module.exports = [
"[project]/node_modules/delayed-stream/lib/delayed_stream.js [app-ssr] (ecmascript)", ((__turbopack_context__, module, exports) => {

var Stream = __turbopack_context__.r("[externals]/stream [external] (stream, cjs)").Stream;
var util = __turbopack_context__.r("[externals]/util [external] (util, cjs)");
module.exports = DelayedStream;
function DelayedStream() {
    this.source = null;
    this.dataSize = 0;
    this.maxDataSize = 1024 * 1024;
    this.pauseStream = true;
    this._maxDataSizeExceeded = false;
    this._released = false;
    this._bufferedEvents = [];
}
util.inherits(DelayedStream, Stream);
DelayedStream.create = function(source, options) {
    var delayedStream = new this();
    options = options || {};
    for(var option in options){
        delayedStream[option] = options[option];
    }
    delayedStream.source = source;
    var realEmit = source.emit;
    source.emit = function() {
        delayedStream._handleEmit(arguments);
        return realEmit.apply(source, arguments);
    };
    source.on('error', function() {});
    if (delayedStream.pauseStream) {
        source.pause();
    }
    return delayedStream;
};
Object.defineProperty(DelayedStream.prototype, 'readable', {
    configurable: true,
    enumerable: true,
    get: function() {
        return this.source.readable;
    }
});
DelayedStream.prototype.setEncoding = function() {
    return this.source.setEncoding.apply(this.source, arguments);
};
DelayedStream.prototype.resume = function() {
    if (!this._released) {
        this.release();
    }
    this.source.resume();
};
DelayedStream.prototype.pause = function() {
    this.source.pause();
};
DelayedStream.prototype.release = function() {
    this._released = true;
    this._bufferedEvents.forEach((function(args) {
        this.emit.apply(this, args);
    }).bind(this));
    this._bufferedEvents = [];
};
DelayedStream.prototype.pipe = function() {
    var r = Stream.prototype.pipe.apply(this, arguments);
    this.resume();
    return r;
};
DelayedStream.prototype._handleEmit = function(args) {
    if (this._released) {
        this.emit.apply(this, args);
        return;
    }
    if (args[0] === 'data') {
        this.dataSize += args[1].length;
        this._checkIfMaxDataSizeExceeded();
    }
    this._bufferedEvents.push(args);
};
DelayedStream.prototype._checkIfMaxDataSizeExceeded = function() {
    if (this._maxDataSizeExceeded) {
        return;
    }
    if (this.dataSize <= this.maxDataSize) {
        return;
    }
    this._maxDataSizeExceeded = true;
    var message = 'DelayedStream#maxDataSize of ' + this.maxDataSize + ' bytes exceeded.';
    this.emit('error', new Error(message));
};
}),
"[project]/node_modules/combined-stream/lib/combined_stream.js [app-ssr] (ecmascript)", ((__turbopack_context__, module, exports) => {

var util = __turbopack_context__.r("[externals]/util [external] (util, cjs)");
var Stream = __turbopack_context__.r("[externals]/stream [external] (stream, cjs)").Stream;
var DelayedStream = __turbopack_context__.r("[project]/node_modules/delayed-stream/lib/delayed_stream.js [app-ssr] (ecmascript)");
module.exports = CombinedStream;
function CombinedStream() {
    this.writable = false;
    this.readable = true;
    this.dataSize = 0;
    this.maxDataSize = 2 * 1024 * 1024;
    this.pauseStreams = true;
    this._released = false;
    this._streams = [];
    this._currentStream = null;
    this._insideLoop = false;
    this._pendingNext = false;
}
util.inherits(CombinedStream, Stream);
CombinedStream.create = function(options) {
    var combinedStream = new this();
    options = options || {};
    for(var option in options){
        combinedStream[option] = options[option];
    }
    return combinedStream;
};
CombinedStream.isStreamLike = function(stream) {
    return typeof stream !== 'function' && typeof stream !== 'string' && typeof stream !== 'boolean' && typeof stream !== 'number' && !Buffer.isBuffer(stream);
};
CombinedStream.prototype.append = function(stream) {
    var isStreamLike = CombinedStream.isStreamLike(stream);
    if (isStreamLike) {
        if (!(stream instanceof DelayedStream)) {
            var newStream = DelayedStream.create(stream, {
                maxDataSize: Infinity,
                pauseStream: this.pauseStreams
            });
            stream.on('data', this._checkDataSize.bind(this));
            stream = newStream;
        }
        this._handleErrors(stream);
        if (this.pauseStreams) {
            stream.pause();
        }
    }
    this._streams.push(stream);
    return this;
};
CombinedStream.prototype.pipe = function(dest, options) {
    Stream.prototype.pipe.call(this, dest, options);
    this.resume();
    return dest;
};
CombinedStream.prototype._getNext = function() {
    this._currentStream = null;
    if (this._insideLoop) {
        this._pendingNext = true;
        return; // defer call
    }
    this._insideLoop = true;
    try {
        do {
            this._pendingNext = false;
            this._realGetNext();
        }while (this._pendingNext)
    } finally{
        this._insideLoop = false;
    }
};
CombinedStream.prototype._realGetNext = function() {
    var stream = this._streams.shift();
    if (typeof stream == 'undefined') {
        this.end();
        return;
    }
    if (typeof stream !== 'function') {
        this._pipeNext(stream);
        return;
    }
    var getStream = stream;
    getStream((function(stream) {
        var isStreamLike = CombinedStream.isStreamLike(stream);
        if (isStreamLike) {
            stream.on('data', this._checkDataSize.bind(this));
            this._handleErrors(stream);
        }
        this._pipeNext(stream);
    }).bind(this));
};
CombinedStream.prototype._pipeNext = function(stream) {
    this._currentStream = stream;
    var isStreamLike = CombinedStream.isStreamLike(stream);
    if (isStreamLike) {
        stream.on('end', this._getNext.bind(this));
        stream.pipe(this, {
            end: false
        });
        return;
    }
    var value = stream;
    this.write(value);
    this._getNext();
};
CombinedStream.prototype._handleErrors = function(stream) {
    var self = this;
    stream.on('error', function(err) {
        self._emitError(err);
    });
};
CombinedStream.prototype.write = function(data) {
    this.emit('data', data);
};
CombinedStream.prototype.pause = function() {
    if (!this.pauseStreams) {
        return;
    }
    if (this.pauseStreams && this._currentStream && typeof this._currentStream.pause == 'function') this._currentStream.pause();
    this.emit('pause');
};
CombinedStream.prototype.resume = function() {
    if (!this._released) {
        this._released = true;
        this.writable = true;
        this._getNext();
    }
    if (this.pauseStreams && this._currentStream && typeof this._currentStream.resume == 'function') this._currentStream.resume();
    this.emit('resume');
};
CombinedStream.prototype.end = function() {
    this._reset();
    this.emit('end');
};
CombinedStream.prototype.destroy = function() {
    this._reset();
    this.emit('close');
};
CombinedStream.prototype._reset = function() {
    this.writable = false;
    this._streams = [];
    this._currentStream = null;
};
CombinedStream.prototype._checkDataSize = function() {
    this._updateDataSize();
    if (this.dataSize <= this.maxDataSize) {
        return;
    }
    var message = 'DelayedStream#maxDataSize of ' + this.maxDataSize + ' bytes exceeded.';
    this._emitError(new Error(message));
};
CombinedStream.prototype._updateDataSize = function() {
    this.dataSize = 0;
    var self = this;
    this._streams.forEach(function(stream) {
        if (!stream.dataSize) {
            return;
        }
        self.dataSize += stream.dataSize;
    });
    if (this._currentStream && this._currentStream.dataSize) {
        this.dataSize += this._currentStream.dataSize;
    }
};
CombinedStream.prototype._emitError = function(err) {
    this._reset();
    this.emit('error', err);
};
}),
"[project]/node_modules/mime-types/index.js [app-ssr] (ecmascript)", ((__turbopack_context__, module, exports) => {
"use strict";

/*!
 * mime-types
 * Copyright(c) 2014 Jonathan Ong
 * Copyright(c) 2015 Douglas Christopher Wilson
 * MIT Licensed
 */ /**
 * Module dependencies.
 * @private
 */ var db = __turbopack_context__.r("[project]/node_modules/mime-db/index.js [app-ssr] (ecmascript)");
var extname = __turbopack_context__.r("[externals]/path [external] (path, cjs)").extname;
/**
 * Module variables.
 * @private
 */ var EXTRACT_TYPE_REGEXP = /^\s*([^;\s]*)(?:;|\s|$)/;
var TEXT_TYPE_REGEXP = /^text\//i;
/**
 * Module exports.
 * @public
 */ exports.charset = charset;
exports.charsets = {
    lookup: charset
};
exports.contentType = contentType;
exports.extension = extension;
exports.extensions = Object.create(null);
exports.lookup = lookup;
exports.types = Object.create(null);
// Populate the extensions/types maps
populateMaps(exports.extensions, exports.types);
/**
 * Get the default charset for a MIME type.
 *
 * @param {string} type
 * @return {boolean|string}
 */ function charset(type) {
    if (!type || typeof type !== 'string') {
        return false;
    }
    // TODO: use media-typer
    var match = EXTRACT_TYPE_REGEXP.exec(type);
    var mime = match && db[match[1].toLowerCase()];
    if (mime && mime.charset) {
        return mime.charset;
    }
    // default text/* to utf-8
    if (match && TEXT_TYPE_REGEXP.test(match[1])) {
        return 'UTF-8';
    }
    return false;
}
/**
 * Create a full Content-Type header given a MIME type or extension.
 *
 * @param {string} str
 * @return {boolean|string}
 */ function contentType(str) {
    // TODO: should this even be in this module?
    if (!str || typeof str !== 'string') {
        return false;
    }
    var mime = str.indexOf('/') === -1 ? exports.lookup(str) : str;
    if (!mime) {
        return false;
    }
    // TODO: use content-type or other module
    if (mime.indexOf('charset') === -1) {
        var charset = exports.charset(mime);
        if (charset) mime += '; charset=' + charset.toLowerCase();
    }
    return mime;
}
/**
 * Get the default extension for a MIME type.
 *
 * @param {string} type
 * @return {boolean|string}
 */ function extension(type) {
    if (!type || typeof type !== 'string') {
        return false;
    }
    // TODO: use media-typer
    var match = EXTRACT_TYPE_REGEXP.exec(type);
    // get extensions
    var exts = match && exports.extensions[match[1].toLowerCase()];
    if (!exts || !exts.length) {
        return false;
    }
    return exts[0];
}
/**
 * Lookup the MIME type for a file path/extension.
 *
 * @param {string} path
 * @return {boolean|string}
 */ function lookup(path) {
    if (!path || typeof path !== 'string') {
        return false;
    }
    // get the extension ("ext" or ".ext" or full path)
    var extension = extname('x.' + path).toLowerCase().substr(1);
    if (!extension) {
        return false;
    }
    return exports.types[extension] || false;
}
/**
 * Populate the extensions and types maps.
 * @private
 */ function populateMaps(extensions, types) {
    // source preference (least -> most)
    var preference = [
        'nginx',
        'apache',
        undefined,
        'iana'
    ];
    Object.keys(db).forEach(function forEachMimeType(type) {
        var mime = db[type];
        var exts = mime.extensions;
        if (!exts || !exts.length) {
            return;
        }
        // mime -> extensions
        extensions[type] = exts;
        // extension -> mime
        for(var i = 0; i < exts.length; i++){
            var extension = exts[i];
            if (types[extension]) {
                var from = preference.indexOf(db[types[extension]].source);
                var to = preference.indexOf(mime.source);
                if (types[extension] !== 'application/octet-stream' && (from > to || from === to && types[extension].substr(0, 12) === 'application/')) {
                    continue;
                }
            }
            // set the extension -> mime
            types[extension] = type;
        }
    });
}
}),
"[project]/node_modules/asynckit/lib/defer.js [app-ssr] (ecmascript)", ((__turbopack_context__, module, exports) => {

module.exports = defer;
/**
 * Runs provided function on next iteration of the event loop
 *
 * @param {function} fn - function to run
 */ function defer(fn) {
    var nextTick = typeof setImmediate == 'function' ? setImmediate : typeof process == 'object' && typeof process.nextTick == 'function' ? process.nextTick : null;
    if (nextTick) {
        nextTick(fn);
    } else {
        setTimeout(fn, 0);
    }
}
}),
"[project]/node_modules/asynckit/lib/async.js [app-ssr] (ecmascript)", ((__turbopack_context__, module, exports) => {

var defer = __turbopack_context__.r("[project]/node_modules/asynckit/lib/defer.js [app-ssr] (ecmascript)");
// API
module.exports = async;
/**
 * Runs provided callback asynchronously
 * even if callback itself is not
 *
 * @param   {function} callback - callback to invoke
 * @returns {function} - augmented callback
 */ function async(callback) {
    var isAsync = false;
    // check if async happened
    defer(function() {
        isAsync = true;
    });
    return function async_callback(err, result) {
        if (isAsync) {
            callback(err, result);
        } else {
            defer(function nextTick_callback() {
                callback(err, result);
            });
        }
    };
}
}),
"[project]/node_modules/asynckit/lib/abort.js [app-ssr] (ecmascript)", ((__turbopack_context__, module, exports) => {

// API
module.exports = abort;
/**
 * Aborts leftover active jobs
 *
 * @param {object} state - current state object
 */ function abort(state) {
    Object.keys(state.jobs).forEach(clean.bind(state));
    // reset leftover jobs
    state.jobs = {};
}
/**
 * Cleans up leftover job by invoking abort function for the provided job id
 *
 * @this  state
 * @param {string|number} key - job id to abort
 */ function clean(key) {
    if (typeof this.jobs[key] == 'function') {
        this.jobs[key]();
    }
}
}),
"[project]/node_modules/asynckit/lib/iterate.js [app-ssr] (ecmascript)", ((__turbopack_context__, module, exports) => {

var async = __turbopack_context__.r("[project]/node_modules/asynckit/lib/async.js [app-ssr] (ecmascript)"), abort = __turbopack_context__.r("[project]/node_modules/asynckit/lib/abort.js [app-ssr] (ecmascript)");
// API
module.exports = iterate;
/**
 * Iterates over each job object
 *
 * @param {array|object} list - array or object (named list) to iterate over
 * @param {function} iterator - iterator to run
 * @param {object} state - current job status
 * @param {function} callback - invoked when all elements processed
 */ function iterate(list, iterator, state, callback) {
    // store current index
    var key = state['keyedList'] ? state['keyedList'][state.index] : state.index;
    state.jobs[key] = runJob(iterator, key, list[key], function(error, output) {
        // don't repeat yourself
        // skip secondary callbacks
        if (!(key in state.jobs)) {
            return;
        }
        // clean up jobs
        delete state.jobs[key];
        if (error) {
            // don't process rest of the results
            // stop still active jobs
            // and reset the list
            abort(state);
        } else {
            state.results[key] = output;
        }
        // return salvaged results
        callback(error, state.results);
    });
}
/**
 * Runs iterator over provided job element
 *
 * @param   {function} iterator - iterator to invoke
 * @param   {string|number} key - key/index of the element in the list of jobs
 * @param   {mixed} item - job description
 * @param   {function} callback - invoked after iterator is done with the job
 * @returns {function|mixed} - job abort function or something else
 */ function runJob(iterator, key, item, callback) {
    var aborter;
    // allow shortcut if iterator expects only two arguments
    if (iterator.length == 2) {
        aborter = iterator(item, async(callback));
    } else {
        aborter = iterator(item, key, async(callback));
    }
    return aborter;
}
}),
"[project]/node_modules/asynckit/lib/state.js [app-ssr] (ecmascript)", ((__turbopack_context__, module, exports) => {

// API
module.exports = state;
/**
 * Creates initial state object
 * for iteration over list
 *
 * @param   {array|object} list - list to iterate over
 * @param   {function|null} sortMethod - function to use for keys sort,
 *                                     or `null` to keep them as is
 * @returns {object} - initial state object
 */ function state(list, sortMethod) {
    var isNamedList = !Array.isArray(list), initState = {
        index: 0,
        keyedList: isNamedList || sortMethod ? Object.keys(list) : null,
        jobs: {},
        results: isNamedList ? {} : [],
        size: isNamedList ? Object.keys(list).length : list.length
    };
    if (sortMethod) {
        // sort array keys based on it's values
        // sort object's keys just on own merit
        initState.keyedList.sort(isNamedList ? sortMethod : function(a, b) {
            return sortMethod(list[a], list[b]);
        });
    }
    return initState;
}
}),
"[project]/node_modules/asynckit/lib/terminator.js [app-ssr] (ecmascript)", ((__turbopack_context__, module, exports) => {

var abort = __turbopack_context__.r("[project]/node_modules/asynckit/lib/abort.js [app-ssr] (ecmascript)"), async = __turbopack_context__.r("[project]/node_modules/asynckit/lib/async.js [app-ssr] (ecmascript)");
// API
module.exports = terminator;
/**
 * Terminates jobs in the attached state context
 *
 * @this  AsyncKitState#
 * @param {function} callback - final callback to invoke after termination
 */ function terminator(callback) {
    if (!Object.keys(this.jobs).length) {
        return;
    }
    // fast forward iteration index
    this.index = this.size;
    // abort jobs
    abort(this);
    // send back results we have so far
    async(callback)(null, this.results);
}
}),
"[project]/node_modules/asynckit/parallel.js [app-ssr] (ecmascript)", ((__turbopack_context__, module, exports) => {

var iterate = __turbopack_context__.r("[project]/node_modules/asynckit/lib/iterate.js [app-ssr] (ecmascript)"), initState = __turbopack_context__.r("[project]/node_modules/asynckit/lib/state.js [app-ssr] (ecmascript)"), terminator = __turbopack_context__.r("[project]/node_modules/asynckit/lib/terminator.js [app-ssr] (ecmascript)");
// Public API
module.exports = parallel;
/**
 * Runs iterator over provided array elements in parallel
 *
 * @param   {array|object} list - array or object (named list) to iterate over
 * @param   {function} iterator - iterator to run
 * @param   {function} callback - invoked when all elements processed
 * @returns {function} - jobs terminator
 */ function parallel(list, iterator, callback) {
    var state = initState(list);
    while(state.index < (state['keyedList'] || list).length){
        iterate(list, iterator, state, function(error, result) {
            if (error) {
                callback(error, result);
                return;
            }
            // looks like it's the last one
            if (Object.keys(state.jobs).length === 0) {
                callback(null, state.results);
                return;
            }
        });
        state.index++;
    }
    return terminator.bind(state, callback);
}
}),
"[project]/node_modules/asynckit/serialOrdered.js [app-ssr] (ecmascript)", ((__turbopack_context__, module, exports) => {

var iterate = __turbopack_context__.r("[project]/node_modules/asynckit/lib/iterate.js [app-ssr] (ecmascript)"), initState = __turbopack_context__.r("[project]/node_modules/asynckit/lib/state.js [app-ssr] (ecmascript)"), terminator = __turbopack_context__.r("[project]/node_modules/asynckit/lib/terminator.js [app-ssr] (ecmascript)");
// Public API
module.exports = serialOrdered;
// sorting helpers
module.exports.ascending = ascending;
module.exports.descending = descending;
/**
 * Runs iterator over provided sorted array elements in series
 *
 * @param   {array|object} list - array or object (named list) to iterate over
 * @param   {function} iterator - iterator to run
 * @param   {function} sortMethod - custom sort function
 * @param   {function} callback - invoked when all elements processed
 * @returns {function} - jobs terminator
 */ function serialOrdered(list, iterator, sortMethod, callback) {
    var state = initState(list, sortMethod);
    iterate(list, iterator, state, function iteratorHandler(error, result) {
        if (error) {
            callback(error, result);
            return;
        }
        state.index++;
        // are we there yet?
        if (state.index < (state['keyedList'] || list).length) {
            iterate(list, iterator, state, iteratorHandler);
            return;
        }
        // done here
        callback(null, state.results);
    });
    return terminator.bind(state, callback);
}
/*
 * -- Sort methods
 */ /**
 * sort helper to sort array elements in ascending order
 *
 * @param   {mixed} a - an item to compare
 * @param   {mixed} b - an item to compare
 * @returns {number} - comparison result
 */ function ascending(a, b) {
    return a < b ? -1 : a > b ? 1 : 0;
}
/**
 * sort helper to sort array elements in descending order
 *
 * @param   {mixed} a - an item to compare
 * @param   {mixed} b - an item to compare
 * @returns {number} - comparison result
 */ function descending(a, b) {
    return -1 * ascending(a, b);
}
}),
"[project]/node_modules/asynckit/serial.js [app-ssr] (ecmascript)", ((__turbopack_context__, module, exports) => {

var serialOrdered = __turbopack_context__.r("[project]/node_modules/asynckit/serialOrdered.js [app-ssr] (ecmascript)");
// Public API
module.exports = serial;
/**
 * Runs iterator over provided array elements in series
 *
 * @param   {array|object} list - array or object (named list) to iterate over
 * @param   {function} iterator - iterator to run
 * @param   {function} callback - invoked when all elements processed
 * @returns {function} - jobs terminator
 */ function serial(list, iterator, callback) {
    return serialOrdered(list, iterator, null, callback);
}
}),
"[project]/node_modules/asynckit/index.js [app-ssr] (ecmascript)", ((__turbopack_context__, module, exports) => {

module.exports = {
    parallel: __turbopack_context__.r("[project]/node_modules/asynckit/parallel.js [app-ssr] (ecmascript)"),
    serial: __turbopack_context__.r("[project]/node_modules/asynckit/serial.js [app-ssr] (ecmascript)"),
    serialOrdered: __turbopack_context__.r("[project]/node_modules/asynckit/serialOrdered.js [app-ssr] (ecmascript)")
};
}),
"[project]/node_modules/es-object-atoms/index.js [app-ssr] (ecmascript)", ((__turbopack_context__, module, exports) => {
"use strict";

/** @type {import('.')} */ module.exports = Object;
}),
"[project]/node_modules/es-errors/index.js [app-ssr] (ecmascript)", ((__turbopack_context__, module, exports) => {
"use strict";

/** @type {import('.')} */ module.exports = Error;
}),
"[project]/node_modules/es-errors/eval.js [app-ssr] (ecmascript)", ((__turbopack_context__, module, exports) => {
"use strict";

/** @type {import('./eval')} */ module.exports = EvalError;
}),
"[project]/node_modules/es-errors/range.js [app-ssr] (ecmascript)", ((__turbopack_context__, module, exports) => {
"use strict";

/** @type {import('./range')} */ module.exports = RangeError;
}),
"[project]/node_modules/es-errors/ref.js [app-ssr] (ecmascript)", ((__turbopack_context__, module, exports) => {
"use strict";

/** @type {import('./ref')} */ module.exports = ReferenceError;
}),
"[project]/node_modules/es-errors/syntax.js [app-ssr] (ecmascript)", ((__turbopack_context__, module, exports) => {
"use strict";

/** @type {import('./syntax')} */ module.exports = SyntaxError;
}),
"[project]/node_modules/es-errors/type.js [app-ssr] (ecmascript)", ((__turbopack_context__, module, exports) => {
"use strict";

/** @type {import('./type')} */ module.exports = TypeError;
}),
"[project]/node_modules/es-errors/uri.js [app-ssr] (ecmascript)", ((__turbopack_context__, module, exports) => {
"use strict";

/** @type {import('./uri')} */ module.exports = URIError;
}),
"[project]/node_modules/math-intrinsics/abs.js [app-ssr] (ecmascript)", ((__turbopack_context__, module, exports) => {
"use strict";

/** @type {import('./abs')} */ module.exports = Math.abs;
}),
"[project]/node_modules/math-intrinsics/floor.js [app-ssr] (ecmascript)", ((__turbopack_context__, module, exports) => {
"use strict";

/** @type {import('./floor')} */ module.exports = Math.floor;
}),
"[project]/node_modules/math-intrinsics/max.js [app-ssr] (ecmascript)", ((__turbopack_context__, module, exports) => {
"use strict";

/** @type {import('./max')} */ module.exports = Math.max;
}),
"[project]/node_modules/math-intrinsics/min.js [app-ssr] (ecmascript)", ((__turbopack_context__, module, exports) => {
"use strict";

/** @type {import('./min')} */ module.exports = Math.min;
}),
"[project]/node_modules/math-intrinsics/pow.js [app-ssr] (ecmascript)", ((__turbopack_context__, module, exports) => {
"use strict";

/** @type {import('./pow')} */ module.exports = Math.pow;
}),
"[project]/node_modules/math-intrinsics/round.js [app-ssr] (ecmascript)", ((__turbopack_context__, module, exports) => {
"use strict";

/** @type {import('./round')} */ module.exports = Math.round;
}),
"[project]/node_modules/math-intrinsics/isNaN.js [app-ssr] (ecmascript)", ((__turbopack_context__, module, exports) => {
"use strict";

/** @type {import('./isNaN')} */ module.exports = Number.isNaN || function isNaN(a) {
    return a !== a;
};
}),
"[project]/node_modules/math-intrinsics/sign.js [app-ssr] (ecmascript)", ((__turbopack_context__, module, exports) => {
"use strict";

var $isNaN = __turbopack_context__.r("[project]/node_modules/math-intrinsics/isNaN.js [app-ssr] (ecmascript)");
/** @type {import('./sign')} */ module.exports = function sign(number) {
    if ($isNaN(number) || number === 0) {
        return number;
    }
    return number < 0 ? -1 : +1;
};
}),
"[project]/node_modules/gopd/gOPD.js [app-ssr] (ecmascript)", ((__turbopack_context__, module, exports) => {
"use strict";

/** @type {import('./gOPD')} */ module.exports = Object.getOwnPropertyDescriptor;
}),
"[project]/node_modules/gopd/index.js [app-ssr] (ecmascript)", ((__turbopack_context__, module, exports) => {
"use strict";

/** @type {import('.')} */ var $gOPD = __turbopack_context__.r("[project]/node_modules/gopd/gOPD.js [app-ssr] (ecmascript)");
if ($gOPD) {
    try {
        $gOPD([], 'length');
    } catch (e) {
        // IE 8 has a broken gOPD
        $gOPD = null;
    }
}
module.exports = $gOPD;
}),
"[project]/node_modules/es-define-property/index.js [app-ssr] (ecmascript)", ((__turbopack_context__, module, exports) => {
"use strict";

/** @type {import('.')} */ var $defineProperty = Object.defineProperty || false;
if ($defineProperty) {
    try {
        $defineProperty({}, 'a', {
            value: 1
        });
    } catch (e) {
        // IE 8 has a broken defineProperty
        $defineProperty = false;
    }
}
module.exports = $defineProperty;
}),
"[project]/node_modules/has-symbols/shams.js [app-ssr] (ecmascript)", ((__turbopack_context__, module, exports) => {
"use strict";

/** @type {import('./shams')} */ /* eslint complexity: [2, 18], max-statements: [2, 33] */ module.exports = function hasSymbols() {
    if (typeof Symbol !== 'function' || typeof Object.getOwnPropertySymbols !== 'function') {
        return false;
    }
    if (typeof Symbol.iterator === 'symbol') {
        return true;
    }
    /** @type {{ [k in symbol]?: unknown }} */ var obj = {};
    var sym = Symbol('test');
    var symObj = Object(sym);
    if (typeof sym === 'string') {
        return false;
    }
    if (Object.prototype.toString.call(sym) !== '[object Symbol]') {
        return false;
    }
    if (Object.prototype.toString.call(symObj) !== '[object Symbol]') {
        return false;
    }
    // temp disabled per https://github.com/ljharb/object.assign/issues/17
    // if (sym instanceof Symbol) { return false; }
    // temp disabled per https://github.com/WebReflection/get-own-property-symbols/issues/4
    // if (!(symObj instanceof Symbol)) { return false; }
    // if (typeof Symbol.prototype.toString !== 'function') { return false; }
    // if (String(sym) !== Symbol.prototype.toString.call(sym)) { return false; }
    var symVal = 42;
    obj[sym] = symVal;
    for(var _ in obj){
        return false;
    } // eslint-disable-line no-restricted-syntax, no-unreachable-loop
    if (typeof Object.keys === 'function' && Object.keys(obj).length !== 0) {
        return false;
    }
    if (typeof Object.getOwnPropertyNames === 'function' && Object.getOwnPropertyNames(obj).length !== 0) {
        return false;
    }
    var syms = Object.getOwnPropertySymbols(obj);
    if (syms.length !== 1 || syms[0] !== sym) {
        return false;
    }
    if (!Object.prototype.propertyIsEnumerable.call(obj, sym)) {
        return false;
    }
    if (typeof Object.getOwnPropertyDescriptor === 'function') {
        // eslint-disable-next-line no-extra-parens
        var descriptor = Object.getOwnPropertyDescriptor(obj, sym);
        if (descriptor.value !== symVal || descriptor.enumerable !== true) {
            return false;
        }
    }
    return true;
};
}),
"[project]/node_modules/has-symbols/index.js [app-ssr] (ecmascript)", ((__turbopack_context__, module, exports) => {
"use strict";

var origSymbol = typeof Symbol !== 'undefined' && Symbol;
var hasSymbolSham = __turbopack_context__.r("[project]/node_modules/has-symbols/shams.js [app-ssr] (ecmascript)");
/** @type {import('.')} */ module.exports = function hasNativeSymbols() {
    if (typeof origSymbol !== 'function') {
        return false;
    }
    if (typeof Symbol !== 'function') {
        return false;
    }
    if (typeof origSymbol('foo') !== 'symbol') {
        return false;
    }
    if (typeof Symbol('bar') !== 'symbol') {
        return false;
    }
    return hasSymbolSham();
};
}),
"[project]/node_modules/get-proto/Reflect.getPrototypeOf.js [app-ssr] (ecmascript)", ((__turbopack_context__, module, exports) => {
"use strict";

/** @type {import('./Reflect.getPrototypeOf')} */ module.exports = typeof Reflect !== 'undefined' && Reflect.getPrototypeOf || null;
}),
"[project]/node_modules/get-proto/Object.getPrototypeOf.js [app-ssr] (ecmascript)", ((__turbopack_context__, module, exports) => {
"use strict";

var $Object = __turbopack_context__.r("[project]/node_modules/es-object-atoms/index.js [app-ssr] (ecmascript)");
/** @type {import('./Object.getPrototypeOf')} */ module.exports = $Object.getPrototypeOf || null;
}),
"[project]/node_modules/get-proto/index.js [app-ssr] (ecmascript)", ((__turbopack_context__, module, exports) => {
"use strict";

var reflectGetProto = __turbopack_context__.r("[project]/node_modules/get-proto/Reflect.getPrototypeOf.js [app-ssr] (ecmascript)");
var originalGetProto = __turbopack_context__.r("[project]/node_modules/get-proto/Object.getPrototypeOf.js [app-ssr] (ecmascript)");
var getDunderProto = __turbopack_context__.r("[project]/node_modules/dunder-proto/get.js [app-ssr] (ecmascript)");
/** @type {import('.')} */ module.exports = reflectGetProto ? function getProto(O) {
    // @ts-expect-error TS can't narrow inside a closure, for some reason
    return reflectGetProto(O);
} : originalGetProto ? function getProto(O) {
    if (!O || typeof O !== 'object' && typeof O !== 'function') {
        throw new TypeError('getProto: not an object');
    }
    // @ts-expect-error TS can't narrow inside a closure, for some reason
    return originalGetProto(O);
} : getDunderProto ? function getProto(O) {
    // @ts-expect-error TS can't narrow inside a closure, for some reason
    return getDunderProto(O);
} : null;
}),
"[project]/node_modules/function-bind/implementation.js [app-ssr] (ecmascript)", ((__turbopack_context__, module, exports) => {
"use strict";

/* eslint no-invalid-this: 1 */ var ERROR_MESSAGE = 'Function.prototype.bind called on incompatible ';
var toStr = Object.prototype.toString;
var max = Math.max;
var funcType = '[object Function]';
var concatty = function concatty(a, b) {
    var arr = [];
    for(var i = 0; i < a.length; i += 1){
        arr[i] = a[i];
    }
    for(var j = 0; j < b.length; j += 1){
        arr[j + a.length] = b[j];
    }
    return arr;
};
var slicy = function slicy(arrLike, offset) {
    var arr = [];
    for(var i = offset || 0, j = 0; i < arrLike.length; i += 1, j += 1){
        arr[j] = arrLike[i];
    }
    return arr;
};
var joiny = function(arr, joiner) {
    var str = '';
    for(var i = 0; i < arr.length; i += 1){
        str += arr[i];
        if (i + 1 < arr.length) {
            str += joiner;
        }
    }
    return str;
};
module.exports = function bind(that) {
    var target = this;
    if (typeof target !== 'function' || toStr.apply(target) !== funcType) {
        throw new TypeError(ERROR_MESSAGE + target);
    }
    var args = slicy(arguments, 1);
    var bound;
    var binder = function() {
        if (this instanceof bound) {
            var result = target.apply(this, concatty(args, arguments));
            if (Object(result) === result) {
                return result;
            }
            return this;
        }
        return target.apply(that, concatty(args, arguments));
    };
    var boundLength = max(0, target.length - args.length);
    var boundArgs = [];
    for(var i = 0; i < boundLength; i++){
        boundArgs[i] = '$' + i;
    }
    bound = Function('binder', 'return function (' + joiny(boundArgs, ',') + '){ return binder.apply(this,arguments); }')(binder);
    if (target.prototype) {
        var Empty = function Empty() {};
        Empty.prototype = target.prototype;
        bound.prototype = new Empty();
        Empty.prototype = null;
    }
    return bound;
};
}),
"[project]/node_modules/function-bind/index.js [app-ssr] (ecmascript)", ((__turbopack_context__, module, exports) => {
"use strict";

var implementation = __turbopack_context__.r("[project]/node_modules/function-bind/implementation.js [app-ssr] (ecmascript)");
module.exports = Function.prototype.bind || implementation;
}),
"[project]/node_modules/call-bind-apply-helpers/functionCall.js [app-ssr] (ecmascript)", ((__turbopack_context__, module, exports) => {
"use strict";

/** @type {import('./functionCall')} */ module.exports = Function.prototype.call;
}),
"[project]/node_modules/call-bind-apply-helpers/functionApply.js [app-ssr] (ecmascript)", ((__turbopack_context__, module, exports) => {
"use strict";

/** @type {import('./functionApply')} */ module.exports = Function.prototype.apply;
}),
"[project]/node_modules/call-bind-apply-helpers/reflectApply.js [app-ssr] (ecmascript)", ((__turbopack_context__, module, exports) => {
"use strict";

/** @type {import('./reflectApply')} */ module.exports = typeof Reflect !== 'undefined' && Reflect && Reflect.apply;
}),
"[project]/node_modules/call-bind-apply-helpers/actualApply.js [app-ssr] (ecmascript)", ((__turbopack_context__, module, exports) => {
"use strict";

var bind = __turbopack_context__.r("[project]/node_modules/function-bind/index.js [app-ssr] (ecmascript)");
var $apply = __turbopack_context__.r("[project]/node_modules/call-bind-apply-helpers/functionApply.js [app-ssr] (ecmascript)");
var $call = __turbopack_context__.r("[project]/node_modules/call-bind-apply-helpers/functionCall.js [app-ssr] (ecmascript)");
var $reflectApply = __turbopack_context__.r("[project]/node_modules/call-bind-apply-helpers/reflectApply.js [app-ssr] (ecmascript)");
/** @type {import('./actualApply')} */ module.exports = $reflectApply || bind.call($call, $apply);
}),
"[project]/node_modules/call-bind-apply-helpers/index.js [app-ssr] (ecmascript)", ((__turbopack_context__, module, exports) => {
"use strict";

var bind = __turbopack_context__.r("[project]/node_modules/function-bind/index.js [app-ssr] (ecmascript)");
var $TypeError = __turbopack_context__.r("[project]/node_modules/es-errors/type.js [app-ssr] (ecmascript)");
var $call = __turbopack_context__.r("[project]/node_modules/call-bind-apply-helpers/functionCall.js [app-ssr] (ecmascript)");
var $actualApply = __turbopack_context__.r("[project]/node_modules/call-bind-apply-helpers/actualApply.js [app-ssr] (ecmascript)");
/** @type {(args: [Function, thisArg?: unknown, ...args: unknown[]]) => Function} TODO FIXME, find a way to use import('.') */ module.exports = function callBindBasic(args) {
    if (args.length < 1 || typeof args[0] !== 'function') {
        throw new $TypeError('a function is required');
    }
    return $actualApply(bind, $call, args);
};
}),
"[project]/node_modules/call-bind-apply-helpers/applyBind.js [app-ssr] (ecmascript)", ((__turbopack_context__, module, exports) => {
"use strict";

var bind = __turbopack_context__.r("[project]/node_modules/function-bind/index.js [app-ssr] (ecmascript)");
var $apply = __turbopack_context__.r("[project]/node_modules/call-bind-apply-helpers/functionApply.js [app-ssr] (ecmascript)");
var actualApply = __turbopack_context__.r("[project]/node_modules/call-bind-apply-helpers/actualApply.js [app-ssr] (ecmascript)");
/** @type {import('./applyBind')} */ module.exports = function applyBind() {
    return actualApply(bind, $apply, arguments);
};
}),
"[project]/node_modules/dunder-proto/get.js [app-ssr] (ecmascript)", ((__turbopack_context__, module, exports) => {
"use strict";

var callBind = __turbopack_context__.r("[project]/node_modules/call-bind-apply-helpers/index.js [app-ssr] (ecmascript)");
var gOPD = __turbopack_context__.r("[project]/node_modules/gopd/index.js [app-ssr] (ecmascript)");
var hasProtoAccessor;
try {
    // eslint-disable-next-line no-extra-parens, no-proto
    hasProtoAccessor = /** @type {{ __proto__?: typeof Array.prototype }} */ [].__proto__ === Array.prototype;
} catch (e) {
    if (!e || typeof e !== 'object' || !('code' in e) || e.code !== 'ERR_PROTO_ACCESS') {
        throw e;
    }
}
// eslint-disable-next-line no-extra-parens
var desc = !!hasProtoAccessor && gOPD && gOPD(Object.prototype, '__proto__');
var $Object = Object;
var $getPrototypeOf = $Object.getPrototypeOf;
/** @type {import('./get')} */ module.exports = desc && typeof desc.get === 'function' ? callBind([
    desc.get
]) : typeof $getPrototypeOf === 'function' ? /** @type {import('./get')} */ function getDunder(value) {
    // eslint-disable-next-line eqeqeq
    return $getPrototypeOf(value == null ? value : $Object(value));
} : false;
}),
"[project]/node_modules/hasown/index.js [app-ssr] (ecmascript)", ((__turbopack_context__, module, exports) => {
"use strict";

var call = Function.prototype.call;
var $hasOwn = Object.prototype.hasOwnProperty;
var bind = __turbopack_context__.r("[project]/node_modules/function-bind/index.js [app-ssr] (ecmascript)");
/** @type {import('.')} */ module.exports = bind.call(call, $hasOwn);
}),
"[project]/node_modules/get-intrinsic/index.js [app-ssr] (ecmascript)", ((__turbopack_context__, module, exports) => {
"use strict";

var undefined1;
var $Object = __turbopack_context__.r("[project]/node_modules/es-object-atoms/index.js [app-ssr] (ecmascript)");
var $Error = __turbopack_context__.r("[project]/node_modules/es-errors/index.js [app-ssr] (ecmascript)");
var $EvalError = __turbopack_context__.r("[project]/node_modules/es-errors/eval.js [app-ssr] (ecmascript)");
var $RangeError = __turbopack_context__.r("[project]/node_modules/es-errors/range.js [app-ssr] (ecmascript)");
var $ReferenceError = __turbopack_context__.r("[project]/node_modules/es-errors/ref.js [app-ssr] (ecmascript)");
var $SyntaxError = __turbopack_context__.r("[project]/node_modules/es-errors/syntax.js [app-ssr] (ecmascript)");
var $TypeError = __turbopack_context__.r("[project]/node_modules/es-errors/type.js [app-ssr] (ecmascript)");
var $URIError = __turbopack_context__.r("[project]/node_modules/es-errors/uri.js [app-ssr] (ecmascript)");
var abs = __turbopack_context__.r("[project]/node_modules/math-intrinsics/abs.js [app-ssr] (ecmascript)");
var floor = __turbopack_context__.r("[project]/node_modules/math-intrinsics/floor.js [app-ssr] (ecmascript)");
var max = __turbopack_context__.r("[project]/node_modules/math-intrinsics/max.js [app-ssr] (ecmascript)");
var min = __turbopack_context__.r("[project]/node_modules/math-intrinsics/min.js [app-ssr] (ecmascript)");
var pow = __turbopack_context__.r("[project]/node_modules/math-intrinsics/pow.js [app-ssr] (ecmascript)");
var round = __turbopack_context__.r("[project]/node_modules/math-intrinsics/round.js [app-ssr] (ecmascript)");
var sign = __turbopack_context__.r("[project]/node_modules/math-intrinsics/sign.js [app-ssr] (ecmascript)");
var $Function = Function;
// eslint-disable-next-line consistent-return
var getEvalledConstructor = function(expressionSyntax) {
    try {
        return $Function('"use strict"; return (' + expressionSyntax + ').constructor;')();
    } catch (e) {}
};
var $gOPD = __turbopack_context__.r("[project]/node_modules/gopd/index.js [app-ssr] (ecmascript)");
var $defineProperty = __turbopack_context__.r("[project]/node_modules/es-define-property/index.js [app-ssr] (ecmascript)");
var throwTypeError = function() {
    throw new $TypeError();
};
var ThrowTypeError = $gOPD ? function() {
    try {
        // eslint-disable-next-line no-unused-expressions, no-caller, no-restricted-properties
        arguments.callee; // IE 8 does not throw here
        return throwTypeError;
    } catch (calleeThrows) {
        try {
            // IE 8 throws on Object.getOwnPropertyDescriptor(arguments, '')
            return $gOPD(arguments, 'callee').get;
        } catch (gOPDthrows) {
            return throwTypeError;
        }
    }
}() : throwTypeError;
var hasSymbols = __turbopack_context__.r("[project]/node_modules/has-symbols/index.js [app-ssr] (ecmascript)")();
var getProto = __turbopack_context__.r("[project]/node_modules/get-proto/index.js [app-ssr] (ecmascript)");
var $ObjectGPO = __turbopack_context__.r("[project]/node_modules/get-proto/Object.getPrototypeOf.js [app-ssr] (ecmascript)");
var $ReflectGPO = __turbopack_context__.r("[project]/node_modules/get-proto/Reflect.getPrototypeOf.js [app-ssr] (ecmascript)");
var $apply = __turbopack_context__.r("[project]/node_modules/call-bind-apply-helpers/functionApply.js [app-ssr] (ecmascript)");
var $call = __turbopack_context__.r("[project]/node_modules/call-bind-apply-helpers/functionCall.js [app-ssr] (ecmascript)");
var needsEval = {};
var TypedArray = typeof Uint8Array === 'undefined' || !getProto ? undefined : getProto(Uint8Array);
var INTRINSICS = {
    __proto__: null,
    '%AggregateError%': typeof AggregateError === 'undefined' ? undefined : AggregateError,
    '%Array%': Array,
    '%ArrayBuffer%': typeof ArrayBuffer === 'undefined' ? undefined : ArrayBuffer,
    '%ArrayIteratorPrototype%': hasSymbols && getProto ? getProto([][Symbol.iterator]()) : undefined,
    '%AsyncFromSyncIteratorPrototype%': undefined,
    '%AsyncFunction%': needsEval,
    '%AsyncGenerator%': needsEval,
    '%AsyncGeneratorFunction%': needsEval,
    '%AsyncIteratorPrototype%': needsEval,
    '%Atomics%': typeof Atomics === 'undefined' ? undefined : Atomics,
    '%BigInt%': typeof BigInt === 'undefined' ? undefined : BigInt,
    '%BigInt64Array%': typeof BigInt64Array === 'undefined' ? undefined : BigInt64Array,
    '%BigUint64Array%': typeof BigUint64Array === 'undefined' ? undefined : BigUint64Array,
    '%Boolean%': Boolean,
    '%DataView%': typeof DataView === 'undefined' ? undefined : DataView,
    '%Date%': Date,
    '%decodeURI%': decodeURI,
    '%decodeURIComponent%': decodeURIComponent,
    '%encodeURI%': encodeURI,
    '%encodeURIComponent%': encodeURIComponent,
    '%Error%': $Error,
    '%eval%': eval,
    '%EvalError%': $EvalError,
    '%Float16Array%': typeof Float16Array === 'undefined' ? undefined : Float16Array,
    '%Float32Array%': typeof Float32Array === 'undefined' ? undefined : Float32Array,
    '%Float64Array%': typeof Float64Array === 'undefined' ? undefined : Float64Array,
    '%FinalizationRegistry%': typeof FinalizationRegistry === 'undefined' ? undefined : FinalizationRegistry,
    '%Function%': $Function,
    '%GeneratorFunction%': needsEval,
    '%Int8Array%': typeof Int8Array === 'undefined' ? undefined : Int8Array,
    '%Int16Array%': typeof Int16Array === 'undefined' ? undefined : Int16Array,
    '%Int32Array%': typeof Int32Array === 'undefined' ? undefined : Int32Array,
    '%isFinite%': isFinite,
    '%isNaN%': isNaN,
    '%IteratorPrototype%': hasSymbols && getProto ? getProto(getProto([][Symbol.iterator]())) : undefined,
    '%JSON%': typeof JSON === 'object' ? JSON : undefined,
    '%Map%': typeof Map === 'undefined' ? undefined : Map,
    '%MapIteratorPrototype%': typeof Map === 'undefined' || !hasSymbols || !getProto ? undefined : getProto(new Map()[Symbol.iterator]()),
    '%Math%': Math,
    '%Number%': Number,
    '%Object%': $Object,
    '%Object.getOwnPropertyDescriptor%': $gOPD,
    '%parseFloat%': parseFloat,
    '%parseInt%': parseInt,
    '%Promise%': typeof Promise === 'undefined' ? undefined : Promise,
    '%Proxy%': typeof Proxy === 'undefined' ? undefined : Proxy,
    '%RangeError%': $RangeError,
    '%ReferenceError%': $ReferenceError,
    '%Reflect%': typeof Reflect === 'undefined' ? undefined : Reflect,
    '%RegExp%': RegExp,
    '%Set%': typeof Set === 'undefined' ? undefined : Set,
    '%SetIteratorPrototype%': typeof Set === 'undefined' || !hasSymbols || !getProto ? undefined : getProto(new Set()[Symbol.iterator]()),
    '%SharedArrayBuffer%': typeof SharedArrayBuffer === 'undefined' ? undefined : SharedArrayBuffer,
    '%String%': String,
    '%StringIteratorPrototype%': hasSymbols && getProto ? getProto(''[Symbol.iterator]()) : undefined,
    '%Symbol%': hasSymbols ? Symbol : undefined,
    '%SyntaxError%': $SyntaxError,
    '%ThrowTypeError%': ThrowTypeError,
    '%TypedArray%': TypedArray,
    '%TypeError%': $TypeError,
    '%Uint8Array%': typeof Uint8Array === 'undefined' ? undefined : Uint8Array,
    '%Uint8ClampedArray%': typeof Uint8ClampedArray === 'undefined' ? undefined : Uint8ClampedArray,
    '%Uint16Array%': typeof Uint16Array === 'undefined' ? undefined : Uint16Array,
    '%Uint32Array%': typeof Uint32Array === 'undefined' ? undefined : Uint32Array,
    '%URIError%': $URIError,
    '%WeakMap%': typeof WeakMap === 'undefined' ? undefined : WeakMap,
    '%WeakRef%': typeof WeakRef === 'undefined' ? undefined : WeakRef,
    '%WeakSet%': typeof WeakSet === 'undefined' ? undefined : WeakSet,
    '%Function.prototype.call%': $call,
    '%Function.prototype.apply%': $apply,
    '%Object.defineProperty%': $defineProperty,
    '%Object.getPrototypeOf%': $ObjectGPO,
    '%Math.abs%': abs,
    '%Math.floor%': floor,
    '%Math.max%': max,
    '%Math.min%': min,
    '%Math.pow%': pow,
    '%Math.round%': round,
    '%Math.sign%': sign,
    '%Reflect.getPrototypeOf%': $ReflectGPO
};
if (getProto) {
    try {
        null.error; // eslint-disable-line no-unused-expressions
    } catch (e) {
        // https://github.com/tc39/proposal-shadowrealm/pull/384#issuecomment-1364264229
        var errorProto = getProto(getProto(e));
        INTRINSICS['%Error.prototype%'] = errorProto;
    }
}
var doEval = function doEval(name) {
    var value;
    if (name === '%AsyncFunction%') {
        value = getEvalledConstructor('async function () {}');
    } else if (name === '%GeneratorFunction%') {
        value = getEvalledConstructor('function* () {}');
    } else if (name === '%AsyncGeneratorFunction%') {
        value = getEvalledConstructor('async function* () {}');
    } else if (name === '%AsyncGenerator%') {
        var fn = doEval('%AsyncGeneratorFunction%');
        if (fn) {
            value = fn.prototype;
        }
    } else if (name === '%AsyncIteratorPrototype%') {
        var gen = doEval('%AsyncGenerator%');
        if (gen && getProto) {
            value = getProto(gen.prototype);
        }
    }
    INTRINSICS[name] = value;
    return value;
};
var LEGACY_ALIASES = {
    __proto__: null,
    '%ArrayBufferPrototype%': [
        'ArrayBuffer',
        'prototype'
    ],
    '%ArrayPrototype%': [
        'Array',
        'prototype'
    ],
    '%ArrayProto_entries%': [
        'Array',
        'prototype',
        'entries'
    ],
    '%ArrayProto_forEach%': [
        'Array',
        'prototype',
        'forEach'
    ],
    '%ArrayProto_keys%': [
        'Array',
        'prototype',
        'keys'
    ],
    '%ArrayProto_values%': [
        'Array',
        'prototype',
        'values'
    ],
    '%AsyncFunctionPrototype%': [
        'AsyncFunction',
        'prototype'
    ],
    '%AsyncGenerator%': [
        'AsyncGeneratorFunction',
        'prototype'
    ],
    '%AsyncGeneratorPrototype%': [
        'AsyncGeneratorFunction',
        'prototype',
        'prototype'
    ],
    '%BooleanPrototype%': [
        'Boolean',
        'prototype'
    ],
    '%DataViewPrototype%': [
        'DataView',
        'prototype'
    ],
    '%DatePrototype%': [
        'Date',
        'prototype'
    ],
    '%ErrorPrototype%': [
        'Error',
        'prototype'
    ],
    '%EvalErrorPrototype%': [
        'EvalError',
        'prototype'
    ],
    '%Float32ArrayPrototype%': [
        'Float32Array',
        'prototype'
    ],
    '%Float64ArrayPrototype%': [
        'Float64Array',
        'prototype'
    ],
    '%FunctionPrototype%': [
        'Function',
        'prototype'
    ],
    '%Generator%': [
        'GeneratorFunction',
        'prototype'
    ],
    '%GeneratorPrototype%': [
        'GeneratorFunction',
        'prototype',
        'prototype'
    ],
    '%Int8ArrayPrototype%': [
        'Int8Array',
        'prototype'
    ],
    '%Int16ArrayPrototype%': [
        'Int16Array',
        'prototype'
    ],
    '%Int32ArrayPrototype%': [
        'Int32Array',
        'prototype'
    ],
    '%JSONParse%': [
        'JSON',
        'parse'
    ],
    '%JSONStringify%': [
        'JSON',
        'stringify'
    ],
    '%MapPrototype%': [
        'Map',
        'prototype'
    ],
    '%NumberPrototype%': [
        'Number',
        'prototype'
    ],
    '%ObjectPrototype%': [
        'Object',
        'prototype'
    ],
    '%ObjProto_toString%': [
        'Object',
        'prototype',
        'toString'
    ],
    '%ObjProto_valueOf%': [
        'Object',
        'prototype',
        'valueOf'
    ],
    '%PromisePrototype%': [
        'Promise',
        'prototype'
    ],
    '%PromiseProto_then%': [
        'Promise',
        'prototype',
        'then'
    ],
    '%Promise_all%': [
        'Promise',
        'all'
    ],
    '%Promise_reject%': [
        'Promise',
        'reject'
    ],
    '%Promise_resolve%': [
        'Promise',
        'resolve'
    ],
    '%RangeErrorPrototype%': [
        'RangeError',
        'prototype'
    ],
    '%ReferenceErrorPrototype%': [
        'ReferenceError',
        'prototype'
    ],
    '%RegExpPrototype%': [
        'RegExp',
        'prototype'
    ],
    '%SetPrototype%': [
        'Set',
        'prototype'
    ],
    '%SharedArrayBufferPrototype%': [
        'SharedArrayBuffer',
        'prototype'
    ],
    '%StringPrototype%': [
        'String',
        'prototype'
    ],
    '%SymbolPrototype%': [
        'Symbol',
        'prototype'
    ],
    '%SyntaxErrorPrototype%': [
        'SyntaxError',
        'prototype'
    ],
    '%TypedArrayPrototype%': [
        'TypedArray',
        'prototype'
    ],
    '%TypeErrorPrototype%': [
        'TypeError',
        'prototype'
    ],
    '%Uint8ArrayPrototype%': [
        'Uint8Array',
        'prototype'
    ],
    '%Uint8ClampedArrayPrototype%': [
        'Uint8ClampedArray',
        'prototype'
    ],
    '%Uint16ArrayPrototype%': [
        'Uint16Array',
        'prototype'
    ],
    '%Uint32ArrayPrototype%': [
        'Uint32Array',
        'prototype'
    ],
    '%URIErrorPrototype%': [
        'URIError',
        'prototype'
    ],
    '%WeakMapPrototype%': [
        'WeakMap',
        'prototype'
    ],
    '%WeakSetPrototype%': [
        'WeakSet',
        'prototype'
    ]
};
var bind = __turbopack_context__.r("[project]/node_modules/function-bind/index.js [app-ssr] (ecmascript)");
var hasOwn = __turbopack_context__.r("[project]/node_modules/hasown/index.js [app-ssr] (ecmascript)");
var $concat = bind.call($call, Array.prototype.concat);
var $spliceApply = bind.call($apply, Array.prototype.splice);
var $replace = bind.call($call, String.prototype.replace);
var $strSlice = bind.call($call, String.prototype.slice);
var $exec = bind.call($call, RegExp.prototype.exec);
/* adapted from https://github.com/lodash/lodash/blob/4.17.15/dist/lodash.js#L6735-L6744 */ var rePropName = /[^%.[\]]+|\[(?:(-?\d+(?:\.\d+)?)|(["'])((?:(?!\2)[^\\]|\\.)*?)\2)\]|(?=(?:\.|\[\])(?:\.|\[\]|%$))/g;
var reEscapeChar = /\\(\\)?/g; /** Used to match backslashes in property paths. */ 
var stringToPath = function stringToPath(string) {
    var first = $strSlice(string, 0, 1);
    var last = $strSlice(string, -1);
    if (first === '%' && last !== '%') {
        throw new $SyntaxError('invalid intrinsic syntax, expected closing `%`');
    } else if (last === '%' && first !== '%') {
        throw new $SyntaxError('invalid intrinsic syntax, expected opening `%`');
    }
    var result = [];
    $replace(string, rePropName, function(match, number, quote, subString) {
        result[result.length] = quote ? $replace(subString, reEscapeChar, '$1') : number || match;
    });
    return result;
};
/* end adaptation */ var getBaseIntrinsic = function getBaseIntrinsic(name, allowMissing) {
    var intrinsicName = name;
    var alias;
    if (hasOwn(LEGACY_ALIASES, intrinsicName)) {
        alias = LEGACY_ALIASES[intrinsicName];
        intrinsicName = '%' + alias[0] + '%';
    }
    if (hasOwn(INTRINSICS, intrinsicName)) {
        var value = INTRINSICS[intrinsicName];
        if (value === needsEval) {
            value = doEval(intrinsicName);
        }
        if (typeof value === 'undefined' && !allowMissing) {
            throw new $TypeError('intrinsic ' + name + ' exists, but is not available. Please file an issue!');
        }
        return {
            alias: alias,
            name: intrinsicName,
            value: value
        };
    }
    throw new $SyntaxError('intrinsic ' + name + ' does not exist!');
};
module.exports = function GetIntrinsic(name, allowMissing) {
    if (typeof name !== 'string' || name.length === 0) {
        throw new $TypeError('intrinsic name must be a non-empty string');
    }
    if (arguments.length > 1 && typeof allowMissing !== 'boolean') {
        throw new $TypeError('"allowMissing" argument must be a boolean');
    }
    if ($exec(/^%?[^%]*%?$/, name) === null) {
        throw new $SyntaxError('`%` may not be present anywhere but at the beginning and end of the intrinsic name');
    }
    var parts = stringToPath(name);
    var intrinsicBaseName = parts.length > 0 ? parts[0] : '';
    var intrinsic = getBaseIntrinsic('%' + intrinsicBaseName + '%', allowMissing);
    var intrinsicRealName = intrinsic.name;
    var value = intrinsic.value;
    var skipFurtherCaching = false;
    var alias = intrinsic.alias;
    if (alias) {
        intrinsicBaseName = alias[0];
        $spliceApply(parts, $concat([
            0,
            1
        ], alias));
    }
    for(var i = 1, isOwn = true; i < parts.length; i += 1){
        var part = parts[i];
        var first = $strSlice(part, 0, 1);
        var last = $strSlice(part, -1);
        if ((first === '"' || first === "'" || first === '`' || last === '"' || last === "'" || last === '`') && first !== last) {
            throw new $SyntaxError('property names with quotes must have matching quotes');
        }
        if (part === 'constructor' || !isOwn) {
            skipFurtherCaching = true;
        }
        intrinsicBaseName += '.' + part;
        intrinsicRealName = '%' + intrinsicBaseName + '%';
        if (hasOwn(INTRINSICS, intrinsicRealName)) {
            value = INTRINSICS[intrinsicRealName];
        } else if (value != null) {
            if (!(part in value)) {
                if (!allowMissing) {
                    throw new $TypeError('base intrinsic for ' + name + ' exists, but the property is not available.');
                }
                return void undefined;
            }
            if ($gOPD && i + 1 >= parts.length) {
                var desc = $gOPD(value, part);
                isOwn = !!desc;
                // By convention, when a data property is converted to an accessor
                // property to emulate a data property that does not suffer from
                // the override mistake, that accessor's getter is marked with
                // an `originalValue` property. Here, when we detect this, we
                // uphold the illusion by pretending to see that original data
                // property, i.e., returning the value rather than the getter
                // itself.
                if (isOwn && 'get' in desc && !('originalValue' in desc.get)) {
                    value = desc.get;
                } else {
                    value = value[part];
                }
            } else {
                isOwn = hasOwn(value, part);
                value = value[part];
            }
            if (isOwn && !skipFurtherCaching) {
                INTRINSICS[intrinsicRealName] = value;
            }
        }
    }
    return value;
};
}),
"[project]/node_modules/has-tostringtag/shams.js [app-ssr] (ecmascript)", ((__turbopack_context__, module, exports) => {
"use strict";

var hasSymbols = __turbopack_context__.r("[project]/node_modules/has-symbols/shams.js [app-ssr] (ecmascript)");
/** @type {import('.')} */ module.exports = function hasToStringTagShams() {
    return hasSymbols() && !!Symbol.toStringTag;
};
}),
"[project]/node_modules/es-set-tostringtag/index.js [app-ssr] (ecmascript)", ((__turbopack_context__, module, exports) => {
"use strict";

var GetIntrinsic = __turbopack_context__.r("[project]/node_modules/get-intrinsic/index.js [app-ssr] (ecmascript)");
var $defineProperty = GetIntrinsic('%Object.defineProperty%', true);
var hasToStringTag = __turbopack_context__.r("[project]/node_modules/has-tostringtag/shams.js [app-ssr] (ecmascript)")();
var hasOwn = __turbopack_context__.r("[project]/node_modules/hasown/index.js [app-ssr] (ecmascript)");
var $TypeError = __turbopack_context__.r("[project]/node_modules/es-errors/type.js [app-ssr] (ecmascript)");
var toStringTag = hasToStringTag ? Symbol.toStringTag : null;
/** @type {import('.')} */ module.exports = function setToStringTag(object, value) {
    var overrideIfSet = arguments.length > 2 && !!arguments[2] && arguments[2].force;
    var nonConfigurable = arguments.length > 2 && !!arguments[2] && arguments[2].nonConfigurable;
    if (typeof overrideIfSet !== 'undefined' && typeof overrideIfSet !== 'boolean' || typeof nonConfigurable !== 'undefined' && typeof nonConfigurable !== 'boolean') {
        throw new $TypeError('if provided, the `overrideIfSet` and `nonConfigurable` options must be booleans');
    }
    if (toStringTag && (overrideIfSet || !hasOwn(object, toStringTag))) {
        if ($defineProperty) {
            $defineProperty(object, toStringTag, {
                configurable: !nonConfigurable,
                enumerable: false,
                value: value,
                writable: false
            });
        } else {
            object[toStringTag] = value; // eslint-disable-line no-param-reassign
        }
    }
};
}),
"[project]/node_modules/form-data/lib/populate.js [app-ssr] (ecmascript)", ((__turbopack_context__, module, exports) => {
"use strict";

// populates missing values
module.exports = function(dst, src) {
    Object.keys(src).forEach(function(prop) {
        dst[prop] = dst[prop] || src[prop]; // eslint-disable-line no-param-reassign
    });
    return dst;
};
}),
"[project]/node_modules/form-data/lib/form_data.js [app-ssr] (ecmascript)", ((__turbopack_context__, module, exports) => {
"use strict";

var CombinedStream = __turbopack_context__.r("[project]/node_modules/combined-stream/lib/combined_stream.js [app-ssr] (ecmascript)");
var util = __turbopack_context__.r("[externals]/util [external] (util, cjs)");
var path = __turbopack_context__.r("[externals]/path [external] (path, cjs)");
var http = __turbopack_context__.r("[externals]/http [external] (http, cjs)");
var https = __turbopack_context__.r("[externals]/https [external] (https, cjs)");
var parseUrl = __turbopack_context__.r("[externals]/url [external] (url, cjs)").parse;
var fs = __turbopack_context__.r("[externals]/fs [external] (fs, cjs)");
var Stream = __turbopack_context__.r("[externals]/stream [external] (stream, cjs)").Stream;
var crypto = __turbopack_context__.r("[externals]/crypto [external] (crypto, cjs)");
var mime = __turbopack_context__.r("[project]/node_modules/mime-types/index.js [app-ssr] (ecmascript)");
var asynckit = __turbopack_context__.r("[project]/node_modules/asynckit/index.js [app-ssr] (ecmascript)");
var setToStringTag = __turbopack_context__.r("[project]/node_modules/es-set-tostringtag/index.js [app-ssr] (ecmascript)");
var hasOwn = __turbopack_context__.r("[project]/node_modules/hasown/index.js [app-ssr] (ecmascript)");
var populate = __turbopack_context__.r("[project]/node_modules/form-data/lib/populate.js [app-ssr] (ecmascript)");
/**
 * Create readable "multipart/form-data" streams.
 * Can be used to submit forms
 * and file uploads to other web applications.
 *
 * @constructor
 * @param {object} options - Properties to be added/overriden for FormData and CombinedStream
 */ function FormData(options) {
    if (!(this instanceof FormData)) {
        return new FormData(options);
    }
    this._overheadLength = 0;
    this._valueLength = 0;
    this._valuesToMeasure = [];
    CombinedStream.call(this);
    options = options || {}; // eslint-disable-line no-param-reassign
    for(var option in options){
        this[option] = options[option];
    }
}
// make it a Stream
util.inherits(FormData, CombinedStream);
FormData.LINE_BREAK = '\r\n';
FormData.DEFAULT_CONTENT_TYPE = 'application/octet-stream';
FormData.prototype.append = function(field, value, options) {
    options = options || {}; // eslint-disable-line no-param-reassign
    // allow filename as single option
    if (typeof options === 'string') {
        options = {
            filename: options
        }; // eslint-disable-line no-param-reassign
    }
    var append = CombinedStream.prototype.append.bind(this);
    // all that streamy business can't handle numbers
    if (typeof value === 'number' || value == null) {
        value = String(value); // eslint-disable-line no-param-reassign
    }
    // https://github.com/felixge/node-form-data/issues/38
    if (Array.isArray(value)) {
        /*
     * Please convert your array into string
     * the way web server expects it
     */ this._error(new Error('Arrays are not supported.'));
        return;
    }
    var header = this._multiPartHeader(field, value, options);
    var footer = this._multiPartFooter();
    append(header);
    append(value);
    append(footer);
    // pass along options.knownLength
    this._trackLength(header, value, options);
};
FormData.prototype._trackLength = function(header, value, options) {
    var valueLength = 0;
    /*
   * used w/ getLengthSync(), when length is known.
   * e.g. for streaming directly from a remote server,
   * w/ a known file a size, and not wanting to wait for
   * incoming file to finish to get its size.
   */ if (options.knownLength != null) {
        valueLength += Number(options.knownLength);
    } else if (Buffer.isBuffer(value)) {
        valueLength = value.length;
    } else if (typeof value === 'string') {
        valueLength = Buffer.byteLength(value);
    }
    this._valueLength += valueLength;
    // @check why add CRLF? does this account for custom/multiple CRLFs?
    this._overheadLength += Buffer.byteLength(header) + FormData.LINE_BREAK.length;
    // empty or either doesn't have path or not an http response or not a stream
    if (!value || !value.path && !(value.readable && hasOwn(value, 'httpVersion')) && !(value instanceof Stream)) {
        return;
    }
    // no need to bother with the length
    if (!options.knownLength) {
        this._valuesToMeasure.push(value);
    }
};
FormData.prototype._lengthRetriever = function(value, callback) {
    if (hasOwn(value, 'fd')) {
        // take read range into a account
        // `end` = Infinity > read file till the end
        //
        // TODO: Looks like there is bug in Node fs.createReadStream
        // it doesn't respect `end` options without `start` options
        // Fix it when node fixes it.
        // https://github.com/joyent/node/issues/7819
        if (value.end != undefined && value.end != Infinity && value.start != undefined) {
            // when end specified
            // no need to calculate range
            // inclusive, starts with 0
            callback(null, value.end + 1 - (value.start ? value.start : 0)); // eslint-disable-line callback-return
        // not that fast snoopy
        } else {
            // still need to fetch file size from fs
            fs.stat(value.path, function(err, stat) {
                if (err) {
                    callback(err);
                    return;
                }
                // update final size based on the range options
                var fileSize = stat.size - (value.start ? value.start : 0);
                callback(null, fileSize);
            });
        }
    // or http response
    } else if (hasOwn(value, 'httpVersion')) {
        callback(null, Number(value.headers['content-length'])); // eslint-disable-line callback-return
    // or request stream http://github.com/mikeal/request
    } else if (hasOwn(value, 'httpModule')) {
        // wait till response come back
        value.on('response', function(response) {
            value.pause();
            callback(null, Number(response.headers['content-length']));
        });
        value.resume();
    // something else
    } else {
        callback('Unknown stream'); // eslint-disable-line callback-return
    }
};
FormData.prototype._multiPartHeader = function(field, value, options) {
    /*
   * custom header specified (as string)?
   * it becomes responsible for boundary
   * (e.g. to handle extra CRLFs on .NET servers)
   */ if (typeof options.header === 'string') {
        return options.header;
    }
    var contentDisposition = this._getContentDisposition(value, options);
    var contentType = this._getContentType(value, options);
    var contents = '';
    var headers = {
        // add custom disposition as third element or keep it two elements if not
        'Content-Disposition': [
            'form-data',
            'name="' + field + '"'
        ].concat(contentDisposition || []),
        // if no content type. allow it to be empty array
        'Content-Type': [].concat(contentType || [])
    };
    // allow custom headers.
    if (typeof options.header === 'object') {
        populate(headers, options.header);
    }
    var header;
    for(var prop in headers){
        if (hasOwn(headers, prop)) {
            header = headers[prop];
            // skip nullish headers.
            if (header == null) {
                continue; // eslint-disable-line no-restricted-syntax, no-continue
            }
            // convert all headers to arrays.
            if (!Array.isArray(header)) {
                header = [
                    header
                ];
            }
            // add non-empty headers.
            if (header.length) {
                contents += prop + ': ' + header.join('; ') + FormData.LINE_BREAK;
            }
        }
    }
    return '--' + this.getBoundary() + FormData.LINE_BREAK + contents + FormData.LINE_BREAK;
};
FormData.prototype._getContentDisposition = function(value, options) {
    var filename;
    if (typeof options.filepath === 'string') {
        // custom filepath for relative paths
        filename = path.normalize(options.filepath).replace(/\\/g, '/');
    } else if (options.filename || value && (value.name || value.path)) {
        /*
     * custom filename take precedence
     * formidable and the browser add a name property
     * fs- and request- streams have path property
     */ filename = path.basename(options.filename || value && (value.name || value.path));
    } else if (value && value.readable && hasOwn(value, 'httpVersion')) {
        // or try http response
        filename = path.basename(value.client._httpMessage.path || '');
    }
    if (filename) {
        return 'filename="' + filename + '"';
    }
};
FormData.prototype._getContentType = function(value, options) {
    // use custom content-type above all
    var contentType = options.contentType;
    // or try `name` from formidable, browser
    if (!contentType && value && value.name) {
        contentType = mime.lookup(value.name);
    }
    // or try `path` from fs-, request- streams
    if (!contentType && value && value.path) {
        contentType = mime.lookup(value.path);
    }
    // or if it's http-reponse
    if (!contentType && value && value.readable && hasOwn(value, 'httpVersion')) {
        contentType = value.headers['content-type'];
    }
    // or guess it from the filepath or filename
    if (!contentType && (options.filepath || options.filename)) {
        contentType = mime.lookup(options.filepath || options.filename);
    }
    // fallback to the default content type if `value` is not simple value
    if (!contentType && value && typeof value === 'object') {
        contentType = FormData.DEFAULT_CONTENT_TYPE;
    }
    return contentType;
};
FormData.prototype._multiPartFooter = function() {
    return (function(next) {
        var footer = FormData.LINE_BREAK;
        var lastPart = this._streams.length === 0;
        if (lastPart) {
            footer += this._lastBoundary();
        }
        next(footer);
    }).bind(this);
};
FormData.prototype._lastBoundary = function() {
    return '--' + this.getBoundary() + '--' + FormData.LINE_BREAK;
};
FormData.prototype.getHeaders = function(userHeaders) {
    var header;
    var formHeaders = {
        'content-type': 'multipart/form-data; boundary=' + this.getBoundary()
    };
    for(header in userHeaders){
        if (hasOwn(userHeaders, header)) {
            formHeaders[header.toLowerCase()] = userHeaders[header];
        }
    }
    return formHeaders;
};
FormData.prototype.setBoundary = function(boundary) {
    if (typeof boundary !== 'string') {
        throw new TypeError('FormData boundary must be a string');
    }
    this._boundary = boundary;
};
FormData.prototype.getBoundary = function() {
    if (!this._boundary) {
        this._generateBoundary();
    }
    return this._boundary;
};
FormData.prototype.getBuffer = function() {
    var dataBuffer = new Buffer.alloc(0); // eslint-disable-line new-cap
    var boundary = this.getBoundary();
    // Create the form content. Add Line breaks to the end of data.
    for(var i = 0, len = this._streams.length; i < len; i++){
        if (typeof this._streams[i] !== 'function') {
            // Add content to the buffer.
            if (Buffer.isBuffer(this._streams[i])) {
                dataBuffer = Buffer.concat([
                    dataBuffer,
                    this._streams[i]
                ]);
            } else {
                dataBuffer = Buffer.concat([
                    dataBuffer,
                    Buffer.from(this._streams[i])
                ]);
            }
            // Add break after content.
            if (typeof this._streams[i] !== 'string' || this._streams[i].substring(2, boundary.length + 2) !== boundary) {
                dataBuffer = Buffer.concat([
                    dataBuffer,
                    Buffer.from(FormData.LINE_BREAK)
                ]);
            }
        }
    }
    // Add the footer and return the Buffer object.
    return Buffer.concat([
        dataBuffer,
        Buffer.from(this._lastBoundary())
    ]);
};
FormData.prototype._generateBoundary = function() {
    // This generates a 50 character boundary similar to those used by Firefox.
    // They are optimized for boyer-moore parsing.
    this._boundary = '--------------------------' + crypto.randomBytes(12).toString('hex');
};
// Note: getLengthSync DOESN'T calculate streams length
// As workaround one can calculate file size manually and add it as knownLength option
FormData.prototype.getLengthSync = function() {
    var knownLength = this._overheadLength + this._valueLength;
    // Don't get confused, there are 3 "internal" streams for each keyval pair so it basically checks if there is any value added to the form
    if (this._streams.length) {
        knownLength += this._lastBoundary().length;
    }
    // https://github.com/form-data/form-data/issues/40
    if (!this.hasKnownLength()) {
        /*
     * Some async length retrievers are present
     * therefore synchronous length calculation is false.
     * Please use getLength(callback) to get proper length
     */ this._error(new Error('Cannot calculate proper length in synchronous way.'));
    }
    return knownLength;
};
// Public API to check if length of added values is known
// https://github.com/form-data/form-data/issues/196
// https://github.com/form-data/form-data/issues/262
FormData.prototype.hasKnownLength = function() {
    var hasKnownLength = true;
    if (this._valuesToMeasure.length) {
        hasKnownLength = false;
    }
    return hasKnownLength;
};
FormData.prototype.getLength = function(cb) {
    var knownLength = this._overheadLength + this._valueLength;
    if (this._streams.length) {
        knownLength += this._lastBoundary().length;
    }
    if (!this._valuesToMeasure.length) {
        process.nextTick(cb.bind(this, null, knownLength));
        return;
    }
    asynckit.parallel(this._valuesToMeasure, this._lengthRetriever, function(err, values) {
        if (err) {
            cb(err);
            return;
        }
        values.forEach(function(length) {
            knownLength += length;
        });
        cb(null, knownLength);
    });
};
FormData.prototype.submit = function(params, cb) {
    var request;
    var options;
    var defaults = {
        method: 'post'
    };
    // parse provided url if it's string or treat it as options object
    if (typeof params === 'string') {
        params = parseUrl(params); // eslint-disable-line no-param-reassign
        /* eslint sort-keys: 0 */ options = populate({
            port: params.port,
            path: params.pathname,
            host: params.hostname,
            protocol: params.protocol
        }, defaults);
    } else {
        options = populate(params, defaults);
        // if no port provided use default one
        if (!options.port) {
            options.port = options.protocol === 'https:' ? 443 : 80;
        }
    }
    // put that good code in getHeaders to some use
    options.headers = this.getHeaders(params.headers);
    // https if specified, fallback to http in any other case
    if (options.protocol === 'https:') {
        request = https.request(options);
    } else {
        request = http.request(options);
    }
    // get content length and fire away
    this.getLength((function(err, length) {
        if (err && err !== 'Unknown stream') {
            this._error(err);
            return;
        }
        // add content length
        if (length) {
            request.setHeader('Content-Length', length);
        }
        this.pipe(request);
        if (cb) {
            var onResponse;
            var callback = function(error, responce) {
                request.removeListener('error', callback);
                request.removeListener('response', onResponse);
                return cb.call(this, error, responce); // eslint-disable-line no-invalid-this
            };
            onResponse = callback.bind(this, null);
            request.on('error', callback);
            request.on('response', onResponse);
        }
    }).bind(this));
    return request;
};
FormData.prototype._error = function(err) {
    if (!this.error) {
        this.error = err;
        this.pause();
        this.emit('error', err);
    }
};
FormData.prototype.toString = function() {
    return '[object FormData]';
};
setToStringTag(FormData, 'FormData');
// Public API
module.exports = FormData;
}),
"[project]/node_modules/proxy-from-env/index.js [app-ssr] (ecmascript)", ((__turbopack_context__, module, exports) => {
"use strict";

var parseUrl = __turbopack_context__.r("[externals]/url [external] (url, cjs)").parse;
var DEFAULT_PORTS = {
    ftp: 21,
    gopher: 70,
    http: 80,
    https: 443,
    ws: 80,
    wss: 443
};
var stringEndsWith = String.prototype.endsWith || function(s) {
    return s.length <= this.length && this.indexOf(s, this.length - s.length) !== -1;
};
/**
 * @param {string|object} url - The URL, or the result from url.parse.
 * @return {string} The URL of the proxy that should handle the request to the
 *  given URL. If no proxy is set, this will be an empty string.
 */ function getProxyForUrl(url) {
    var parsedUrl = typeof url === 'string' ? parseUrl(url) : url || {};
    var proto = parsedUrl.protocol;
    var hostname = parsedUrl.host;
    var port = parsedUrl.port;
    if (typeof hostname !== 'string' || !hostname || typeof proto !== 'string') {
        return ''; // Don't proxy URLs without a valid scheme or host.
    }
    proto = proto.split(':', 1)[0];
    // Stripping ports in this way instead of using parsedUrl.hostname to make
    // sure that the brackets around IPv6 addresses are kept.
    hostname = hostname.replace(/:\d*$/, '');
    port = parseInt(port) || DEFAULT_PORTS[proto] || 0;
    if (!shouldProxy(hostname, port)) {
        return ''; // Don't proxy URLs that match NO_PROXY.
    }
    var proxy = getEnv('npm_config_' + proto + '_proxy') || getEnv(proto + '_proxy') || getEnv('npm_config_proxy') || getEnv('all_proxy');
    if (proxy && proxy.indexOf('://') === -1) {
        // Missing scheme in proxy, default to the requested URL's scheme.
        proxy = proto + '://' + proxy;
    }
    return proxy;
}
/**
 * Determines whether a given URL should be proxied.
 *
 * @param {string} hostname - The host name of the URL.
 * @param {number} port - The effective port of the URL.
 * @returns {boolean} Whether the given URL should be proxied.
 * @private
 */ function shouldProxy(hostname, port) {
    var NO_PROXY = (getEnv('npm_config_no_proxy') || getEnv('no_proxy')).toLowerCase();
    if (!NO_PROXY) {
        return true; // Always proxy if NO_PROXY is not set.
    }
    if (NO_PROXY === '*') {
        return false; // Never proxy if wildcard is set.
    }
    return NO_PROXY.split(/[,\s]/).every(function(proxy) {
        if (!proxy) {
            return true; // Skip zero-length hosts.
        }
        var parsedProxy = proxy.match(/^(.+):(\d+)$/);
        var parsedProxyHostname = parsedProxy ? parsedProxy[1] : proxy;
        var parsedProxyPort = parsedProxy ? parseInt(parsedProxy[2]) : 0;
        if (parsedProxyPort && parsedProxyPort !== port) {
            return true; // Skip if ports don't match.
        }
        if (!/^[.*]/.test(parsedProxyHostname)) {
            // No wildcards, so stop proxying if there is an exact match.
            return hostname !== parsedProxyHostname;
        }
        if (parsedProxyHostname.charAt(0) === '*') {
            // Remove leading wildcard.
            parsedProxyHostname = parsedProxyHostname.slice(1);
        }
        // Stop proxying if the hostname ends with the no_proxy host.
        return !stringEndsWith.call(hostname, parsedProxyHostname);
    });
}
/**
 * Get the value for an environment variable.
 *
 * @param {string} key - The name of the environment variable.
 * @return {string} The value of the environment variable.
 * @private
 */ function getEnv(key) {
    return process.env[key.toLowerCase()] || process.env[key.toUpperCase()] || '';
}
exports.getProxyForUrl = getProxyForUrl;
}),
"[project]/node_modules/ms/index.js [app-ssr] (ecmascript)", ((__turbopack_context__, module, exports) => {

/**
 * Helpers.
 */ var s = 1000;
var m = s * 60;
var h = m * 60;
var d = h * 24;
var w = d * 7;
var y = d * 365.25;
/**
 * Parse or format the given `val`.
 *
 * Options:
 *
 *  - `long` verbose formatting [false]
 *
 * @param {String|Number} val
 * @param {Object} [options]
 * @throws {Error} throw an error if val is not a non-empty string or a number
 * @return {String|Number}
 * @api public
 */ module.exports = function(val, options) {
    options = options || {};
    var type = typeof val;
    if (type === 'string' && val.length > 0) {
        return parse(val);
    } else if (type === 'number' && isFinite(val)) {
        return options.long ? fmtLong(val) : fmtShort(val);
    }
    throw new Error('val is not a non-empty string or a valid number. val=' + JSON.stringify(val));
};
/**
 * Parse the given `str` and return milliseconds.
 *
 * @param {String} str
 * @return {Number}
 * @api private
 */ function parse(str) {
    str = String(str);
    if (str.length > 100) {
        return;
    }
    var match = /^(-?(?:\d+)?\.?\d+) *(milliseconds?|msecs?|ms|seconds?|secs?|s|minutes?|mins?|m|hours?|hrs?|h|days?|d|weeks?|w|years?|yrs?|y)?$/i.exec(str);
    if (!match) {
        return;
    }
    var n = parseFloat(match[1]);
    var type = (match[2] || 'ms').toLowerCase();
    switch(type){
        case 'years':
        case 'year':
        case 'yrs':
        case 'yr':
        case 'y':
            return n * y;
        case 'weeks':
        case 'week':
        case 'w':
            return n * w;
        case 'days':
        case 'day':
        case 'd':
            return n * d;
        case 'hours':
        case 'hour':
        case 'hrs':
        case 'hr':
        case 'h':
            return n * h;
        case 'minutes':
        case 'minute':
        case 'mins':
        case 'min':
        case 'm':
            return n * m;
        case 'seconds':
        case 'second':
        case 'secs':
        case 'sec':
        case 's':
            return n * s;
        case 'milliseconds':
        case 'millisecond':
        case 'msecs':
        case 'msec':
        case 'ms':
            return n;
        default:
            return undefined;
    }
}
/**
 * Short format for `ms`.
 *
 * @param {Number} ms
 * @return {String}
 * @api private
 */ function fmtShort(ms) {
    var msAbs = Math.abs(ms);
    if (msAbs >= d) {
        return Math.round(ms / d) + 'd';
    }
    if (msAbs >= h) {
        return Math.round(ms / h) + 'h';
    }
    if (msAbs >= m) {
        return Math.round(ms / m) + 'm';
    }
    if (msAbs >= s) {
        return Math.round(ms / s) + 's';
    }
    return ms + 'ms';
}
/**
 * Long format for `ms`.
 *
 * @param {Number} ms
 * @return {String}
 * @api private
 */ function fmtLong(ms) {
    var msAbs = Math.abs(ms);
    if (msAbs >= d) {
        return plural(ms, msAbs, d, 'day');
    }
    if (msAbs >= h) {
        return plural(ms, msAbs, h, 'hour');
    }
    if (msAbs >= m) {
        return plural(ms, msAbs, m, 'minute');
    }
    if (msAbs >= s) {
        return plural(ms, msAbs, s, 'second');
    }
    return ms + ' ms';
}
/**
 * Pluralization helper.
 */ function plural(ms, msAbs, n, name) {
    var isPlural = msAbs >= n * 1.5;
    return Math.round(ms / n) + ' ' + name + (isPlural ? 's' : '');
}
}),
"[project]/node_modules/debug/src/common.js [app-ssr] (ecmascript)", ((__turbopack_context__, module, exports) => {

/**
 * This is the common logic for both the Node.js and web browser
 * implementations of `debug()`.
 */ function setup(env) {
    createDebug.debug = createDebug;
    createDebug.default = createDebug;
    createDebug.coerce = coerce;
    createDebug.disable = disable;
    createDebug.enable = enable;
    createDebug.enabled = enabled;
    createDebug.humanize = __turbopack_context__.r("[project]/node_modules/ms/index.js [app-ssr] (ecmascript)");
    createDebug.destroy = destroy;
    Object.keys(env).forEach((key)=>{
        createDebug[key] = env[key];
    });
    /**
	* The currently active debug mode names, and names to skip.
	*/ createDebug.names = [];
    createDebug.skips = [];
    /**
	* Map of special "%n" handling functions, for the debug "format" argument.
	*
	* Valid key names are a single, lower or upper-case letter, i.e. "n" and "N".
	*/ createDebug.formatters = {};
    /**
	* Selects a color for a debug namespace
	* @param {String} namespace The namespace string for the debug instance to be colored
	* @return {Number|String} An ANSI color code for the given namespace
	* @api private
	*/ function selectColor(namespace) {
        let hash = 0;
        for(let i = 0; i < namespace.length; i++){
            hash = (hash << 5) - hash + namespace.charCodeAt(i);
            hash |= 0; // Convert to 32bit integer
        }
        return createDebug.colors[Math.abs(hash) % createDebug.colors.length];
    }
    createDebug.selectColor = selectColor;
    /**
	* Create a debugger with the given `namespace`.
	*
	* @param {String} namespace
	* @return {Function}
	* @api public
	*/ function createDebug(namespace) {
        let prevTime;
        let enableOverride = null;
        let namespacesCache;
        let enabledCache;
        function debug(...args) {
            // Disabled?
            if (!debug.enabled) {
                return;
            }
            const self = debug;
            // Set `diff` timestamp
            const curr = Number(new Date());
            const ms = curr - (prevTime || curr);
            self.diff = ms;
            self.prev = prevTime;
            self.curr = curr;
            prevTime = curr;
            args[0] = createDebug.coerce(args[0]);
            if (typeof args[0] !== 'string') {
                // Anything else let's inspect with %O
                args.unshift('%O');
            }
            // Apply any `formatters` transformations
            let index = 0;
            args[0] = args[0].replace(/%([a-zA-Z%])/g, (match, format)=>{
                // If we encounter an escaped % then don't increase the array index
                if (match === '%%') {
                    return '%';
                }
                index++;
                const formatter = createDebug.formatters[format];
                if (typeof formatter === 'function') {
                    const val = args[index];
                    match = formatter.call(self, val);
                    // Now we need to remove `args[index]` since it's inlined in the `format`
                    args.splice(index, 1);
                    index--;
                }
                return match;
            });
            // Apply env-specific formatting (colors, etc.)
            createDebug.formatArgs.call(self, args);
            const logFn = self.log || createDebug.log;
            logFn.apply(self, args);
        }
        debug.namespace = namespace;
        debug.useColors = createDebug.useColors();
        debug.color = createDebug.selectColor(namespace);
        debug.extend = extend;
        debug.destroy = createDebug.destroy; // XXX Temporary. Will be removed in the next major release.
        Object.defineProperty(debug, 'enabled', {
            enumerable: true,
            configurable: false,
            get: ()=>{
                if (enableOverride !== null) {
                    return enableOverride;
                }
                if (namespacesCache !== createDebug.namespaces) {
                    namespacesCache = createDebug.namespaces;
                    enabledCache = createDebug.enabled(namespace);
                }
                return enabledCache;
            },
            set: (v)=>{
                enableOverride = v;
            }
        });
        // Env-specific initialization logic for debug instances
        if (typeof createDebug.init === 'function') {
            createDebug.init(debug);
        }
        return debug;
    }
    function extend(namespace, delimiter) {
        const newDebug = createDebug(this.namespace + (typeof delimiter === 'undefined' ? ':' : delimiter) + namespace);
        newDebug.log = this.log;
        return newDebug;
    }
    /**
	* Enables a debug mode by namespaces. This can include modes
	* separated by a colon and wildcards.
	*
	* @param {String} namespaces
	* @api public
	*/ function enable(namespaces) {
        createDebug.save(namespaces);
        createDebug.namespaces = namespaces;
        createDebug.names = [];
        createDebug.skips = [];
        const split = (typeof namespaces === 'string' ? namespaces : '').trim().replace(/\s+/g, ',').split(',').filter(Boolean);
        for (const ns of split){
            if (ns[0] === '-') {
                createDebug.skips.push(ns.slice(1));
            } else {
                createDebug.names.push(ns);
            }
        }
    }
    /**
	 * Checks if the given string matches a namespace template, honoring
	 * asterisks as wildcards.
	 *
	 * @param {String} search
	 * @param {String} template
	 * @return {Boolean}
	 */ function matchesTemplate(search, template) {
        let searchIndex = 0;
        let templateIndex = 0;
        let starIndex = -1;
        let matchIndex = 0;
        while(searchIndex < search.length){
            if (templateIndex < template.length && (template[templateIndex] === search[searchIndex] || template[templateIndex] === '*')) {
                // Match character or proceed with wildcard
                if (template[templateIndex] === '*') {
                    starIndex = templateIndex;
                    matchIndex = searchIndex;
                    templateIndex++; // Skip the '*'
                } else {
                    searchIndex++;
                    templateIndex++;
                }
            } else if (starIndex !== -1) {
                // Backtrack to the last '*' and try to match more characters
                templateIndex = starIndex + 1;
                matchIndex++;
                searchIndex = matchIndex;
            } else {
                return false; // No match
            }
        }
        // Handle trailing '*' in template
        while(templateIndex < template.length && template[templateIndex] === '*'){
            templateIndex++;
        }
        return templateIndex === template.length;
    }
    /**
	* Disable debug output.
	*
	* @return {String} namespaces
	* @api public
	*/ function disable() {
        const namespaces = [
            ...createDebug.names,
            ...createDebug.skips.map((namespace)=>'-' + namespace)
        ].join(',');
        createDebug.enable('');
        return namespaces;
    }
    /**
	* Returns true if the given mode name is enabled, false otherwise.
	*
	* @param {String} name
	* @return {Boolean}
	* @api public
	*/ function enabled(name) {
        for (const skip of createDebug.skips){
            if (matchesTemplate(name, skip)) {
                return false;
            }
        }
        for (const ns of createDebug.names){
            if (matchesTemplate(name, ns)) {
                return true;
            }
        }
        return false;
    }
    /**
	* Coerce `val`.
	*
	* @param {Mixed} val
	* @return {Mixed}
	* @api private
	*/ function coerce(val) {
        if (val instanceof Error) {
            return val.stack || val.message;
        }
        return val;
    }
    /**
	* XXX DO NOT USE. This is a temporary stub function.
	* XXX It WILL be removed in the next major release.
	*/ function destroy() {
        console.warn('Instance method `debug.destroy()` is deprecated and no longer does anything. It will be removed in the next major version of `debug`.');
    }
    createDebug.enable(createDebug.load());
    return createDebug;
}
module.exports = setup;
}),
"[project]/node_modules/debug/src/node.js [app-ssr] (ecmascript)", ((__turbopack_context__, module, exports) => {

/**
 * Module dependencies.
 */ const tty = __turbopack_context__.r("[externals]/tty [external] (tty, cjs)");
const util = __turbopack_context__.r("[externals]/util [external] (util, cjs)");
/**
 * This is the Node.js implementation of `debug()`.
 */ exports.init = init;
exports.log = log;
exports.formatArgs = formatArgs;
exports.save = save;
exports.load = load;
exports.useColors = useColors;
exports.destroy = util.deprecate(()=>{}, 'Instance method `debug.destroy()` is deprecated and no longer does anything. It will be removed in the next major version of `debug`.');
/**
 * Colors.
 */ exports.colors = [
    6,
    2,
    3,
    4,
    5,
    1
];
try {
    // Optional dependency (as in, doesn't need to be installed, NOT like optionalDependencies in package.json)
    // eslint-disable-next-line import/no-extraneous-dependencies
    const supportsColor = __turbopack_context__.r("[project]/node_modules/supports-color/index.js [app-ssr] (ecmascript)");
    if (supportsColor && (supportsColor.stderr || supportsColor).level >= 2) {
        exports.colors = [
            20,
            21,
            26,
            27,
            32,
            33,
            38,
            39,
            40,
            41,
            42,
            43,
            44,
            45,
            56,
            57,
            62,
            63,
            68,
            69,
            74,
            75,
            76,
            77,
            78,
            79,
            80,
            81,
            92,
            93,
            98,
            99,
            112,
            113,
            128,
            129,
            134,
            135,
            148,
            149,
            160,
            161,
            162,
            163,
            164,
            165,
            166,
            167,
            168,
            169,
            170,
            171,
            172,
            173,
            178,
            179,
            184,
            185,
            196,
            197,
            198,
            199,
            200,
            201,
            202,
            203,
            204,
            205,
            206,
            207,
            208,
            209,
            214,
            215,
            220,
            221
        ];
    }
} catch (error) {
// Swallow - we only care if `supports-color` is available; it doesn't have to be.
}
/**
 * Build up the default `inspectOpts` object from the environment variables.
 *
 *   $ DEBUG_COLORS=no DEBUG_DEPTH=10 DEBUG_SHOW_HIDDEN=enabled node script.js
 */ exports.inspectOpts = Object.keys(process.env).filter((key)=>{
    return /^debug_/i.test(key);
}).reduce((obj, key)=>{
    // Camel-case
    const prop = key.substring(6).toLowerCase().replace(/_([a-z])/g, (_, k)=>{
        return k.toUpperCase();
    });
    // Coerce string value into JS value
    let val = process.env[key];
    if (/^(yes|on|true|enabled)$/i.test(val)) {
        val = true;
    } else if (/^(no|off|false|disabled)$/i.test(val)) {
        val = false;
    } else if (val === 'null') {
        val = null;
    } else {
        val = Number(val);
    }
    obj[prop] = val;
    return obj;
}, {});
/**
 * Is stdout a TTY? Colored output is enabled when `true`.
 */ function useColors() {
    return 'colors' in exports.inspectOpts ? Boolean(exports.inspectOpts.colors) : tty.isatty(process.stderr.fd);
}
/**
 * Adds ANSI color escape codes if enabled.
 *
 * @api public
 */ function formatArgs(args) {
    const { namespace: name, useColors } = this;
    if (useColors) {
        const c = this.color;
        const colorCode = '\u001B[3' + (c < 8 ? c : '8;5;' + c);
        const prefix = `  ${colorCode};1m${name} \u001B[0m`;
        args[0] = prefix + args[0].split('\n').join('\n' + prefix);
        args.push(colorCode + 'm+' + module.exports.humanize(this.diff) + '\u001B[0m');
    } else {
        args[0] = getDate() + name + ' ' + args[0];
    }
}
function getDate() {
    if (exports.inspectOpts.hideDate) {
        return '';
    }
    return new Date().toISOString() + ' ';
}
/**
 * Invokes `util.formatWithOptions()` with the specified arguments and writes to stderr.
 */ function log(...args) {
    return process.stderr.write(util.formatWithOptions(exports.inspectOpts, ...args) + '\n');
}
/**
 * Save `namespaces`.
 *
 * @param {String} namespaces
 * @api private
 */ function save(namespaces) {
    if (namespaces) {
        process.env.DEBUG = namespaces;
    } else {
        // If you set a process.env field to null or undefined, it gets cast to the
        // string 'null' or 'undefined'. Just delete instead.
        delete process.env.DEBUG;
    }
}
/**
 * Load `namespaces`.
 *
 * @return {String} returns the previously persisted debug modes
 * @api private
 */ function load() {
    return process.env.DEBUG;
}
/**
 * Init logic for `debug` instances.
 *
 * Create a new `inspectOpts` object in case `useColors` is set
 * differently for a particular `debug` instance.
 */ function init(debug) {
    debug.inspectOpts = {};
    const keys = Object.keys(exports.inspectOpts);
    for(let i = 0; i < keys.length; i++){
        debug.inspectOpts[keys[i]] = exports.inspectOpts[keys[i]];
    }
}
module.exports = __turbopack_context__.r("[project]/node_modules/debug/src/common.js [app-ssr] (ecmascript)")(exports);
const { formatters } = module.exports;
/**
 * Map %o to `util.inspect()`, all on a single line.
 */ formatters.o = function(v) {
    this.inspectOpts.colors = this.useColors;
    return util.inspect(v, this.inspectOpts).split('\n').map((str)=>str.trim()).join(' ');
};
/**
 * Map %O to `util.inspect()`, allowing multiple lines if needed.
 */ formatters.O = function(v) {
    this.inspectOpts.colors = this.useColors;
    return util.inspect(v, this.inspectOpts);
};
}),
"[project]/node_modules/debug/src/browser.js [app-ssr] (ecmascript)", ((__turbopack_context__, module, exports) => {

/* eslint-env browser */ /**
 * This is the web browser implementation of `debug()`.
 */ exports.formatArgs = formatArgs;
exports.save = save;
exports.load = load;
exports.useColors = useColors;
exports.storage = localstorage();
exports.destroy = (()=>{
    let warned = false;
    return ()=>{
        if (!warned) {
            warned = true;
            console.warn('Instance method `debug.destroy()` is deprecated and no longer does anything. It will be removed in the next major version of `debug`.');
        }
    };
})();
/**
 * Colors.
 */ exports.colors = [
    '#0000CC',
    '#0000FF',
    '#0033CC',
    '#0033FF',
    '#0066CC',
    '#0066FF',
    '#0099CC',
    '#0099FF',
    '#00CC00',
    '#00CC33',
    '#00CC66',
    '#00CC99',
    '#00CCCC',
    '#00CCFF',
    '#3300CC',
    '#3300FF',
    '#3333CC',
    '#3333FF',
    '#3366CC',
    '#3366FF',
    '#3399CC',
    '#3399FF',
    '#33CC00',
    '#33CC33',
    '#33CC66',
    '#33CC99',
    '#33CCCC',
    '#33CCFF',
    '#6600CC',
    '#6600FF',
    '#6633CC',
    '#6633FF',
    '#66CC00',
    '#66CC33',
    '#9900CC',
    '#9900FF',
    '#9933CC',
    '#9933FF',
    '#99CC00',
    '#99CC33',
    '#CC0000',
    '#CC0033',
    '#CC0066',
    '#CC0099',
    '#CC00CC',
    '#CC00FF',
    '#CC3300',
    '#CC3333',
    '#CC3366',
    '#CC3399',
    '#CC33CC',
    '#CC33FF',
    '#CC6600',
    '#CC6633',
    '#CC9900',
    '#CC9933',
    '#CCCC00',
    '#CCCC33',
    '#FF0000',
    '#FF0033',
    '#FF0066',
    '#FF0099',
    '#FF00CC',
    '#FF00FF',
    '#FF3300',
    '#FF3333',
    '#FF3366',
    '#FF3399',
    '#FF33CC',
    '#FF33FF',
    '#FF6600',
    '#FF6633',
    '#FF9900',
    '#FF9933',
    '#FFCC00',
    '#FFCC33'
];
/**
 * Currently only WebKit-based Web Inspectors, Firefox >= v31,
 * and the Firebug extension (any Firefox version) are known
 * to support "%c" CSS customizations.
 *
 * TODO: add a `localStorage` variable to explicitly enable/disable colors
 */ // eslint-disable-next-line complexity
function useColors() {
    // NB: In an Electron preload script, document will be defined but not fully
    // initialized. Since we know we're in Chrome, we'll just detect this case
    // explicitly
    if ("TURBOPACK compile-time falsy", 0) //TURBOPACK unreachable
    ;
    // Internet Explorer and Edge do not support colors.
    if (typeof navigator !== 'undefined' && navigator.userAgent && navigator.userAgent.toLowerCase().match(/(edge|trident)\/(\d+)/)) {
        return false;
    }
    let m;
    // Is webkit? http://stackoverflow.com/a/16459606/376773
    // document is undefined in react-native: https://github.com/facebook/react-native/pull/1632
    // eslint-disable-next-line no-return-assign
    return typeof document !== 'undefined' && document.documentElement && document.documentElement.style && document.documentElement.style.WebkitAppearance || ("TURBOPACK compile-time value", "undefined") !== 'undefined' && window.console && (window.console.firebug || window.console.exception && window.console.table) || typeof navigator !== 'undefined' && navigator.userAgent && (m = navigator.userAgent.toLowerCase().match(/firefox\/(\d+)/)) && parseInt(m[1], 10) >= 31 || typeof navigator !== 'undefined' && navigator.userAgent && navigator.userAgent.toLowerCase().match(/applewebkit\/(\d+)/);
}
/**
 * Colorize log arguments if enabled.
 *
 * @api public
 */ function formatArgs(args) {
    args[0] = (this.useColors ? '%c' : '') + this.namespace + (this.useColors ? ' %c' : ' ') + args[0] + (this.useColors ? '%c ' : ' ') + '+' + module.exports.humanize(this.diff);
    if (!this.useColors) {
        return;
    }
    const c = 'color: ' + this.color;
    args.splice(1, 0, c, 'color: inherit');
    // The final "%c" is somewhat tricky, because there could be other
    // arguments passed either before or after the %c, so we need to
    // figure out the correct index to insert the CSS into
    let index = 0;
    let lastC = 0;
    args[0].replace(/%[a-zA-Z%]/g, (match)=>{
        if (match === '%%') {
            return;
        }
        index++;
        if (match === '%c') {
            // We only are interested in the *last* %c
            // (the user may have provided their own)
            lastC = index;
        }
    });
    args.splice(lastC, 0, c);
}
/**
 * Invokes `console.debug()` when available.
 * No-op when `console.debug` is not a "function".
 * If `console.debug` is not available, falls back
 * to `console.log`.
 *
 * @api public
 */ exports.log = console.debug || console.log || (()=>{});
/**
 * Save `namespaces`.
 *
 * @param {String} namespaces
 * @api private
 */ function save(namespaces) {
    try {
        if (namespaces) {
            exports.storage.setItem('debug', namespaces);
        } else {
            exports.storage.removeItem('debug');
        }
    } catch (error) {
    // Swallow
    // XXX (@Qix-) should we be logging these?
    }
}
/**
 * Load `namespaces`.
 *
 * @return {String} returns the previously persisted debug modes
 * @api private
 */ function load() {
    let r;
    try {
        r = exports.storage.getItem('debug') || exports.storage.getItem('DEBUG');
    } catch (error) {
    // Swallow
    // XXX (@Qix-) should we be logging these?
    }
    // If debug isn't set in LS, and we're in Electron, try to load $DEBUG
    if (!r && typeof process !== 'undefined' && 'env' in process) {
        r = process.env.DEBUG;
    }
    return r;
}
/**
 * Localstorage attempts to return the localstorage.
 *
 * This is necessary because safari throws
 * when a user disables cookies/localstorage
 * and you attempt to access it.
 *
 * @return {LocalStorage}
 * @api private
 */ function localstorage() {
    try {
        // TVMLKit (Apple TV JS Runtime) does not have a window object, just localStorage in the global context
        // The Browser also has localStorage in the global context.
        return localStorage;
    } catch (error) {
    // Swallow
    // XXX (@Qix-) should we be logging these?
    }
}
module.exports = __turbopack_context__.r("[project]/node_modules/debug/src/common.js [app-ssr] (ecmascript)")(exports);
const { formatters } = module.exports;
/**
 * Map %j to `JSON.stringify()`, since no Web Inspectors do that by default.
 */ formatters.j = function(v) {
    try {
        return JSON.stringify(v);
    } catch (error) {
        return '[UnexpectedJSONParseError]: ' + error.message;
    }
};
}),
"[project]/node_modules/debug/src/index.js [app-ssr] (ecmascript)", ((__turbopack_context__, module, exports) => {

/**
 * Detect Electron renderer / nwjs process, which is node, but we should
 * treat as a browser.
 */ if (typeof process === 'undefined' || process.type === 'renderer' || ("TURBOPACK compile-time value", false) === true || process.__nwjs) {
    module.exports = __turbopack_context__.r("[project]/node_modules/debug/src/browser.js [app-ssr] (ecmascript)");
} else {
    module.exports = __turbopack_context__.r("[project]/node_modules/debug/src/node.js [app-ssr] (ecmascript)");
}
}),
"[project]/node_modules/has-flag/index.js [app-ssr] (ecmascript)", ((__turbopack_context__, module, exports) => {
"use strict";

module.exports = (flag, argv = process.argv)=>{
    const prefix = flag.startsWith('-') ? '' : flag.length === 1 ? '-' : '--';
    const position = argv.indexOf(prefix + flag);
    const terminatorPosition = argv.indexOf('--');
    return position !== -1 && (terminatorPosition === -1 || position < terminatorPosition);
};
}),
"[project]/node_modules/supports-color/index.js [app-ssr] (ecmascript)", ((__turbopack_context__, module, exports) => {
"use strict";

const os = __turbopack_context__.r("[externals]/os [external] (os, cjs)");
const tty = __turbopack_context__.r("[externals]/tty [external] (tty, cjs)");
const hasFlag = __turbopack_context__.r("[project]/node_modules/has-flag/index.js [app-ssr] (ecmascript)");
const { env } = process;
let forceColor;
if (hasFlag('no-color') || hasFlag('no-colors') || hasFlag('color=false') || hasFlag('color=never')) {
    forceColor = 0;
} else if (hasFlag('color') || hasFlag('colors') || hasFlag('color=true') || hasFlag('color=always')) {
    forceColor = 1;
}
if ('FORCE_COLOR' in env) {
    if (env.FORCE_COLOR === 'true') {
        forceColor = 1;
    } else if (env.FORCE_COLOR === 'false') {
        forceColor = 0;
    } else {
        forceColor = env.FORCE_COLOR.length === 0 ? 1 : Math.min(parseInt(env.FORCE_COLOR, 10), 3);
    }
}
function translateLevel(level) {
    if (level === 0) {
        return false;
    }
    return {
        level,
        hasBasic: true,
        has256: level >= 2,
        has16m: level >= 3
    };
}
function supportsColor(haveStream, streamIsTTY) {
    if (forceColor === 0) {
        return 0;
    }
    if (hasFlag('color=16m') || hasFlag('color=full') || hasFlag('color=truecolor')) {
        return 3;
    }
    if (hasFlag('color=256')) {
        return 2;
    }
    if (haveStream && !streamIsTTY && forceColor === undefined) {
        return 0;
    }
    const min = forceColor || 0;
    if (env.TERM === 'dumb') {
        return min;
    }
    if ("TURBOPACK compile-time falsy", 0) //TURBOPACK unreachable
    ;
    if ('CI' in env) {
        if ([
            'TRAVIS',
            'CIRCLECI',
            'APPVEYOR',
            'GITLAB_CI',
            'GITHUB_ACTIONS',
            'BUILDKITE'
        ].some((sign)=>sign in env) || env.CI_NAME === 'codeship') {
            return 1;
        }
        return min;
    }
    if ('TEAMCITY_VERSION' in env) {
        return /^(9\.(0*[1-9]\d*)\.|\d{2,}\.)/.test(env.TEAMCITY_VERSION) ? 1 : 0;
    }
    if (env.COLORTERM === 'truecolor') {
        return 3;
    }
    if ('TERM_PROGRAM' in env) {
        const version = parseInt((env.TERM_PROGRAM_VERSION || '').split('.')[0], 10);
        switch(env.TERM_PROGRAM){
            case 'iTerm.app':
                return version >= 3 ? 3 : 2;
            case 'Apple_Terminal':
                return 2;
        }
    }
    if (/-256(color)?$/i.test(env.TERM)) {
        return 2;
    }
    if (/^screen|^xterm|^vt100|^vt220|^rxvt|color|ansi|cygwin|linux/i.test(env.TERM)) {
        return 1;
    }
    if ('COLORTERM' in env) {
        return 1;
    }
    return min;
}
function getSupportLevel(stream) {
    const level = supportsColor(stream, stream && stream.isTTY);
    return translateLevel(level);
}
module.exports = {
    supportsColor: getSupportLevel,
    stdout: translateLevel(supportsColor(true, tty.isatty(1))),
    stderr: translateLevel(supportsColor(true, tty.isatty(2)))
};
}),
"[project]/node_modules/follow-redirects/debug.js [app-ssr] (ecmascript)", ((__turbopack_context__, module, exports) => {

var debug;
module.exports = function() {
    if (!debug) {
        try {
            /* eslint global-require: off */ debug = __turbopack_context__.r("[project]/node_modules/debug/src/index.js [app-ssr] (ecmascript)")("follow-redirects");
        } catch (error) {}
        if (typeof debug !== "function") {
            debug = function() {};
        }
    }
    debug.apply(null, arguments);
};
}),
"[project]/node_modules/follow-redirects/index.js [app-ssr] (ecmascript)", ((__turbopack_context__, module, exports) => {

var url = __turbopack_context__.r("[externals]/url [external] (url, cjs)");
var URL = url.URL;
var http = __turbopack_context__.r("[externals]/http [external] (http, cjs)");
var https = __turbopack_context__.r("[externals]/https [external] (https, cjs)");
var Writable = __turbopack_context__.r("[externals]/stream [external] (stream, cjs)").Writable;
var assert = __turbopack_context__.r("[externals]/assert [external] (assert, cjs)");
var debug = __turbopack_context__.r("[project]/node_modules/follow-redirects/debug.js [app-ssr] (ecmascript)");
// Preventive platform detection
// istanbul ignore next
(function detectUnsupportedEnvironment() {
    var looksLikeNode = typeof process !== "undefined";
    var looksLikeBrowser = ("TURBOPACK compile-time value", "undefined") !== "undefined" && typeof document !== "undefined";
    var looksLikeV8 = isFunction(Error.captureStackTrace);
    if (!looksLikeNode && (looksLikeBrowser || !looksLikeV8)) {
        console.warn("The follow-redirects package should be excluded from browser builds.");
    }
})();
// Whether to use the native URL object or the legacy url module
var useNativeURL = false;
try {
    assert(new URL(""));
} catch (error) {
    useNativeURL = error.code === "ERR_INVALID_URL";
}
// URL fields to preserve in copy operations
var preservedUrlFields = [
    "auth",
    "host",
    "hostname",
    "href",
    "path",
    "pathname",
    "port",
    "protocol",
    "query",
    "search",
    "hash"
];
// Create handlers that pass events from native requests
var events = [
    "abort",
    "aborted",
    "connect",
    "error",
    "socket",
    "timeout"
];
var eventHandlers = Object.create(null);
events.forEach(function(event) {
    eventHandlers[event] = function(arg1, arg2, arg3) {
        this._redirectable.emit(event, arg1, arg2, arg3);
    };
});
// Error types with codes
var InvalidUrlError = createErrorType("ERR_INVALID_URL", "Invalid URL", TypeError);
var RedirectionError = createErrorType("ERR_FR_REDIRECTION_FAILURE", "Redirected request failed");
var TooManyRedirectsError = createErrorType("ERR_FR_TOO_MANY_REDIRECTS", "Maximum number of redirects exceeded", RedirectionError);
var MaxBodyLengthExceededError = createErrorType("ERR_FR_MAX_BODY_LENGTH_EXCEEDED", "Request body larger than maxBodyLength limit");
var WriteAfterEndError = createErrorType("ERR_STREAM_WRITE_AFTER_END", "write after end");
// istanbul ignore next
var destroy = Writable.prototype.destroy || noop;
// An HTTP(S) request that can be redirected
function RedirectableRequest(options, responseCallback) {
    // Initialize the request
    Writable.call(this);
    this._sanitizeOptions(options);
    this._options = options;
    this._ended = false;
    this._ending = false;
    this._redirectCount = 0;
    this._redirects = [];
    this._requestBodyLength = 0;
    this._requestBodyBuffers = [];
    // Attach a callback if passed
    if (responseCallback) {
        this.on("response", responseCallback);
    }
    // React to responses of native requests
    var self = this;
    this._onNativeResponse = function(response) {
        try {
            self._processResponse(response);
        } catch (cause) {
            self.emit("error", cause instanceof RedirectionError ? cause : new RedirectionError({
                cause: cause
            }));
        }
    };
    // Perform the first request
    this._performRequest();
}
RedirectableRequest.prototype = Object.create(Writable.prototype);
RedirectableRequest.prototype.abort = function() {
    destroyRequest(this._currentRequest);
    this._currentRequest.abort();
    this.emit("abort");
};
RedirectableRequest.prototype.destroy = function(error) {
    destroyRequest(this._currentRequest, error);
    destroy.call(this, error);
    return this;
};
// Writes buffered data to the current native request
RedirectableRequest.prototype.write = function(data, encoding, callback) {
    // Writing is not allowed if end has been called
    if (this._ending) {
        throw new WriteAfterEndError();
    }
    // Validate input and shift parameters if necessary
    if (!isString(data) && !isBuffer(data)) {
        throw new TypeError("data should be a string, Buffer or Uint8Array");
    }
    if (isFunction(encoding)) {
        callback = encoding;
        encoding = null;
    }
    // Ignore empty buffers, since writing them doesn't invoke the callback
    // https://github.com/nodejs/node/issues/22066
    if (data.length === 0) {
        if (callback) {
            callback();
        }
        return;
    }
    // Only write when we don't exceed the maximum body length
    if (this._requestBodyLength + data.length <= this._options.maxBodyLength) {
        this._requestBodyLength += data.length;
        this._requestBodyBuffers.push({
            data: data,
            encoding: encoding
        });
        this._currentRequest.write(data, encoding, callback);
    } else {
        this.emit("error", new MaxBodyLengthExceededError());
        this.abort();
    }
};
// Ends the current native request
RedirectableRequest.prototype.end = function(data, encoding, callback) {
    // Shift parameters if necessary
    if (isFunction(data)) {
        callback = data;
        data = encoding = null;
    } else if (isFunction(encoding)) {
        callback = encoding;
        encoding = null;
    }
    // Write data if needed and end
    if (!data) {
        this._ended = this._ending = true;
        this._currentRequest.end(null, null, callback);
    } else {
        var self = this;
        var currentRequest = this._currentRequest;
        this.write(data, encoding, function() {
            self._ended = true;
            currentRequest.end(null, null, callback);
        });
        this._ending = true;
    }
};
// Sets a header value on the current native request
RedirectableRequest.prototype.setHeader = function(name, value) {
    this._options.headers[name] = value;
    this._currentRequest.setHeader(name, value);
};
// Clears a header value on the current native request
RedirectableRequest.prototype.removeHeader = function(name) {
    delete this._options.headers[name];
    this._currentRequest.removeHeader(name);
};
// Global timeout for all underlying requests
RedirectableRequest.prototype.setTimeout = function(msecs, callback) {
    var self = this;
    // Destroys the socket on timeout
    function destroyOnTimeout(socket) {
        socket.setTimeout(msecs);
        socket.removeListener("timeout", socket.destroy);
        socket.addListener("timeout", socket.destroy);
    }
    // Sets up a timer to trigger a timeout event
    function startTimer(socket) {
        if (self._timeout) {
            clearTimeout(self._timeout);
        }
        self._timeout = setTimeout(function() {
            self.emit("timeout");
            clearTimer();
        }, msecs);
        destroyOnTimeout(socket);
    }
    // Stops a timeout from triggering
    function clearTimer() {
        // Clear the timeout
        if (self._timeout) {
            clearTimeout(self._timeout);
            self._timeout = null;
        }
        // Clean up all attached listeners
        self.removeListener("abort", clearTimer);
        self.removeListener("error", clearTimer);
        self.removeListener("response", clearTimer);
        self.removeListener("close", clearTimer);
        if (callback) {
            self.removeListener("timeout", callback);
        }
        if (!self.socket) {
            self._currentRequest.removeListener("socket", startTimer);
        }
    }
    // Attach callback if passed
    if (callback) {
        this.on("timeout", callback);
    }
    // Start the timer if or when the socket is opened
    if (this.socket) {
        startTimer(this.socket);
    } else {
        this._currentRequest.once("socket", startTimer);
    }
    // Clean up on events
    this.on("socket", destroyOnTimeout);
    this.on("abort", clearTimer);
    this.on("error", clearTimer);
    this.on("response", clearTimer);
    this.on("close", clearTimer);
    return this;
};
// Proxy all other public ClientRequest methods
[
    "flushHeaders",
    "getHeader",
    "setNoDelay",
    "setSocketKeepAlive"
].forEach(function(method) {
    RedirectableRequest.prototype[method] = function(a, b) {
        return this._currentRequest[method](a, b);
    };
});
// Proxy all public ClientRequest properties
[
    "aborted",
    "connection",
    "socket"
].forEach(function(property) {
    Object.defineProperty(RedirectableRequest.prototype, property, {
        get: function() {
            return this._currentRequest[property];
        }
    });
});
RedirectableRequest.prototype._sanitizeOptions = function(options) {
    // Ensure headers are always present
    if (!options.headers) {
        options.headers = {};
    }
    // Since http.request treats host as an alias of hostname,
    // but the url module interprets host as hostname plus port,
    // eliminate the host property to avoid confusion.
    if (options.host) {
        // Use hostname if set, because it has precedence
        if (!options.hostname) {
            options.hostname = options.host;
        }
        delete options.host;
    }
    // Complete the URL object when necessary
    if (!options.pathname && options.path) {
        var searchPos = options.path.indexOf("?");
        if (searchPos < 0) {
            options.pathname = options.path;
        } else {
            options.pathname = options.path.substring(0, searchPos);
            options.search = options.path.substring(searchPos);
        }
    }
};
// Executes the next native request (initial or redirect)
RedirectableRequest.prototype._performRequest = function() {
    // Load the native protocol
    var protocol = this._options.protocol;
    var nativeProtocol = this._options.nativeProtocols[protocol];
    if (!nativeProtocol) {
        throw new TypeError("Unsupported protocol " + protocol);
    }
    // If specified, use the agent corresponding to the protocol
    // (HTTP and HTTPS use different types of agents)
    if (this._options.agents) {
        var scheme = protocol.slice(0, -1);
        this._options.agent = this._options.agents[scheme];
    }
    // Create the native request and set up its event handlers
    var request = this._currentRequest = nativeProtocol.request(this._options, this._onNativeResponse);
    request._redirectable = this;
    for (var event of events){
        request.on(event, eventHandlers[event]);
    }
    // RFC72305.3.1: When making a request directly to an origin server, []
    // a client MUST send only the absolute path [] as the request-target.
    this._currentUrl = /^\//.test(this._options.path) ? url.format(this._options) : // When making a request to a proxy, []
    // a client MUST send the target URI in absolute-form [].
    this._options.path;
    // End a redirected request
    // (The first request must be ended explicitly with RedirectableRequest#end)
    if (this._isRedirect) {
        // Write the request entity and end
        var i = 0;
        var self = this;
        var buffers = this._requestBodyBuffers;
        (function writeNext(error) {
            // Only write if this request has not been redirected yet
            // istanbul ignore else
            if (request === self._currentRequest) {
                // Report any write errors
                // istanbul ignore if
                if (error) {
                    self.emit("error", error);
                } else if (i < buffers.length) {
                    var buffer = buffers[i++];
                    // istanbul ignore else
                    if (!request.finished) {
                        request.write(buffer.data, buffer.encoding, writeNext);
                    }
                } else if (self._ended) {
                    request.end();
                }
            }
        })();
    }
};
// Processes a response from the current native request
RedirectableRequest.prototype._processResponse = function(response) {
    // Store the redirected response
    var statusCode = response.statusCode;
    if (this._options.trackRedirects) {
        this._redirects.push({
            url: this._currentUrl,
            headers: response.headers,
            statusCode: statusCode
        });
    }
    // RFC72316.4: The 3xx (Redirection) class of status code indicates
    // that further action needs to be taken by the user agent in order to
    // fulfill the request. If a Location header field is provided,
    // the user agent MAY automatically redirect its request to the URI
    // referenced by the Location field value,
    // even if the specific status code is not understood.
    // If the response is not a redirect; return it as-is
    var location = response.headers.location;
    if (!location || this._options.followRedirects === false || statusCode < 300 || statusCode >= 400) {
        response.responseUrl = this._currentUrl;
        response.redirects = this._redirects;
        this.emit("response", response);
        // Clean up
        this._requestBodyBuffers = [];
        return;
    }
    // The response is a redirect, so abort the current request
    destroyRequest(this._currentRequest);
    // Discard the remainder of the response to avoid waiting for data
    response.destroy();
    // RFC72316.4: A client SHOULD detect and intervene
    // in cyclical redirections (i.e., "infinite" redirection loops).
    if (++this._redirectCount > this._options.maxRedirects) {
        throw new TooManyRedirectsError();
    }
    // Store the request headers if applicable
    var requestHeaders;
    var beforeRedirect = this._options.beforeRedirect;
    if (beforeRedirect) {
        requestHeaders = Object.assign({
            // The Host header was set by nativeProtocol.request
            Host: response.req.getHeader("host")
        }, this._options.headers);
    }
    // RFC72316.4: Automatic redirection needs to done with
    // care for methods not known to be safe, []
    // RFC72316.4.23: For historical reasons, a user agent MAY change
    // the request method from POST to GET for the subsequent request.
    var method = this._options.method;
    if ((statusCode === 301 || statusCode === 302) && this._options.method === "POST" || // RFC72316.4.4: The 303 (See Other) status code indicates that
    // the server is redirecting the user agent to a different resource []
    // A user agent can perform a retrieval request targeting that URI
    // (a GET or HEAD request if using HTTP) []
    statusCode === 303 && !/^(?:GET|HEAD)$/.test(this._options.method)) {
        this._options.method = "GET";
        // Drop a possible entity and headers related to it
        this._requestBodyBuffers = [];
        removeMatchingHeaders(/^content-/i, this._options.headers);
    }
    // Drop the Host header, as the redirect might lead to a different host
    var currentHostHeader = removeMatchingHeaders(/^host$/i, this._options.headers);
    // If the redirect is relative, carry over the host of the last request
    var currentUrlParts = parseUrl(this._currentUrl);
    var currentHost = currentHostHeader || currentUrlParts.host;
    var currentUrl = /^\w+:/.test(location) ? this._currentUrl : url.format(Object.assign(currentUrlParts, {
        host: currentHost
    }));
    // Create the redirected request
    var redirectUrl = resolveUrl(location, currentUrl);
    debug("redirecting to", redirectUrl.href);
    this._isRedirect = true;
    spreadUrlObject(redirectUrl, this._options);
    // Drop confidential headers when redirecting to a less secure protocol
    // or to a different domain that is not a superdomain
    if (redirectUrl.protocol !== currentUrlParts.protocol && redirectUrl.protocol !== "https:" || redirectUrl.host !== currentHost && !isSubdomain(redirectUrl.host, currentHost)) {
        removeMatchingHeaders(/^(?:(?:proxy-)?authorization|cookie)$/i, this._options.headers);
    }
    // Evaluate the beforeRedirect callback
    if (isFunction(beforeRedirect)) {
        var responseDetails = {
            headers: response.headers,
            statusCode: statusCode
        };
        var requestDetails = {
            url: currentUrl,
            method: method,
            headers: requestHeaders
        };
        beforeRedirect(this._options, responseDetails, requestDetails);
        this._sanitizeOptions(this._options);
    }
    // Perform the redirected request
    this._performRequest();
};
// Wraps the key/value object of protocols with redirect functionality
function wrap(protocols) {
    // Default settings
    var exports = {
        maxRedirects: 21,
        maxBodyLength: 10 * 1024 * 1024
    };
    // Wrap each protocol
    var nativeProtocols = {};
    Object.keys(protocols).forEach(function(scheme) {
        var protocol = scheme + ":";
        var nativeProtocol = nativeProtocols[protocol] = protocols[scheme];
        var wrappedProtocol = exports[scheme] = Object.create(nativeProtocol);
        // Executes a request, following redirects
        function request(input, options, callback) {
            // Parse parameters, ensuring that input is an object
            if (isURL(input)) {
                input = spreadUrlObject(input);
            } else if (isString(input)) {
                input = spreadUrlObject(parseUrl(input));
            } else {
                callback = options;
                options = validateUrl(input);
                input = {
                    protocol: protocol
                };
            }
            if (isFunction(options)) {
                callback = options;
                options = null;
            }
            // Set defaults
            options = Object.assign({
                maxRedirects: exports.maxRedirects,
                maxBodyLength: exports.maxBodyLength
            }, input, options);
            options.nativeProtocols = nativeProtocols;
            if (!isString(options.host) && !isString(options.hostname)) {
                options.hostname = "::1";
            }
            assert.equal(options.protocol, protocol, "protocol mismatch");
            debug("options", options);
            return new RedirectableRequest(options, callback);
        }
        // Executes a GET request, following redirects
        function get(input, options, callback) {
            var wrappedRequest = wrappedProtocol.request(input, options, callback);
            wrappedRequest.end();
            return wrappedRequest;
        }
        // Expose the properties on the wrapped protocol
        Object.defineProperties(wrappedProtocol, {
            request: {
                value: request,
                configurable: true,
                enumerable: true,
                writable: true
            },
            get: {
                value: get,
                configurable: true,
                enumerable: true,
                writable: true
            }
        });
    });
    return exports;
}
function noop() {}
function parseUrl(input) {
    var parsed;
    // istanbul ignore else
    if (useNativeURL) {
        parsed = new URL(input);
    } else {
        // Ensure the URL is valid and absolute
        parsed = validateUrl(url.parse(input));
        if (!isString(parsed.protocol)) {
            throw new InvalidUrlError({
                input
            });
        }
    }
    return parsed;
}
function resolveUrl(relative, base) {
    // istanbul ignore next
    return useNativeURL ? new URL(relative, base) : parseUrl(url.resolve(base, relative));
}
function validateUrl(input) {
    if (/^\[/.test(input.hostname) && !/^\[[:0-9a-f]+\]$/i.test(input.hostname)) {
        throw new InvalidUrlError({
            input: input.href || input
        });
    }
    if (/^\[/.test(input.host) && !/^\[[:0-9a-f]+\](:\d+)?$/i.test(input.host)) {
        throw new InvalidUrlError({
            input: input.href || input
        });
    }
    return input;
}
function spreadUrlObject(urlObject, target) {
    var spread = target || {};
    for (var key of preservedUrlFields){
        spread[key] = urlObject[key];
    }
    // Fix IPv6 hostname
    if (spread.hostname.startsWith("[")) {
        spread.hostname = spread.hostname.slice(1, -1);
    }
    // Ensure port is a number
    if (spread.port !== "") {
        spread.port = Number(spread.port);
    }
    // Concatenate path
    spread.path = spread.search ? spread.pathname + spread.search : spread.pathname;
    return spread;
}
function removeMatchingHeaders(regex, headers) {
    var lastValue;
    for(var header in headers){
        if (regex.test(header)) {
            lastValue = headers[header];
            delete headers[header];
        }
    }
    return lastValue === null || typeof lastValue === "undefined" ? undefined : String(lastValue).trim();
}
function createErrorType(code, message, baseClass) {
    // Create constructor
    function CustomError(properties) {
        // istanbul ignore else
        if (isFunction(Error.captureStackTrace)) {
            Error.captureStackTrace(this, this.constructor);
        }
        Object.assign(this, properties || {});
        this.code = code;
        this.message = this.cause ? message + ": " + this.cause.message : message;
    }
    // Attach constructor and set default properties
    CustomError.prototype = new (baseClass || Error)();
    Object.defineProperties(CustomError.prototype, {
        constructor: {
            value: CustomError,
            enumerable: false
        },
        name: {
            value: "Error [" + code + "]",
            enumerable: false
        }
    });
    return CustomError;
}
function destroyRequest(request, error) {
    for (var event of events){
        request.removeListener(event, eventHandlers[event]);
    }
    request.on("error", noop);
    request.destroy(error);
}
function isSubdomain(subdomain, domain) {
    assert(isString(subdomain) && isString(domain));
    var dot = subdomain.length - domain.length - 1;
    return dot > 0 && subdomain[dot] === "." && subdomain.endsWith(domain);
}
function isString(value) {
    return typeof value === "string" || value instanceof String;
}
function isFunction(value) {
    return typeof value === "function";
}
function isBuffer(value) {
    return typeof value === "object" && "length" in value;
}
function isURL(value) {
    return URL && value instanceof URL;
}
// Exports
module.exports = wrap({
    http: http,
    https: https
});
module.exports.wrap = wrap;
}),
"[project]/node_modules/@stellar/js-xdr/src/errors.js [app-ssr] (ecmascript)", ((__turbopack_context__) => {
"use strict";

__turbopack_context__.s([
    "XdrDefinitionError",
    ()=>XdrDefinitionError,
    "XdrNotImplementedDefinitionError",
    ()=>XdrNotImplementedDefinitionError,
    "XdrReaderError",
    ()=>XdrReaderError,
    "XdrWriterError",
    ()=>XdrWriterError
]);
class XdrWriterError extends TypeError {
    constructor(message){
        super(`XDR Write Error: ${message}`);
    }
}
class XdrReaderError extends TypeError {
    constructor(message){
        super(`XDR Read Error: ${message}`);
    }
}
class XdrDefinitionError extends TypeError {
    constructor(message){
        super(`XDR Type Definition Error: ${message}`);
    }
}
class XdrNotImplementedDefinitionError extends XdrDefinitionError {
    constructor(){
        super(`method not implemented, it should be overloaded in the descendant class.`);
    }
}
}),
"[project]/node_modules/@stellar/js-xdr/src/serialization/xdr-reader.js [app-ssr] (ecmascript)", ((__turbopack_context__) => {
"use strict";

/**
 * @internal
 */ __turbopack_context__.s([
    "XdrReader",
    ()=>XdrReader
]);
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$stellar$2f$js$2d$xdr$2f$src$2f$errors$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/@stellar/js-xdr/src/errors.js [app-ssr] (ecmascript)");
;
class XdrReader {
    /**
   * @constructor
   * @param {Buffer} source - Buffer containing serialized data
   */ constructor(source){
        if (!Buffer.isBuffer(source)) {
            if (source instanceof Array || Array.isArray(source) || ArrayBuffer.isView(source)) {
                source = Buffer.from(source);
            } else {
                throw new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$stellar$2f$js$2d$xdr$2f$src$2f$errors$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["XdrReaderError"](`source invalid: ${source}`);
            }
        }
        this._buffer = source;
        this._length = source.length;
        this._index = 0;
    }
    /**
   * @type {Buffer}
   * @private
   * @readonly
   */ _buffer;
    /**
   * @type {Number}
   * @private
   * @readonly
   */ _length;
    /**
   * @type {Number}
   * @private
   * @readonly
   */ _index;
    /**
   * Check if the reader reached the end of the input buffer
   * @return {Boolean}
   */ get eof() {
        return this._index === this._length;
    }
    /**
   * Advance reader position, check padding and overflow
   * @param {Number} size - Bytes to read
   * @return {Number} Position to read from
   * @private
   */ advance(size) {
        const from = this._index;
        // advance cursor position
        this._index += size;
        // check buffer boundaries
        if (this._length < this._index) throw new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$stellar$2f$js$2d$xdr$2f$src$2f$errors$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["XdrReaderError"]('attempt to read outside the boundary of the buffer');
        // check that padding is correct for Opaque and String
        const padding = 4 - (size % 4 || 4);
        if (padding > 0) {
            for(let i = 0; i < padding; i++)if (this._buffer[this._index + i] !== 0) // all bytes in the padding should be zeros
            throw new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$stellar$2f$js$2d$xdr$2f$src$2f$errors$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["XdrReaderError"]('invalid padding');
            this._index += padding;
        }
        return from;
    }
    /**
   * Reset reader position
   * @return {void}
   */ rewind() {
        this._index = 0;
    }
    /**
   * Read byte array from the buffer
   * @param {Number} size - Bytes to read
   * @return {Buffer} - Sliced portion of the underlying buffer
   */ read(size) {
        const from = this.advance(size);
        return this._buffer.subarray(from, from + size);
    }
    /**
   * Read i32 from buffer
   * @return {Number}
   */ readInt32BE() {
        return this._buffer.readInt32BE(this.advance(4));
    }
    /**
   * Read u32 from buffer
   * @return {Number}
   */ readUInt32BE() {
        return this._buffer.readUInt32BE(this.advance(4));
    }
    /**
   * Read i64 from buffer
   * @return {BigInt}
   */ readBigInt64BE() {
        return this._buffer.readBigInt64BE(this.advance(8));
    }
    /**
   * Read u64 from buffer
   * @return {BigInt}
   */ readBigUInt64BE() {
        return this._buffer.readBigUInt64BE(this.advance(8));
    }
    /**
   * Read float from buffer
   * @return {Number}
   */ readFloatBE() {
        return this._buffer.readFloatBE(this.advance(4));
    }
    /**
   * Read double from buffer
   * @return {Number}
   */ readDoubleBE() {
        return this._buffer.readDoubleBE(this.advance(8));
    }
    /**
   * Ensure that input buffer has been consumed in full, otherwise it's a type mismatch
   * @return {void}
   * @throws {XdrReaderError}
   */ ensureInputConsumed() {
        if (this._index !== this._length) throw new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$stellar$2f$js$2d$xdr$2f$src$2f$errors$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["XdrReaderError"](`invalid XDR contract typecast - source buffer not entirely consumed`);
    }
}
}),
"[project]/node_modules/@stellar/js-xdr/src/serialization/xdr-writer.js [app-ssr] (ecmascript)", ((__turbopack_context__) => {
"use strict";

__turbopack_context__.s([
    "XdrWriter",
    ()=>XdrWriter
]);
const BUFFER_CHUNK = 8192; // 8 KB chunk size increment
class XdrWriter {
    /**
   * @param {Buffer|Number} [buffer] - Optional destination buffer
   */ constructor(buffer){
        if (typeof buffer === 'number') {
            buffer = Buffer.allocUnsafe(buffer);
        } else if (!(buffer instanceof Buffer)) {
            buffer = Buffer.allocUnsafe(BUFFER_CHUNK);
        }
        this._buffer = buffer;
        this._length = buffer.length;
    }
    /**
   * @type {Buffer}
   * @private
   * @readonly
   */ _buffer;
    /**
   * @type {Number}
   * @private
   * @readonly
   */ _length;
    /**
   * @type {Number}
   * @private
   * @readonly
   */ _index = 0;
    /**
   * Advance writer position, write padding if needed, auto-resize the buffer
   * @param {Number} size - Bytes to write
   * @return {Number} Position to read from
   * @private
   */ alloc(size) {
        const from = this._index;
        // advance cursor position
        this._index += size;
        // ensure sufficient buffer size
        if (this._length < this._index) {
            this.resize(this._index);
        }
        return from;
    }
    /**
   * Increase size of the underlying buffer
   * @param {Number} minRequiredSize - Minimum required buffer size
   * @return {void}
   * @private
   */ resize(minRequiredSize) {
        // calculate new length, align new buffer length by chunk size
        const newLength = Math.ceil(minRequiredSize / BUFFER_CHUNK) * BUFFER_CHUNK;
        // create new buffer and copy previous data
        const newBuffer = Buffer.allocUnsafe(newLength);
        this._buffer.copy(newBuffer, 0, 0, this._length);
        // update references
        this._buffer = newBuffer;
        this._length = newLength;
    }
    /**
   * Return XDR-serialized value
   * @return {Buffer}
   */ finalize() {
        // clip underlying buffer to the actually written value
        return this._buffer.subarray(0, this._index);
    }
    /**
   * Return XDR-serialized value as byte array
   * @return {Number[]}
   */ toArray() {
        return [
            ...this.finalize()
        ];
    }
    /**
   * Write byte array from the buffer
   * @param {Buffer|String} value - Bytes/string to write
   * @param {Number} size - Size in bytes
   * @return {XdrReader} - XdrReader wrapper on top of a subarray
   */ write(value, size) {
        if (typeof value === 'string') {
            // serialize string directly to the output buffer
            const offset = this.alloc(size);
            this._buffer.write(value, offset, 'utf8');
        } else {
            // copy data to the output buffer
            if (!(value instanceof Buffer)) {
                value = Buffer.from(value);
            }
            const offset = this.alloc(size);
            value.copy(this._buffer, offset, 0, size);
        }
        // add padding for 4-byte XDR alignment
        const padding = 4 - (size % 4 || 4);
        if (padding > 0) {
            const offset = this.alloc(padding);
            this._buffer.fill(0, offset, this._index);
        }
    }
    /**
   * Write i32 from buffer
   * @param {Number} value - Value to serialize
   * @return {void}
   */ writeInt32BE(value) {
        const offset = this.alloc(4);
        this._buffer.writeInt32BE(value, offset);
    }
    /**
   * Write u32 from buffer
   * @param {Number} value - Value to serialize
   * @return {void}
   */ writeUInt32BE(value) {
        const offset = this.alloc(4);
        this._buffer.writeUInt32BE(value, offset);
    }
    /**
   * Write i64 from buffer
   * @param {BigInt} value - Value to serialize
   * @return {void}
   */ writeBigInt64BE(value) {
        const offset = this.alloc(8);
        this._buffer.writeBigInt64BE(value, offset);
    }
    /**
   * Write u64 from buffer
   * @param {BigInt} value - Value to serialize
   * @return {void}
   */ writeBigUInt64BE(value) {
        const offset = this.alloc(8);
        this._buffer.writeBigUInt64BE(value, offset);
    }
    /**
   * Write float from buffer
   * @param {Number} value - Value to serialize
   * @return {void}
   */ writeFloatBE(value) {
        const offset = this.alloc(4);
        this._buffer.writeFloatBE(value, offset);
    }
    /**
   * Write double from buffer
   * @param {Number} value - Value to serialize
   * @return {void}
   */ writeDoubleBE(value) {
        const offset = this.alloc(8);
        this._buffer.writeDoubleBE(value, offset);
    }
    static bufferChunkSize = BUFFER_CHUNK;
}
}),
"[project]/node_modules/@stellar/js-xdr/src/xdr-type.js [app-ssr] (ecmascript)", ((__turbopack_context__) => {
"use strict";

__turbopack_context__.s([
    "XdrCompositeType",
    ()=>XdrCompositeType,
    "XdrPrimitiveType",
    ()=>XdrPrimitiveType,
    "hasConstructor",
    ()=>hasConstructor,
    "isSerializableIsh",
    ()=>isSerializableIsh
]);
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$stellar$2f$js$2d$xdr$2f$src$2f$serialization$2f$xdr$2d$reader$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/@stellar/js-xdr/src/serialization/xdr-reader.js [app-ssr] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$stellar$2f$js$2d$xdr$2f$src$2f$serialization$2f$xdr$2d$writer$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/@stellar/js-xdr/src/serialization/xdr-writer.js [app-ssr] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$stellar$2f$js$2d$xdr$2f$src$2f$errors$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/@stellar/js-xdr/src/errors.js [app-ssr] (ecmascript)");
;
;
;
class XdrType {
    /**
   * Encode value to XDR format
   * @param {XdrEncodingFormat} [format] - Encoding format (one of "raw", "hex", "base64")
   * @return {String|Buffer}
   */ toXDR(format = 'raw') {
        if (!this.write) return this.constructor.toXDR(this, format);
        const writer = new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$stellar$2f$js$2d$xdr$2f$src$2f$serialization$2f$xdr$2d$writer$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["XdrWriter"]();
        this.write(this, writer);
        return encodeResult(writer.finalize(), format);
    }
    /**
   * Decode XDR-encoded value
   * @param {Buffer|String} input - XDR-encoded input data
   * @param {XdrEncodingFormat} [format] - Encoding format (one of "raw", "hex", "base64")
   * @return {this}
   */ fromXDR(input, format = 'raw') {
        if (!this.read) return this.constructor.fromXDR(input, format);
        const reader = new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$stellar$2f$js$2d$xdr$2f$src$2f$serialization$2f$xdr$2d$reader$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["XdrReader"](decodeInput(input, format));
        const result = this.read(reader);
        reader.ensureInputConsumed();
        return result;
    }
    /**
   * Check whether input contains a valid XDR-encoded value
   * @param {Buffer|String} input - XDR-encoded input data
   * @param {XdrEncodingFormat} [format] - Encoding format (one of "raw", "hex", "base64")
   * @return {Boolean}
   */ validateXDR(input, format = 'raw') {
        try {
            this.fromXDR(input, format);
            return true;
        } catch (e) {
            return false;
        }
    }
    /**
   * Encode value to XDR format
   * @param {this} value - Value to serialize
   * @param {XdrEncodingFormat} [format] - Encoding format (one of "raw", "hex", "base64")
   * @return {Buffer}
   */ static toXDR(value, format = 'raw') {
        const writer = new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$stellar$2f$js$2d$xdr$2f$src$2f$serialization$2f$xdr$2d$writer$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["XdrWriter"]();
        this.write(value, writer);
        return encodeResult(writer.finalize(), format);
    }
    /**
   * Decode XDR-encoded value
   * @param {Buffer|String} input - XDR-encoded input data
   * @param {XdrEncodingFormat} [format] - Encoding format (one of "raw", "hex", "base64")
   * @return {this}
   */ static fromXDR(input, format = 'raw') {
        const reader = new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$stellar$2f$js$2d$xdr$2f$src$2f$serialization$2f$xdr$2d$reader$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["XdrReader"](decodeInput(input, format));
        const result = this.read(reader);
        reader.ensureInputConsumed();
        return result;
    }
    /**
   * Check whether input contains a valid XDR-encoded value
   * @param {Buffer|String} input - XDR-encoded input data
   * @param {XdrEncodingFormat} [format] - Encoding format (one of "raw", "hex", "base64")
   * @return {Boolean}
   */ static validateXDR(input, format = 'raw') {
        try {
            this.fromXDR(input, format);
            return true;
        } catch (e) {
            return false;
        }
    }
}
class XdrPrimitiveType extends XdrType {
    /**
   * Read value from the XDR-serialized input
   * @param {XdrReader} reader - XdrReader instance
   * @return {this}
   * @abstract
   */ // eslint-disable-next-line no-unused-vars
    static read(reader) {
        throw new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$stellar$2f$js$2d$xdr$2f$src$2f$errors$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["XdrNotImplementedDefinitionError"]();
    }
    /**
   * Write XDR value to the buffer
   * @param {this} value - Value to write
   * @param {XdrWriter} writer - XdrWriter instance
   * @return {void}
   * @abstract
   */ // eslint-disable-next-line no-unused-vars
    static write(value, writer) {
        throw new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$stellar$2f$js$2d$xdr$2f$src$2f$errors$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["XdrNotImplementedDefinitionError"]();
    }
    /**
   * Check whether XDR primitive value is valid
   * @param {this} value - Value to check
   * @return {Boolean}
   * @abstract
   */ // eslint-disable-next-line no-unused-vars
    static isValid(value) {
        return false;
    }
}
class XdrCompositeType extends XdrType {
    // Every descendant should implement two methods: read(reader) and write(value, writer)
    /**
   * Check whether XDR primitive value is valid
   * @param {this} value - Value to check
   * @return {Boolean}
   * @abstract
   */ // eslint-disable-next-line no-unused-vars
    isValid(value) {
        return false;
    }
}
class InvalidXdrEncodingFormatError extends TypeError {
    constructor(format){
        super(`Invalid format ${format}, must be one of "raw", "hex", "base64"`);
    }
}
function encodeResult(buffer, format) {
    switch(format){
        case 'raw':
            return buffer;
        case 'hex':
            return buffer.toString('hex');
        case 'base64':
            return buffer.toString('base64');
        default:
            throw new InvalidXdrEncodingFormatError(format);
    }
}
function decodeInput(input, format) {
    switch(format){
        case 'raw':
            return input;
        case 'hex':
            return Buffer.from(input, 'hex');
        case 'base64':
            return Buffer.from(input, 'base64');
        default:
            throw new InvalidXdrEncodingFormatError(format);
    }
}
function isSerializableIsh(value, subtype) {
    return value !== undefined && value !== null && // prereqs, otherwise `getPrototypeOf` pops
    (value instanceof subtype || hasConstructor(value, subtype) && // ensure it has read/write methods, then
    typeof value.constructor.read === 'function' && typeof value.constructor.write === 'function' && // ensure XdrType is in the prototype chain
    hasConstructor(value, 'XdrType'));
}
function hasConstructor(instance, subtype) {
    do {
        const ctor = instance.constructor;
        if (ctor.name === subtype) {
            return true;
        }
    }while (instance = Object.getPrototypeOf(instance))
    return false;
} /**
 * @typedef {'raw'|'hex'|'base64'} XdrEncodingFormat
 */ 
}),
"[project]/node_modules/@stellar/js-xdr/src/int.js [app-ssr] (ecmascript)", ((__turbopack_context__) => {
"use strict";

__turbopack_context__.s([
    "Int",
    ()=>Int
]);
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$stellar$2f$js$2d$xdr$2f$src$2f$xdr$2d$type$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/@stellar/js-xdr/src/xdr-type.js [app-ssr] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$stellar$2f$js$2d$xdr$2f$src$2f$errors$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/@stellar/js-xdr/src/errors.js [app-ssr] (ecmascript)");
;
;
const MAX_VALUE = 2147483647;
const MIN_VALUE = -2147483648;
class Int extends __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$stellar$2f$js$2d$xdr$2f$src$2f$xdr$2d$type$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["XdrPrimitiveType"] {
    /**
   * @inheritDoc
   */ static read(reader) {
        return reader.readInt32BE();
    }
    /**
   * @inheritDoc
   */ static write(value, writer) {
        if (typeof value !== 'number') throw new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$stellar$2f$js$2d$xdr$2f$src$2f$errors$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["XdrWriterError"]('not a number');
        if ((value | 0) !== value) throw new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$stellar$2f$js$2d$xdr$2f$src$2f$errors$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["XdrWriterError"]('invalid i32 value');
        writer.writeInt32BE(value);
    }
    /**
   * @inheritDoc
   */ static isValid(value) {
        if (typeof value !== 'number' || (value | 0) !== value) {
            return false;
        }
        return value >= MIN_VALUE && value <= MAX_VALUE;
    }
}
Int.MAX_VALUE = MAX_VALUE;
Int.MIN_VALUE = -MIN_VALUE;
}),
"[project]/node_modules/@stellar/js-xdr/src/bigint-encoder.js [app-ssr] (ecmascript)", ((__turbopack_context__) => {
"use strict";

/**
 * Encode a native `bigint` value from a list of arbitrary integer-like values.
 *
 * @param {Array<number|bigint|string>} parts - Slices to encode in big-endian
 *    format (i.e. earlier elements are higher bits)
 * @param {64|128|256} size - Number of bits in the target integer type
 * @param {boolean} unsigned - Whether it's an unsigned integer
 *
 * @returns {bigint}
 */ __turbopack_context__.s([
    "calculateBigIntBoundaries",
    ()=>calculateBigIntBoundaries,
    "encodeBigIntFromBits",
    ()=>encodeBigIntFromBits,
    "formatIntName",
    ()=>formatIntName,
    "sliceBigInt",
    ()=>sliceBigInt
]);
function encodeBigIntFromBits(parts, size, unsigned) {
    if (!(parts instanceof Array)) {
        // allow a single parameter instead of an array
        parts = [
            parts
        ];
    } else if (parts.length && parts[0] instanceof Array) {
        // unpack nested array param
        parts = parts[0];
    }
    const total = parts.length;
    const sliceSize = size / total;
    switch(sliceSize){
        case 32:
        case 64:
        case 128:
        case 256:
            break;
        default:
            throw new RangeError(`expected slices to fit in 32/64/128/256 bits, got ${parts}`);
    }
    // normalize all inputs to bigint
    try {
        for(let i = 0; i < parts.length; i++){
            if (typeof parts[i] !== 'bigint') {
                parts[i] = BigInt(parts[i].valueOf());
            }
        }
    } catch (e) {
        throw new TypeError(`expected bigint-like values, got: ${parts} (${e})`);
    }
    // check for sign mismatches for single inputs (this is a special case to
    // handle one parameter passed to e.g. UnsignedHyper et al.)
    // see https://github.com/stellar/js-xdr/pull/100#discussion_r1228770845
    if (unsigned && parts.length === 1 && parts[0] < 0n) {
        throw new RangeError(`expected a positive value, got: ${parts}`);
    }
    // encode in big-endian fashion, shifting each slice by the slice size
    let result = BigInt.asUintN(sliceSize, parts[0]); // safe: len >= 1
    for(let i = 1; i < parts.length; i++){
        result |= BigInt.asUintN(sliceSize, parts[i]) << BigInt(i * sliceSize);
    }
    // interpret value as signed if necessary and clamp it
    if (!unsigned) {
        result = BigInt.asIntN(size, result);
    }
    // check boundaries
    const [min, max] = calculateBigIntBoundaries(size, unsigned);
    if (result >= min && result <= max) {
        return result;
    }
    // failed to encode
    throw new TypeError(`bigint values [${parts}] for ${formatIntName(size, unsigned)} out of range [${min}, ${max}]: ${result}`);
}
function sliceBigInt(value, iSize, sliceSize) {
    if (typeof value !== 'bigint') {
        throw new TypeError(`Expected bigint 'value', got ${typeof value}`);
    }
    const total = iSize / sliceSize;
    if (total === 1) {
        return [
            value
        ];
    }
    if (sliceSize < 32 || sliceSize > 128 || total !== 2 && total !== 4 && total !== 8) {
        throw new TypeError(`invalid bigint (${value}) and slice size (${iSize} -> ${sliceSize}) combination`);
    }
    const shift = BigInt(sliceSize);
    // iterate shift and mask application
    const result = new Array(total);
    for(let i = 0; i < total; i++){
        // we force a signed interpretation to preserve sign in each slice value,
        // but downstream can convert to unsigned if it's appropriate
        result[i] = BigInt.asIntN(sliceSize, value); // clamps to size
        // move on to the next chunk
        value >>= shift;
    }
    return result;
}
function formatIntName(precision, unsigned) {
    return `${unsigned ? 'u' : 'i'}${precision}`;
}
function calculateBigIntBoundaries(size, unsigned) {
    if (unsigned) {
        return [
            0n,
            (1n << BigInt(size)) - 1n
        ];
    }
    const boundary = 1n << BigInt(size - 1);
    return [
        0n - boundary,
        boundary - 1n
    ];
}
}),
"[project]/node_modules/@stellar/js-xdr/src/large-int.js [app-ssr] (ecmascript)", ((__turbopack_context__) => {
"use strict";

__turbopack_context__.s([
    "LargeInt",
    ()=>LargeInt
]);
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$stellar$2f$js$2d$xdr$2f$src$2f$xdr$2d$type$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/@stellar/js-xdr/src/xdr-type.js [app-ssr] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$stellar$2f$js$2d$xdr$2f$src$2f$bigint$2d$encoder$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/@stellar/js-xdr/src/bigint-encoder.js [app-ssr] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$stellar$2f$js$2d$xdr$2f$src$2f$errors$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/@stellar/js-xdr/src/errors.js [app-ssr] (ecmascript)");
;
;
;
class LargeInt extends __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$stellar$2f$js$2d$xdr$2f$src$2f$xdr$2d$type$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["XdrPrimitiveType"] {
    /**
   * @param {Array<Number|BigInt|String>} parts - Slices to encode
   */ constructor(args){
        super();
        this._value = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$stellar$2f$js$2d$xdr$2f$src$2f$bigint$2d$encoder$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["encodeBigIntFromBits"])(args, this.size, this.unsigned);
    }
    /**
   * Signed/unsigned representation
   * @type {Boolean}
   * @abstract
   */ get unsigned() {
        throw new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$stellar$2f$js$2d$xdr$2f$src$2f$errors$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["XdrNotImplementedDefinitionError"]();
    }
    /**
   * Size of the integer in bits
   * @type {Number}
   * @abstract
   */ get size() {
        throw new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$stellar$2f$js$2d$xdr$2f$src$2f$errors$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["XdrNotImplementedDefinitionError"]();
    }
    /**
   * Slice integer to parts with smaller bit size
   * @param {32|64|128} sliceSize - Size of each part in bits
   * @return {BigInt[]}
   */ slice(sliceSize) {
        return (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$stellar$2f$js$2d$xdr$2f$src$2f$bigint$2d$encoder$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["sliceBigInt"])(this._value, this.size, sliceSize);
    }
    toString() {
        return this._value.toString();
    }
    toJSON() {
        return {
            _value: this._value.toString()
        };
    }
    toBigInt() {
        return BigInt(this._value);
    }
    /**
   * @inheritDoc
   */ static read(reader) {
        const { size } = this.prototype;
        if (size === 64) return new this(reader.readBigUInt64BE());
        return new this(...Array.from({
            length: size / 64
        }, ()=>reader.readBigUInt64BE()).reverse());
    }
    /**
   * @inheritDoc
   */ static write(value, writer) {
        if (value instanceof this) {
            value = value._value;
        } else if (typeof value !== 'bigint' || value > this.MAX_VALUE || value < this.MIN_VALUE) throw new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$stellar$2f$js$2d$xdr$2f$src$2f$errors$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["XdrWriterError"](`${value} is not a ${this.name}`);
        const { unsigned, size } = this.prototype;
        if (size === 64) {
            if (unsigned) {
                writer.writeBigUInt64BE(value);
            } else {
                writer.writeBigInt64BE(value);
            }
        } else {
            for (const part of (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$stellar$2f$js$2d$xdr$2f$src$2f$bigint$2d$encoder$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["sliceBigInt"])(value, size, 64).reverse()){
                if (unsigned) {
                    writer.writeBigUInt64BE(part);
                } else {
                    writer.writeBigInt64BE(part);
                }
            }
        }
    }
    /**
   * @inheritDoc
   */ static isValid(value) {
        return typeof value === 'bigint' || value instanceof this;
    }
    /**
   * Create instance from string
   * @param {String} string - Numeric representation
   * @return {LargeInt}
   */ static fromString(string) {
        return new this(string);
    }
    static MAX_VALUE = 0n;
    static MIN_VALUE = 0n;
    /**
   * @internal
   * @return {void}
   */ static defineIntBoundaries() {
        const [min, max] = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$stellar$2f$js$2d$xdr$2f$src$2f$bigint$2d$encoder$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["calculateBigIntBoundaries"])(this.prototype.size, this.prototype.unsigned);
        this.MIN_VALUE = min;
        this.MAX_VALUE = max;
    }
}
}),
"[project]/node_modules/@stellar/js-xdr/src/hyper.js [app-ssr] (ecmascript)", ((__turbopack_context__) => {
"use strict";

__turbopack_context__.s([
    "Hyper",
    ()=>Hyper
]);
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$stellar$2f$js$2d$xdr$2f$src$2f$large$2d$int$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/@stellar/js-xdr/src/large-int.js [app-ssr] (ecmascript)");
;
class Hyper extends __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$stellar$2f$js$2d$xdr$2f$src$2f$large$2d$int$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["LargeInt"] {
    /**
   * @param {Array<Number|BigInt|String>} parts - Slices to encode
   */ constructor(...args){
        super(args);
    }
    get low() {
        return Number(this._value & 0xffffffffn) << 0;
    }
    get high() {
        return Number(this._value >> 32n) >> 0;
    }
    get size() {
        return 64;
    }
    get unsigned() {
        return false;
    }
    /**
   * Create Hyper instance from two [high][low] i32 values
   * @param {Number} low - Low part of i64 number
   * @param {Number} high - High part of i64 number
   * @return {LargeInt}
   */ static fromBits(low, high) {
        return new this(low, high);
    }
}
Hyper.defineIntBoundaries();
}),
"[project]/node_modules/@stellar/js-xdr/src/unsigned-int.js [app-ssr] (ecmascript)", ((__turbopack_context__) => {
"use strict";

__turbopack_context__.s([
    "UnsignedInt",
    ()=>UnsignedInt
]);
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$stellar$2f$js$2d$xdr$2f$src$2f$xdr$2d$type$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/@stellar/js-xdr/src/xdr-type.js [app-ssr] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$stellar$2f$js$2d$xdr$2f$src$2f$errors$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/@stellar/js-xdr/src/errors.js [app-ssr] (ecmascript)");
;
;
const MAX_VALUE = 4294967295;
const MIN_VALUE = 0;
class UnsignedInt extends __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$stellar$2f$js$2d$xdr$2f$src$2f$xdr$2d$type$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["XdrPrimitiveType"] {
    /**
   * @inheritDoc
   */ static read(reader) {
        return reader.readUInt32BE();
    }
    /**
   * @inheritDoc
   */ static write(value, writer) {
        if (typeof value !== 'number' || !(value >= MIN_VALUE && value <= MAX_VALUE) || value % 1 !== 0) throw new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$stellar$2f$js$2d$xdr$2f$src$2f$errors$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["XdrWriterError"]('invalid u32 value');
        writer.writeUInt32BE(value);
    }
    /**
   * @inheritDoc
   */ static isValid(value) {
        if (typeof value !== 'number' || value % 1 !== 0) {
            return false;
        }
        return value >= MIN_VALUE && value <= MAX_VALUE;
    }
}
UnsignedInt.MAX_VALUE = MAX_VALUE;
UnsignedInt.MIN_VALUE = MIN_VALUE;
}),
"[project]/node_modules/@stellar/js-xdr/src/unsigned-hyper.js [app-ssr] (ecmascript)", ((__turbopack_context__) => {
"use strict";

__turbopack_context__.s([
    "UnsignedHyper",
    ()=>UnsignedHyper
]);
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$stellar$2f$js$2d$xdr$2f$src$2f$large$2d$int$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/@stellar/js-xdr/src/large-int.js [app-ssr] (ecmascript)");
;
class UnsignedHyper extends __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$stellar$2f$js$2d$xdr$2f$src$2f$large$2d$int$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["LargeInt"] {
    /**
   * @param {Array<Number|BigInt|String>} parts - Slices to encode
   */ constructor(...args){
        super(args);
    }
    get low() {
        return Number(this._value & 0xffffffffn) << 0;
    }
    get high() {
        return Number(this._value >> 32n) >> 0;
    }
    get size() {
        return 64;
    }
    get unsigned() {
        return true;
    }
    /**
   * Create UnsignedHyper instance from two [high][low] i32 values
   * @param {Number} low - Low part of u64 number
   * @param {Number} high - High part of u64 number
   * @return {UnsignedHyper}
   */ static fromBits(low, high) {
        return new this(low, high);
    }
}
UnsignedHyper.defineIntBoundaries();
}),
"[project]/node_modules/@stellar/js-xdr/src/float.js [app-ssr] (ecmascript)", ((__turbopack_context__) => {
"use strict";

__turbopack_context__.s([
    "Float",
    ()=>Float
]);
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$stellar$2f$js$2d$xdr$2f$src$2f$xdr$2d$type$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/@stellar/js-xdr/src/xdr-type.js [app-ssr] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$stellar$2f$js$2d$xdr$2f$src$2f$errors$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/@stellar/js-xdr/src/errors.js [app-ssr] (ecmascript)");
;
;
class Float extends __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$stellar$2f$js$2d$xdr$2f$src$2f$xdr$2d$type$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["XdrPrimitiveType"] {
    /**
   * @inheritDoc
   */ static read(reader) {
        return reader.readFloatBE();
    }
    /**
   * @inheritDoc
   */ static write(value, writer) {
        if (typeof value !== 'number') throw new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$stellar$2f$js$2d$xdr$2f$src$2f$errors$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["XdrWriterError"]('not a number');
        writer.writeFloatBE(value);
    }
    /**
   * @inheritDoc
   */ static isValid(value) {
        return typeof value === 'number';
    }
}
}),
"[project]/node_modules/@stellar/js-xdr/src/double.js [app-ssr] (ecmascript)", ((__turbopack_context__) => {
"use strict";

__turbopack_context__.s([
    "Double",
    ()=>Double
]);
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$stellar$2f$js$2d$xdr$2f$src$2f$xdr$2d$type$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/@stellar/js-xdr/src/xdr-type.js [app-ssr] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$stellar$2f$js$2d$xdr$2f$src$2f$errors$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/@stellar/js-xdr/src/errors.js [app-ssr] (ecmascript)");
;
;
class Double extends __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$stellar$2f$js$2d$xdr$2f$src$2f$xdr$2d$type$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["XdrPrimitiveType"] {
    /**
   * @inheritDoc
   */ static read(reader) {
        return reader.readDoubleBE();
    }
    /**
   * @inheritDoc
   */ static write(value, writer) {
        if (typeof value !== 'number') throw new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$stellar$2f$js$2d$xdr$2f$src$2f$errors$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["XdrWriterError"]('not a number');
        writer.writeDoubleBE(value);
    }
    /**
   * @inheritDoc
   */ static isValid(value) {
        return typeof value === 'number';
    }
}
}),
"[project]/node_modules/@stellar/js-xdr/src/quadruple.js [app-ssr] (ecmascript)", ((__turbopack_context__) => {
"use strict";

__turbopack_context__.s([
    "Quadruple",
    ()=>Quadruple
]);
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$stellar$2f$js$2d$xdr$2f$src$2f$xdr$2d$type$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/@stellar/js-xdr/src/xdr-type.js [app-ssr] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$stellar$2f$js$2d$xdr$2f$src$2f$errors$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/@stellar/js-xdr/src/errors.js [app-ssr] (ecmascript)");
;
;
class Quadruple extends __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$stellar$2f$js$2d$xdr$2f$src$2f$xdr$2d$type$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["XdrPrimitiveType"] {
    static read() {
        throw new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$stellar$2f$js$2d$xdr$2f$src$2f$errors$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["XdrDefinitionError"]('quadruple not supported');
    }
    static write() {
        throw new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$stellar$2f$js$2d$xdr$2f$src$2f$errors$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["XdrDefinitionError"]('quadruple not supported');
    }
    static isValid() {
        return false;
    }
}
}),
"[project]/node_modules/@stellar/js-xdr/src/bool.js [app-ssr] (ecmascript)", ((__turbopack_context__) => {
"use strict";

__turbopack_context__.s([
    "Bool",
    ()=>Bool
]);
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$stellar$2f$js$2d$xdr$2f$src$2f$int$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/@stellar/js-xdr/src/int.js [app-ssr] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$stellar$2f$js$2d$xdr$2f$src$2f$xdr$2d$type$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/@stellar/js-xdr/src/xdr-type.js [app-ssr] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$stellar$2f$js$2d$xdr$2f$src$2f$errors$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/@stellar/js-xdr/src/errors.js [app-ssr] (ecmascript)");
;
;
;
class Bool extends __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$stellar$2f$js$2d$xdr$2f$src$2f$xdr$2d$type$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["XdrPrimitiveType"] {
    /**
   * @inheritDoc
   */ static read(reader) {
        const value = __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$stellar$2f$js$2d$xdr$2f$src$2f$int$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["Int"].read(reader);
        switch(value){
            case 0:
                return false;
            case 1:
                return true;
            default:
                throw new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$stellar$2f$js$2d$xdr$2f$src$2f$errors$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["XdrReaderError"](`got ${value} when trying to read a bool`);
        }
    }
    /**
   * @inheritDoc
   */ static write(value, writer) {
        const intVal = value ? 1 : 0;
        __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$stellar$2f$js$2d$xdr$2f$src$2f$int$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["Int"].write(intVal, writer);
    }
    /**
   * @inheritDoc
   */ static isValid(value) {
        return typeof value === 'boolean';
    }
}
}),
"[project]/node_modules/@stellar/js-xdr/src/string.js [app-ssr] (ecmascript)", ((__turbopack_context__) => {
"use strict";

__turbopack_context__.s([
    "String",
    ()=>String
]);
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$stellar$2f$js$2d$xdr$2f$src$2f$unsigned$2d$int$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/@stellar/js-xdr/src/unsigned-int.js [app-ssr] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$stellar$2f$js$2d$xdr$2f$src$2f$xdr$2d$type$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/@stellar/js-xdr/src/xdr-type.js [app-ssr] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$stellar$2f$js$2d$xdr$2f$src$2f$errors$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/@stellar/js-xdr/src/errors.js [app-ssr] (ecmascript)");
;
;
;
class String extends __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$stellar$2f$js$2d$xdr$2f$src$2f$xdr$2d$type$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["XdrCompositeType"] {
    constructor(maxLength = __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$stellar$2f$js$2d$xdr$2f$src$2f$unsigned$2d$int$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["UnsignedInt"].MAX_VALUE){
        super();
        this._maxLength = maxLength;
    }
    /**
   * @inheritDoc
   */ read(reader) {
        const size = __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$stellar$2f$js$2d$xdr$2f$src$2f$unsigned$2d$int$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["UnsignedInt"].read(reader);
        if (size > this._maxLength) throw new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$stellar$2f$js$2d$xdr$2f$src$2f$errors$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["XdrReaderError"](`saw ${size} length String, max allowed is ${this._maxLength}`);
        return reader.read(size);
    }
    readString(reader) {
        return this.read(reader).toString('utf8');
    }
    /**
   * @inheritDoc
   */ write(value, writer) {
        // calculate string byte size before writing
        const size = typeof value === 'string' ? Buffer.byteLength(value, 'utf8') : value.length;
        if (size > this._maxLength) throw new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$stellar$2f$js$2d$xdr$2f$src$2f$errors$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["XdrWriterError"](`got ${value.length} bytes, max allowed is ${this._maxLength}`);
        // write size info
        __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$stellar$2f$js$2d$xdr$2f$src$2f$unsigned$2d$int$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["UnsignedInt"].write(size, writer);
        writer.write(value, size);
    }
    /**
   * @inheritDoc
   */ isValid(value) {
        if (typeof value === 'string') {
            return Buffer.byteLength(value, 'utf8') <= this._maxLength;
        }
        if (value instanceof Array || Buffer.isBuffer(value)) {
            return value.length <= this._maxLength;
        }
        return false;
    }
}
}),
"[project]/node_modules/@stellar/js-xdr/src/opaque.js [app-ssr] (ecmascript)", ((__turbopack_context__) => {
"use strict";

__turbopack_context__.s([
    "Opaque",
    ()=>Opaque
]);
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$stellar$2f$js$2d$xdr$2f$src$2f$xdr$2d$type$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/@stellar/js-xdr/src/xdr-type.js [app-ssr] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$stellar$2f$js$2d$xdr$2f$src$2f$errors$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/@stellar/js-xdr/src/errors.js [app-ssr] (ecmascript)");
;
;
class Opaque extends __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$stellar$2f$js$2d$xdr$2f$src$2f$xdr$2d$type$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["XdrCompositeType"] {
    constructor(length){
        super();
        this._length = length;
    }
    /**
   * @inheritDoc
   */ read(reader) {
        return reader.read(this._length);
    }
    /**
   * @inheritDoc
   */ write(value, writer) {
        const { length } = value;
        if (length !== this._length) throw new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$stellar$2f$js$2d$xdr$2f$src$2f$errors$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["XdrWriterError"](`got ${value.length} bytes, expected ${this._length}`);
        writer.write(value, length);
    }
    /**
   * @inheritDoc
   */ isValid(value) {
        return Buffer.isBuffer(value) && value.length === this._length;
    }
}
}),
"[project]/node_modules/@stellar/js-xdr/src/var-opaque.js [app-ssr] (ecmascript)", ((__turbopack_context__) => {
"use strict";

__turbopack_context__.s([
    "VarOpaque",
    ()=>VarOpaque
]);
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$stellar$2f$js$2d$xdr$2f$src$2f$unsigned$2d$int$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/@stellar/js-xdr/src/unsigned-int.js [app-ssr] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$stellar$2f$js$2d$xdr$2f$src$2f$xdr$2d$type$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/@stellar/js-xdr/src/xdr-type.js [app-ssr] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$stellar$2f$js$2d$xdr$2f$src$2f$errors$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/@stellar/js-xdr/src/errors.js [app-ssr] (ecmascript)");
;
;
;
class VarOpaque extends __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$stellar$2f$js$2d$xdr$2f$src$2f$xdr$2d$type$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["XdrCompositeType"] {
    constructor(maxLength = __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$stellar$2f$js$2d$xdr$2f$src$2f$unsigned$2d$int$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["UnsignedInt"].MAX_VALUE){
        super();
        this._maxLength = maxLength;
    }
    /**
   * @inheritDoc
   */ read(reader) {
        const size = __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$stellar$2f$js$2d$xdr$2f$src$2f$unsigned$2d$int$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["UnsignedInt"].read(reader);
        if (size > this._maxLength) throw new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$stellar$2f$js$2d$xdr$2f$src$2f$errors$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["XdrReaderError"](`saw ${size} length VarOpaque, max allowed is ${this._maxLength}`);
        return reader.read(size);
    }
    /**
   * @inheritDoc
   */ write(value, writer) {
        const { length } = value;
        if (value.length > this._maxLength) throw new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$stellar$2f$js$2d$xdr$2f$src$2f$errors$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["XdrWriterError"](`got ${value.length} bytes, max allowed is ${this._maxLength}`);
        // write size info
        __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$stellar$2f$js$2d$xdr$2f$src$2f$unsigned$2d$int$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["UnsignedInt"].write(length, writer);
        writer.write(value, length);
    }
    /**
   * @inheritDoc
   */ isValid(value) {
        return Buffer.isBuffer(value) && value.length <= this._maxLength;
    }
}
}),
"[project]/node_modules/@stellar/js-xdr/src/array.js [app-ssr] (ecmascript)", ((__turbopack_context__) => {
"use strict";

__turbopack_context__.s([
    "Array",
    ()=>Array
]);
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$stellar$2f$js$2d$xdr$2f$src$2f$xdr$2d$type$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/@stellar/js-xdr/src/xdr-type.js [app-ssr] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$stellar$2f$js$2d$xdr$2f$src$2f$errors$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/@stellar/js-xdr/src/errors.js [app-ssr] (ecmascript)");
;
;
class Array extends __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$stellar$2f$js$2d$xdr$2f$src$2f$xdr$2d$type$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["XdrCompositeType"] {
    constructor(childType, length){
        super();
        this._childType = childType;
        this._length = length;
    }
    /**
   * @inheritDoc
   */ read(reader) {
        // allocate array of specified length
        const result = new /*TURBOPACK member replacement*/ __turbopack_context__.g.Array(this._length);
        // read values
        for(let i = 0; i < this._length; i++){
            result[i] = this._childType.read(reader);
        }
        return result;
    }
    /**
   * @inheritDoc
   */ write(value, writer) {
        if (!/*TURBOPACK member replacement*/ __turbopack_context__.g.Array.isArray(value)) throw new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$stellar$2f$js$2d$xdr$2f$src$2f$errors$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["XdrWriterError"](`value is not array`);
        if (value.length !== this._length) throw new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$stellar$2f$js$2d$xdr$2f$src$2f$errors$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["XdrWriterError"](`got array of size ${value.length}, expected ${this._length}`);
        for (const child of value){
            this._childType.write(child, writer);
        }
    }
    /**
   * @inheritDoc
   */ isValid(value) {
        if (!(value instanceof /*TURBOPACK member replacement*/ __turbopack_context__.g.Array) || value.length !== this._length) {
            return false;
        }
        for (const child of value){
            if (!this._childType.isValid(child)) return false;
        }
        return true;
    }
}
}),
"[project]/node_modules/@stellar/js-xdr/src/var-array.js [app-ssr] (ecmascript)", ((__turbopack_context__) => {
"use strict";

__turbopack_context__.s([
    "VarArray",
    ()=>VarArray
]);
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$stellar$2f$js$2d$xdr$2f$src$2f$unsigned$2d$int$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/@stellar/js-xdr/src/unsigned-int.js [app-ssr] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$stellar$2f$js$2d$xdr$2f$src$2f$xdr$2d$type$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/@stellar/js-xdr/src/xdr-type.js [app-ssr] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$stellar$2f$js$2d$xdr$2f$src$2f$errors$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/@stellar/js-xdr/src/errors.js [app-ssr] (ecmascript)");
;
;
;
class VarArray extends __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$stellar$2f$js$2d$xdr$2f$src$2f$xdr$2d$type$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["XdrCompositeType"] {
    constructor(childType, maxLength = __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$stellar$2f$js$2d$xdr$2f$src$2f$unsigned$2d$int$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["UnsignedInt"].MAX_VALUE){
        super();
        this._childType = childType;
        this._maxLength = maxLength;
    }
    /**
   * @inheritDoc
   */ read(reader) {
        const length = __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$stellar$2f$js$2d$xdr$2f$src$2f$unsigned$2d$int$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["UnsignedInt"].read(reader);
        if (length > this._maxLength) throw new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$stellar$2f$js$2d$xdr$2f$src$2f$errors$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["XdrReaderError"](`saw ${length} length VarArray, max allowed is ${this._maxLength}`);
        const result = new Array(length);
        for(let i = 0; i < length; i++){
            result[i] = this._childType.read(reader);
        }
        return result;
    }
    /**
   * @inheritDoc
   */ write(value, writer) {
        if (!(value instanceof Array)) throw new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$stellar$2f$js$2d$xdr$2f$src$2f$errors$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["XdrWriterError"](`value is not array`);
        if (value.length > this._maxLength) throw new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$stellar$2f$js$2d$xdr$2f$src$2f$errors$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["XdrWriterError"](`got array of size ${value.length}, max allowed is ${this._maxLength}`);
        __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$stellar$2f$js$2d$xdr$2f$src$2f$unsigned$2d$int$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["UnsignedInt"].write(value.length, writer);
        for (const child of value){
            this._childType.write(child, writer);
        }
    }
    /**
   * @inheritDoc
   */ isValid(value) {
        if (!(value instanceof Array) || value.length > this._maxLength) {
            return false;
        }
        for (const child of value){
            if (!this._childType.isValid(child)) return false;
        }
        return true;
    }
}
}),
"[project]/node_modules/@stellar/js-xdr/src/option.js [app-ssr] (ecmascript)", ((__turbopack_context__) => {
"use strict";

__turbopack_context__.s([
    "Option",
    ()=>Option
]);
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$stellar$2f$js$2d$xdr$2f$src$2f$bool$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/@stellar/js-xdr/src/bool.js [app-ssr] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$stellar$2f$js$2d$xdr$2f$src$2f$xdr$2d$type$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/@stellar/js-xdr/src/xdr-type.js [app-ssr] (ecmascript)");
;
;
class Option extends __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$stellar$2f$js$2d$xdr$2f$src$2f$xdr$2d$type$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["XdrPrimitiveType"] {
    constructor(childType){
        super();
        this._childType = childType;
    }
    /**
   * @inheritDoc
   */ read(reader) {
        if (__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$stellar$2f$js$2d$xdr$2f$src$2f$bool$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["Bool"].read(reader)) {
            return this._childType.read(reader);
        }
        return undefined;
    }
    /**
   * @inheritDoc
   */ write(value, writer) {
        const isPresent = value !== null && value !== undefined;
        __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$stellar$2f$js$2d$xdr$2f$src$2f$bool$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["Bool"].write(isPresent, writer);
        if (isPresent) {
            this._childType.write(value, writer);
        }
    }
    /**
   * @inheritDoc
   */ isValid(value) {
        if (value === null || value === undefined) {
            return true;
        }
        return this._childType.isValid(value);
    }
}
}),
"[project]/node_modules/@stellar/js-xdr/src/void.js [app-ssr] (ecmascript)", ((__turbopack_context__) => {
"use strict";

__turbopack_context__.s([
    "Void",
    ()=>Void
]);
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$stellar$2f$js$2d$xdr$2f$src$2f$xdr$2d$type$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/@stellar/js-xdr/src/xdr-type.js [app-ssr] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$stellar$2f$js$2d$xdr$2f$src$2f$errors$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/@stellar/js-xdr/src/errors.js [app-ssr] (ecmascript)");
;
;
class Void extends __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$stellar$2f$js$2d$xdr$2f$src$2f$xdr$2d$type$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["XdrPrimitiveType"] {
    /* jshint unused: false */ static read() {
        return undefined;
    }
    static write(value) {
        if (value !== undefined) throw new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$stellar$2f$js$2d$xdr$2f$src$2f$errors$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["XdrWriterError"]('trying to write value to a void slot');
    }
    static isValid(value) {
        return value === undefined;
    }
}
}),
"[project]/node_modules/@stellar/js-xdr/src/enum.js [app-ssr] (ecmascript)", ((__turbopack_context__) => {
"use strict";

__turbopack_context__.s([
    "Enum",
    ()=>Enum
]);
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$stellar$2f$js$2d$xdr$2f$src$2f$int$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/@stellar/js-xdr/src/int.js [app-ssr] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$stellar$2f$js$2d$xdr$2f$src$2f$xdr$2d$type$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/@stellar/js-xdr/src/xdr-type.js [app-ssr] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$stellar$2f$js$2d$xdr$2f$src$2f$errors$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/@stellar/js-xdr/src/errors.js [app-ssr] (ecmascript)");
;
;
;
class Enum extends __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$stellar$2f$js$2d$xdr$2f$src$2f$xdr$2d$type$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["XdrPrimitiveType"] {
    constructor(name, value){
        super();
        this.name = name;
        this.value = value;
    }
    /**
   * @inheritDoc
   */ static read(reader) {
        const intVal = __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$stellar$2f$js$2d$xdr$2f$src$2f$int$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["Int"].read(reader);
        const res = this._byValue[intVal];
        if (res === undefined) throw new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$stellar$2f$js$2d$xdr$2f$src$2f$errors$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["XdrReaderError"](`unknown ${this.enumName} member for value ${intVal}`);
        return res;
    }
    /**
   * @inheritDoc
   */ static write(value, writer) {
        if (!this.isValid(value)) {
            throw new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$stellar$2f$js$2d$xdr$2f$src$2f$errors$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["XdrWriterError"](`${value} has enum name ${value?.enumName}, not ${this.enumName}: ${JSON.stringify(value)}`);
        }
        __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$stellar$2f$js$2d$xdr$2f$src$2f$int$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["Int"].write(value.value, writer);
    }
    /**
   * @inheritDoc
   */ static isValid(value) {
        return value?.constructor?.enumName === this.enumName || (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$stellar$2f$js$2d$xdr$2f$src$2f$xdr$2d$type$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["isSerializableIsh"])(value, this);
    }
    static members() {
        return this._members;
    }
    static values() {
        return Object.values(this._members);
    }
    static fromName(name) {
        const result = this._members[name];
        if (!result) throw new TypeError(`${name} is not a member of ${this.enumName}`);
        return result;
    }
    static fromValue(value) {
        const result = this._byValue[value];
        if (result === undefined) throw new TypeError(`${value} is not a value of any member of ${this.enumName}`);
        return result;
    }
    static create(context, name, members) {
        const ChildEnum = class extends Enum {
        };
        ChildEnum.enumName = name;
        context.results[name] = ChildEnum;
        ChildEnum._members = {};
        ChildEnum._byValue = {};
        for (const [key, value] of Object.entries(members)){
            const inst = new ChildEnum(key, value);
            ChildEnum._members[key] = inst;
            ChildEnum._byValue[value] = inst;
            ChildEnum[key] = ()=>inst;
        }
        return ChildEnum;
    }
}
}),
"[project]/node_modules/@stellar/js-xdr/src/reference.js [app-ssr] (ecmascript)", ((__turbopack_context__) => {
"use strict";

__turbopack_context__.s([
    "Reference",
    ()=>Reference
]);
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$stellar$2f$js$2d$xdr$2f$src$2f$xdr$2d$type$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/@stellar/js-xdr/src/xdr-type.js [app-ssr] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$stellar$2f$js$2d$xdr$2f$src$2f$errors$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/@stellar/js-xdr/src/errors.js [app-ssr] (ecmascript)");
;
;
class Reference extends __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$stellar$2f$js$2d$xdr$2f$src$2f$xdr$2d$type$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["XdrPrimitiveType"] {
    /* jshint unused: false */ resolve() {
        throw new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$stellar$2f$js$2d$xdr$2f$src$2f$errors$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["XdrDefinitionError"]('"resolve" method should be implemented in the descendant class');
    }
}
}),
"[project]/node_modules/@stellar/js-xdr/src/struct.js [app-ssr] (ecmascript)", ((__turbopack_context__) => {
"use strict";

__turbopack_context__.s([
    "Struct",
    ()=>Struct
]);
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$stellar$2f$js$2d$xdr$2f$src$2f$reference$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/@stellar/js-xdr/src/reference.js [app-ssr] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$stellar$2f$js$2d$xdr$2f$src$2f$xdr$2d$type$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/@stellar/js-xdr/src/xdr-type.js [app-ssr] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$stellar$2f$js$2d$xdr$2f$src$2f$errors$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/@stellar/js-xdr/src/errors.js [app-ssr] (ecmascript)");
;
;
;
class Struct extends __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$stellar$2f$js$2d$xdr$2f$src$2f$xdr$2d$type$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["XdrCompositeType"] {
    constructor(attributes){
        super();
        this._attributes = attributes || {};
    }
    /**
   * @inheritDoc
   */ static read(reader) {
        const attributes = {};
        for (const [fieldName, type] of this._fields){
            attributes[fieldName] = type.read(reader);
        }
        return new this(attributes);
    }
    /**
   * @inheritDoc
   */ static write(value, writer) {
        if (!this.isValid(value)) {
            throw new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$stellar$2f$js$2d$xdr$2f$src$2f$errors$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["XdrWriterError"](`${value} has struct name ${value?.constructor?.structName}, not ${this.structName}: ${JSON.stringify(value)}`);
        }
        for (const [fieldName, type] of this._fields){
            const attribute = value._attributes[fieldName];
            type.write(attribute, writer);
        }
    }
    /**
   * @inheritDoc
   */ static isValid(value) {
        return value?.constructor?.structName === this.structName || (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$stellar$2f$js$2d$xdr$2f$src$2f$xdr$2d$type$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["isSerializableIsh"])(value, this);
    }
    static create(context, name, fields) {
        const ChildStruct = class extends Struct {
        };
        ChildStruct.structName = name;
        context.results[name] = ChildStruct;
        const mappedFields = new Array(fields.length);
        for(let i = 0; i < fields.length; i++){
            const fieldDescriptor = fields[i];
            const fieldName = fieldDescriptor[0];
            let field = fieldDescriptor[1];
            if (field instanceof __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$stellar$2f$js$2d$xdr$2f$src$2f$reference$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["Reference"]) {
                field = field.resolve(context);
            }
            mappedFields[i] = [
                fieldName,
                field
            ];
            // create accessors
            ChildStruct.prototype[fieldName] = createAccessorMethod(fieldName);
        }
        ChildStruct._fields = mappedFields;
        return ChildStruct;
    }
}
function createAccessorMethod(name) {
    return function readOrWriteAttribute(value) {
        if (value !== undefined) {
            this._attributes[name] = value;
        }
        return this._attributes[name];
    };
}
}),
"[project]/node_modules/@stellar/js-xdr/src/union.js [app-ssr] (ecmascript)", ((__turbopack_context__) => {
"use strict";

__turbopack_context__.s([
    "Union",
    ()=>Union
]);
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$stellar$2f$js$2d$xdr$2f$src$2f$void$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/@stellar/js-xdr/src/void.js [app-ssr] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$stellar$2f$js$2d$xdr$2f$src$2f$reference$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/@stellar/js-xdr/src/reference.js [app-ssr] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$stellar$2f$js$2d$xdr$2f$src$2f$xdr$2d$type$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/@stellar/js-xdr/src/xdr-type.js [app-ssr] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$stellar$2f$js$2d$xdr$2f$src$2f$errors$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/@stellar/js-xdr/src/errors.js [app-ssr] (ecmascript)");
;
;
;
;
class Union extends __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$stellar$2f$js$2d$xdr$2f$src$2f$xdr$2d$type$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["XdrCompositeType"] {
    constructor(aSwitch, value){
        super();
        this.set(aSwitch, value);
    }
    set(aSwitch, value) {
        if (typeof aSwitch === 'string') {
            aSwitch = this.constructor._switchOn.fromName(aSwitch);
        }
        this._switch = aSwitch;
        const arm = this.constructor.armForSwitch(this._switch);
        this._arm = arm;
        this._armType = arm === __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$stellar$2f$js$2d$xdr$2f$src$2f$void$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["Void"] ? __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$stellar$2f$js$2d$xdr$2f$src$2f$void$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["Void"] : this.constructor._arms[arm];
        this._value = value;
    }
    get(armName = this._arm) {
        if (this._arm !== __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$stellar$2f$js$2d$xdr$2f$src$2f$void$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["Void"] && this._arm !== armName) throw new TypeError(`${armName} not set`);
        return this._value;
    }
    switch() {
        return this._switch;
    }
    arm() {
        return this._arm;
    }
    armType() {
        return this._armType;
    }
    value() {
        return this._value;
    }
    static armForSwitch(aSwitch) {
        const member = this._switches.get(aSwitch);
        if (member !== undefined) {
            return member;
        }
        if (this._defaultArm) {
            return this._defaultArm;
        }
        throw new TypeError(`Bad union switch: ${aSwitch}`);
    }
    static armTypeForArm(arm) {
        if (arm === __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$stellar$2f$js$2d$xdr$2f$src$2f$void$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["Void"]) {
            return __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$stellar$2f$js$2d$xdr$2f$src$2f$void$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["Void"];
        }
        return this._arms[arm];
    }
    /**
   * @inheritDoc
   */ static read(reader) {
        const aSwitch = this._switchOn.read(reader);
        const arm = this.armForSwitch(aSwitch);
        const armType = arm === __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$stellar$2f$js$2d$xdr$2f$src$2f$void$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["Void"] ? __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$stellar$2f$js$2d$xdr$2f$src$2f$void$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["Void"] : this._arms[arm];
        let value;
        if (armType !== undefined) {
            value = armType.read(reader);
        } else {
            value = arm.read(reader);
        }
        return new this(aSwitch, value);
    }
    /**
   * @inheritDoc
   */ static write(value, writer) {
        if (!this.isValid(value)) {
            throw new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$stellar$2f$js$2d$xdr$2f$src$2f$errors$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["XdrWriterError"](`${value} has union name ${value?.unionName}, not ${this.unionName}: ${JSON.stringify(value)}`);
        }
        this._switchOn.write(value.switch(), writer);
        value.armType().write(value.value(), writer);
    }
    /**
   * @inheritDoc
   */ static isValid(value) {
        return value?.constructor?.unionName === this.unionName || (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$stellar$2f$js$2d$xdr$2f$src$2f$xdr$2d$type$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["isSerializableIsh"])(value, this);
    }
    static create(context, name, config) {
        const ChildUnion = class extends Union {
        };
        ChildUnion.unionName = name;
        context.results[name] = ChildUnion;
        if (config.switchOn instanceof __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$stellar$2f$js$2d$xdr$2f$src$2f$reference$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["Reference"]) {
            ChildUnion._switchOn = config.switchOn.resolve(context);
        } else {
            ChildUnion._switchOn = config.switchOn;
        }
        ChildUnion._switches = new Map();
        ChildUnion._arms = {};
        // resolve default arm
        let defaultArm = config.defaultArm;
        if (defaultArm instanceof __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$stellar$2f$js$2d$xdr$2f$src$2f$reference$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["Reference"]) {
            defaultArm = defaultArm.resolve(context);
        }
        ChildUnion._defaultArm = defaultArm;
        for (const [aSwitch, armName] of config.switches){
            const key = typeof aSwitch === 'string' ? ChildUnion._switchOn.fromName(aSwitch) : aSwitch;
            ChildUnion._switches.set(key, armName);
        }
        // add enum-based helpers
        // NOTE: we don't have good notation for "is a subclass of XDR.Enum",
        //  and so we use the following check (does _switchOn have a `values`
        //  attribute) to approximate the intent.
        if (ChildUnion._switchOn.values !== undefined) {
            for (const aSwitch of ChildUnion._switchOn.values()){
                // Add enum-based constructors
                ChildUnion[aSwitch.name] = function ctr(value) {
                    return new ChildUnion(aSwitch, value);
                };
                // Add enum-based "set" helpers
                ChildUnion.prototype[aSwitch.name] = function set(value) {
                    return this.set(aSwitch, value);
                };
            }
        }
        if (config.arms) {
            for (const [armsName, value] of Object.entries(config.arms)){
                ChildUnion._arms[armsName] = value instanceof __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$stellar$2f$js$2d$xdr$2f$src$2f$reference$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["Reference"] ? value.resolve(context) : value;
                // Add arm accessor helpers
                if (value !== __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$stellar$2f$js$2d$xdr$2f$src$2f$void$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["Void"]) {
                    ChildUnion.prototype[armsName] = function get() {
                        return this.get(armsName);
                    };
                }
            }
        }
        return ChildUnion;
    }
}
}),
"[project]/node_modules/@stellar/js-xdr/src/types.js [app-ssr] (ecmascript) <locals>", ((__turbopack_context__) => {
"use strict";

__turbopack_context__.s([]);
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$stellar$2f$js$2d$xdr$2f$src$2f$int$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/@stellar/js-xdr/src/int.js [app-ssr] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$stellar$2f$js$2d$xdr$2f$src$2f$hyper$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/@stellar/js-xdr/src/hyper.js [app-ssr] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$stellar$2f$js$2d$xdr$2f$src$2f$unsigned$2d$int$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/@stellar/js-xdr/src/unsigned-int.js [app-ssr] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$stellar$2f$js$2d$xdr$2f$src$2f$unsigned$2d$hyper$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/@stellar/js-xdr/src/unsigned-hyper.js [app-ssr] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$stellar$2f$js$2d$xdr$2f$src$2f$large$2d$int$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/@stellar/js-xdr/src/large-int.js [app-ssr] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$stellar$2f$js$2d$xdr$2f$src$2f$float$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/@stellar/js-xdr/src/float.js [app-ssr] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$stellar$2f$js$2d$xdr$2f$src$2f$double$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/@stellar/js-xdr/src/double.js [app-ssr] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$stellar$2f$js$2d$xdr$2f$src$2f$quadruple$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/@stellar/js-xdr/src/quadruple.js [app-ssr] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$stellar$2f$js$2d$xdr$2f$src$2f$bool$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/@stellar/js-xdr/src/bool.js [app-ssr] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$stellar$2f$js$2d$xdr$2f$src$2f$string$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/@stellar/js-xdr/src/string.js [app-ssr] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$stellar$2f$js$2d$xdr$2f$src$2f$opaque$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/@stellar/js-xdr/src/opaque.js [app-ssr] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$stellar$2f$js$2d$xdr$2f$src$2f$var$2d$opaque$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/@stellar/js-xdr/src/var-opaque.js [app-ssr] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$stellar$2f$js$2d$xdr$2f$src$2f$array$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/@stellar/js-xdr/src/array.js [app-ssr] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$stellar$2f$js$2d$xdr$2f$src$2f$var$2d$array$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/@stellar/js-xdr/src/var-array.js [app-ssr] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$stellar$2f$js$2d$xdr$2f$src$2f$option$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/@stellar/js-xdr/src/option.js [app-ssr] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$stellar$2f$js$2d$xdr$2f$src$2f$void$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/@stellar/js-xdr/src/void.js [app-ssr] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$stellar$2f$js$2d$xdr$2f$src$2f$enum$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/@stellar/js-xdr/src/enum.js [app-ssr] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$stellar$2f$js$2d$xdr$2f$src$2f$struct$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/@stellar/js-xdr/src/struct.js [app-ssr] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$stellar$2f$js$2d$xdr$2f$src$2f$union$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/@stellar/js-xdr/src/union.js [app-ssr] (ecmascript)");
;
;
;
;
;
;
;
;
;
;
;
;
;
;
;
;
;
;
;
}),
"[project]/node_modules/@stellar/js-xdr/src/config.js [app-ssr] (ecmascript) <locals>", ((__turbopack_context__) => {
"use strict";

// eslint-disable-next-line max-classes-per-file
__turbopack_context__.s([
    "config",
    ()=>config
]);
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$stellar$2f$js$2d$xdr$2f$src$2f$types$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__$3c$locals$3e$__ = __turbopack_context__.i("[project]/node_modules/@stellar/js-xdr/src/types.js [app-ssr] (ecmascript) <locals>");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$stellar$2f$js$2d$xdr$2f$src$2f$array$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/@stellar/js-xdr/src/array.js [app-ssr] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$stellar$2f$js$2d$xdr$2f$src$2f$var$2d$array$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/@stellar/js-xdr/src/var-array.js [app-ssr] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$stellar$2f$js$2d$xdr$2f$src$2f$option$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/@stellar/js-xdr/src/option.js [app-ssr] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$stellar$2f$js$2d$xdr$2f$src$2f$enum$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/@stellar/js-xdr/src/enum.js [app-ssr] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$stellar$2f$js$2d$xdr$2f$src$2f$struct$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/@stellar/js-xdr/src/struct.js [app-ssr] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$stellar$2f$js$2d$xdr$2f$src$2f$union$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/@stellar/js-xdr/src/union.js [app-ssr] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$stellar$2f$js$2d$xdr$2f$src$2f$void$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/@stellar/js-xdr/src/void.js [app-ssr] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$stellar$2f$js$2d$xdr$2f$src$2f$bool$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/@stellar/js-xdr/src/bool.js [app-ssr] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$stellar$2f$js$2d$xdr$2f$src$2f$int$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/@stellar/js-xdr/src/int.js [app-ssr] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$stellar$2f$js$2d$xdr$2f$src$2f$hyper$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/@stellar/js-xdr/src/hyper.js [app-ssr] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$stellar$2f$js$2d$xdr$2f$src$2f$unsigned$2d$int$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/@stellar/js-xdr/src/unsigned-int.js [app-ssr] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$stellar$2f$js$2d$xdr$2f$src$2f$unsigned$2d$hyper$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/@stellar/js-xdr/src/unsigned-hyper.js [app-ssr] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$stellar$2f$js$2d$xdr$2f$src$2f$float$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/@stellar/js-xdr/src/float.js [app-ssr] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$stellar$2f$js$2d$xdr$2f$src$2f$double$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/@stellar/js-xdr/src/double.js [app-ssr] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$stellar$2f$js$2d$xdr$2f$src$2f$quadruple$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/@stellar/js-xdr/src/quadruple.js [app-ssr] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$stellar$2f$js$2d$xdr$2f$src$2f$string$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/@stellar/js-xdr/src/string.js [app-ssr] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$stellar$2f$js$2d$xdr$2f$src$2f$opaque$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/@stellar/js-xdr/src/opaque.js [app-ssr] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$stellar$2f$js$2d$xdr$2f$src$2f$var$2d$opaque$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/@stellar/js-xdr/src/var-opaque.js [app-ssr] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$stellar$2f$js$2d$xdr$2f$src$2f$reference$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/@stellar/js-xdr/src/reference.js [app-ssr] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$stellar$2f$js$2d$xdr$2f$src$2f$errors$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/@stellar/js-xdr/src/errors.js [app-ssr] (ecmascript)");
;
;
;
;
class SimpleReference extends __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$stellar$2f$js$2d$xdr$2f$src$2f$reference$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["Reference"] {
    constructor(name){
        super();
        this.name = name;
    }
    resolve(context) {
        const defn = context.definitions[this.name];
        return defn.resolve(context);
    }
}
class ArrayReference extends __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$stellar$2f$js$2d$xdr$2f$src$2f$reference$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["Reference"] {
    constructor(childReference, length, variable = false){
        super();
        this.childReference = childReference;
        this.length = length;
        this.variable = variable;
    }
    resolve(context) {
        let resolvedChild = this.childReference;
        let length = this.length;
        if (resolvedChild instanceof __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$stellar$2f$js$2d$xdr$2f$src$2f$reference$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["Reference"]) {
            resolvedChild = resolvedChild.resolve(context);
        }
        if (length instanceof __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$stellar$2f$js$2d$xdr$2f$src$2f$reference$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["Reference"]) {
            length = length.resolve(context);
        }
        if (this.variable) {
            return new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$stellar$2f$js$2d$xdr$2f$src$2f$var$2d$array$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["VarArray"](resolvedChild, length);
        }
        return new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$stellar$2f$js$2d$xdr$2f$src$2f$array$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["Array"](resolvedChild, length);
    }
}
class OptionReference extends __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$stellar$2f$js$2d$xdr$2f$src$2f$reference$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["Reference"] {
    constructor(childReference){
        super();
        this.childReference = childReference;
        this.name = childReference.name;
    }
    resolve(context) {
        let resolvedChild = this.childReference;
        if (resolvedChild instanceof __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$stellar$2f$js$2d$xdr$2f$src$2f$reference$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["Reference"]) {
            resolvedChild = resolvedChild.resolve(context);
        }
        return new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$stellar$2f$js$2d$xdr$2f$src$2f$option$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["Option"](resolvedChild);
    }
}
class SizedReference extends __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$stellar$2f$js$2d$xdr$2f$src$2f$reference$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["Reference"] {
    constructor(sizedType, length){
        super();
        this.sizedType = sizedType;
        this.length = length;
    }
    resolve(context) {
        let length = this.length;
        if (length instanceof __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$stellar$2f$js$2d$xdr$2f$src$2f$reference$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["Reference"]) {
            length = length.resolve(context);
        }
        return new this.sizedType(length);
    }
}
class Definition {
    constructor(constructor, name, cfg){
        this.constructor = constructor;
        this.name = name;
        this.config = cfg;
    }
    // resolve calls the constructor of this definition with the provided context
    // and this definitions config values.  The definitions constructor should
    // populate the final type on `context.results`, and may refer to other
    // definitions through `context.definitions`
    resolve(context) {
        if (this.name in context.results) {
            return context.results[this.name];
        }
        return this.constructor(context, this.name, this.config);
    }
}
// let the reference resolution system do its thing
// the "constructor" for a typedef just returns the resolved value
function createTypedef(context, typeName, value) {
    if (value instanceof __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$stellar$2f$js$2d$xdr$2f$src$2f$reference$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["Reference"]) {
        value = value.resolve(context);
    }
    context.results[typeName] = value;
    return value;
}
function createConst(context, name, value) {
    context.results[name] = value;
    return value;
}
class TypeBuilder {
    constructor(destination){
        this._destination = destination;
        this._definitions = {};
    }
    enum(name, members) {
        const result = new Definition(__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$stellar$2f$js$2d$xdr$2f$src$2f$enum$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["Enum"].create, name, members);
        this.define(name, result);
    }
    struct(name, members) {
        const result = new Definition(__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$stellar$2f$js$2d$xdr$2f$src$2f$struct$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["Struct"].create, name, members);
        this.define(name, result);
    }
    union(name, cfg) {
        const result = new Definition(__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$stellar$2f$js$2d$xdr$2f$src$2f$union$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["Union"].create, name, cfg);
        this.define(name, result);
    }
    typedef(name, cfg) {
        const result = new Definition(createTypedef, name, cfg);
        this.define(name, result);
    }
    const(name, cfg) {
        const result = new Definition(createConst, name, cfg);
        this.define(name, result);
    }
    void() {
        return __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$stellar$2f$js$2d$xdr$2f$src$2f$void$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["Void"];
    }
    bool() {
        return __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$stellar$2f$js$2d$xdr$2f$src$2f$bool$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["Bool"];
    }
    int() {
        return __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$stellar$2f$js$2d$xdr$2f$src$2f$int$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["Int"];
    }
    hyper() {
        return __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$stellar$2f$js$2d$xdr$2f$src$2f$hyper$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["Hyper"];
    }
    uint() {
        return __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$stellar$2f$js$2d$xdr$2f$src$2f$unsigned$2d$int$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["UnsignedInt"];
    }
    uhyper() {
        return __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$stellar$2f$js$2d$xdr$2f$src$2f$unsigned$2d$hyper$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["UnsignedHyper"];
    }
    float() {
        return __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$stellar$2f$js$2d$xdr$2f$src$2f$float$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["Float"];
    }
    double() {
        return __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$stellar$2f$js$2d$xdr$2f$src$2f$double$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["Double"];
    }
    quadruple() {
        return __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$stellar$2f$js$2d$xdr$2f$src$2f$quadruple$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["Quadruple"];
    }
    string(length) {
        return new SizedReference(__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$stellar$2f$js$2d$xdr$2f$src$2f$string$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["String"], length);
    }
    opaque(length) {
        return new SizedReference(__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$stellar$2f$js$2d$xdr$2f$src$2f$opaque$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["Opaque"], length);
    }
    varOpaque(length) {
        return new SizedReference(__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$stellar$2f$js$2d$xdr$2f$src$2f$var$2d$opaque$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["VarOpaque"], length);
    }
    array(childType, length) {
        return new ArrayReference(childType, length);
    }
    varArray(childType, maxLength) {
        return new ArrayReference(childType, maxLength, true);
    }
    option(childType) {
        return new OptionReference(childType);
    }
    define(name, definition) {
        if (this._destination[name] === undefined) {
            this._definitions[name] = definition;
        } else {
            throw new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$stellar$2f$js$2d$xdr$2f$src$2f$errors$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["XdrDefinitionError"](`${name} is already defined`);
        }
    }
    lookup(name) {
        return new SimpleReference(name);
    }
    resolve() {
        for (const defn of Object.values(this._definitions)){
            defn.resolve({
                definitions: this._definitions,
                results: this._destination
            });
        }
    }
}
function config(fn, types = {}) {
    if (fn) {
        const builder = new TypeBuilder(types);
        fn(builder);
        builder.resolve();
    }
    return types;
}
}),
"[project]/node_modules/@stellar/js-xdr/src/index.js [app-ssr] (ecmascript) <locals>", ((__turbopack_context__) => {
"use strict";

__turbopack_context__.s([]);
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$stellar$2f$js$2d$xdr$2f$src$2f$types$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__$3c$locals$3e$__ = __turbopack_context__.i("[project]/node_modules/@stellar/js-xdr/src/types.js [app-ssr] (ecmascript) <locals>");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$stellar$2f$js$2d$xdr$2f$src$2f$config$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__$3c$locals$3e$__ = __turbopack_context__.i("[project]/node_modules/@stellar/js-xdr/src/config.js [app-ssr] (ecmascript) <locals>");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$stellar$2f$js$2d$xdr$2f$src$2f$serialization$2f$xdr$2d$reader$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/@stellar/js-xdr/src/serialization/xdr-reader.js [app-ssr] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$stellar$2f$js$2d$xdr$2f$src$2f$serialization$2f$xdr$2d$writer$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/@stellar/js-xdr/src/serialization/xdr-writer.js [app-ssr] (ecmascript)");
;
;
;
;
}),
"[project]/node_modules/@stellar/js-xdr/src/types.js [app-ssr] (ecmascript)", ((__turbopack_context__) => {
"use strict";

__turbopack_context__.s([
    "Array",
    ()=>__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$stellar$2f$js$2d$xdr$2f$src$2f$array$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["Array"],
    "Bool",
    ()=>__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$stellar$2f$js$2d$xdr$2f$src$2f$bool$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["Bool"],
    "Double",
    ()=>__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$stellar$2f$js$2d$xdr$2f$src$2f$double$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["Double"],
    "Enum",
    ()=>__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$stellar$2f$js$2d$xdr$2f$src$2f$enum$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["Enum"],
    "Float",
    ()=>__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$stellar$2f$js$2d$xdr$2f$src$2f$float$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["Float"],
    "Hyper",
    ()=>__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$stellar$2f$js$2d$xdr$2f$src$2f$hyper$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["Hyper"],
    "Int",
    ()=>__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$stellar$2f$js$2d$xdr$2f$src$2f$int$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["Int"],
    "LargeInt",
    ()=>__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$stellar$2f$js$2d$xdr$2f$src$2f$large$2d$int$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["LargeInt"],
    "Opaque",
    ()=>__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$stellar$2f$js$2d$xdr$2f$src$2f$opaque$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["Opaque"],
    "Option",
    ()=>__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$stellar$2f$js$2d$xdr$2f$src$2f$option$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["Option"],
    "Quadruple",
    ()=>__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$stellar$2f$js$2d$xdr$2f$src$2f$quadruple$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["Quadruple"],
    "String",
    ()=>__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$stellar$2f$js$2d$xdr$2f$src$2f$string$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["String"],
    "Struct",
    ()=>__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$stellar$2f$js$2d$xdr$2f$src$2f$struct$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["Struct"],
    "Union",
    ()=>__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$stellar$2f$js$2d$xdr$2f$src$2f$union$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["Union"],
    "UnsignedHyper",
    ()=>__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$stellar$2f$js$2d$xdr$2f$src$2f$unsigned$2d$hyper$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["UnsignedHyper"],
    "UnsignedInt",
    ()=>__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$stellar$2f$js$2d$xdr$2f$src$2f$unsigned$2d$int$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["UnsignedInt"],
    "VarArray",
    ()=>__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$stellar$2f$js$2d$xdr$2f$src$2f$var$2d$array$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["VarArray"],
    "VarOpaque",
    ()=>__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$stellar$2f$js$2d$xdr$2f$src$2f$var$2d$opaque$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["VarOpaque"],
    "Void",
    ()=>__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$stellar$2f$js$2d$xdr$2f$src$2f$void$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["Void"]
]);
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$stellar$2f$js$2d$xdr$2f$src$2f$types$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__$3c$locals$3e$__ = __turbopack_context__.i("[project]/node_modules/@stellar/js-xdr/src/types.js [app-ssr] (ecmascript) <locals>");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$stellar$2f$js$2d$xdr$2f$src$2f$int$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/@stellar/js-xdr/src/int.js [app-ssr] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$stellar$2f$js$2d$xdr$2f$src$2f$hyper$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/@stellar/js-xdr/src/hyper.js [app-ssr] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$stellar$2f$js$2d$xdr$2f$src$2f$unsigned$2d$int$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/@stellar/js-xdr/src/unsigned-int.js [app-ssr] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$stellar$2f$js$2d$xdr$2f$src$2f$unsigned$2d$hyper$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/@stellar/js-xdr/src/unsigned-hyper.js [app-ssr] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$stellar$2f$js$2d$xdr$2f$src$2f$large$2d$int$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/@stellar/js-xdr/src/large-int.js [app-ssr] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$stellar$2f$js$2d$xdr$2f$src$2f$float$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/@stellar/js-xdr/src/float.js [app-ssr] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$stellar$2f$js$2d$xdr$2f$src$2f$double$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/@stellar/js-xdr/src/double.js [app-ssr] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$stellar$2f$js$2d$xdr$2f$src$2f$quadruple$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/@stellar/js-xdr/src/quadruple.js [app-ssr] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$stellar$2f$js$2d$xdr$2f$src$2f$bool$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/@stellar/js-xdr/src/bool.js [app-ssr] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$stellar$2f$js$2d$xdr$2f$src$2f$string$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/@stellar/js-xdr/src/string.js [app-ssr] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$stellar$2f$js$2d$xdr$2f$src$2f$opaque$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/@stellar/js-xdr/src/opaque.js [app-ssr] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$stellar$2f$js$2d$xdr$2f$src$2f$var$2d$opaque$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/@stellar/js-xdr/src/var-opaque.js [app-ssr] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$stellar$2f$js$2d$xdr$2f$src$2f$array$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/@stellar/js-xdr/src/array.js [app-ssr] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$stellar$2f$js$2d$xdr$2f$src$2f$var$2d$array$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/@stellar/js-xdr/src/var-array.js [app-ssr] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$stellar$2f$js$2d$xdr$2f$src$2f$option$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/@stellar/js-xdr/src/option.js [app-ssr] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$stellar$2f$js$2d$xdr$2f$src$2f$void$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/@stellar/js-xdr/src/void.js [app-ssr] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$stellar$2f$js$2d$xdr$2f$src$2f$enum$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/@stellar/js-xdr/src/enum.js [app-ssr] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$stellar$2f$js$2d$xdr$2f$src$2f$struct$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/@stellar/js-xdr/src/struct.js [app-ssr] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$stellar$2f$js$2d$xdr$2f$src$2f$union$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/@stellar/js-xdr/src/union.js [app-ssr] (ecmascript)");
}),
"[project]/node_modules/@stellar/js-xdr/src/config.js [app-ssr] (ecmascript)", ((__turbopack_context__) => {
"use strict";

__turbopack_context__.s([
    "Reference",
    ()=>__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$stellar$2f$js$2d$xdr$2f$src$2f$reference$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["Reference"],
    "config",
    ()=>__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$stellar$2f$js$2d$xdr$2f$src$2f$config$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__$3c$locals$3e$__["config"]
]);
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$stellar$2f$js$2d$xdr$2f$src$2f$config$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__$3c$locals$3e$__ = __turbopack_context__.i("[project]/node_modules/@stellar/js-xdr/src/config.js [app-ssr] (ecmascript) <locals>");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$stellar$2f$js$2d$xdr$2f$src$2f$reference$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/@stellar/js-xdr/src/reference.js [app-ssr] (ecmascript)");
}),
"[project]/node_modules/@stellar/js-xdr/src/index.js [app-ssr] (ecmascript)", ((__turbopack_context__) => {
"use strict";

__turbopack_context__.s([
    "Array",
    ()=>__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$stellar$2f$js$2d$xdr$2f$src$2f$types$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["Array"],
    "Bool",
    ()=>__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$stellar$2f$js$2d$xdr$2f$src$2f$types$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["Bool"],
    "Double",
    ()=>__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$stellar$2f$js$2d$xdr$2f$src$2f$types$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["Double"],
    "Enum",
    ()=>__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$stellar$2f$js$2d$xdr$2f$src$2f$types$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["Enum"],
    "Float",
    ()=>__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$stellar$2f$js$2d$xdr$2f$src$2f$types$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["Float"],
    "Hyper",
    ()=>__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$stellar$2f$js$2d$xdr$2f$src$2f$types$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["Hyper"],
    "Int",
    ()=>__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$stellar$2f$js$2d$xdr$2f$src$2f$types$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["Int"],
    "LargeInt",
    ()=>__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$stellar$2f$js$2d$xdr$2f$src$2f$types$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["LargeInt"],
    "Opaque",
    ()=>__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$stellar$2f$js$2d$xdr$2f$src$2f$types$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["Opaque"],
    "Option",
    ()=>__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$stellar$2f$js$2d$xdr$2f$src$2f$types$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["Option"],
    "Quadruple",
    ()=>__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$stellar$2f$js$2d$xdr$2f$src$2f$types$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["Quadruple"],
    "Reference",
    ()=>__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$stellar$2f$js$2d$xdr$2f$src$2f$config$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["Reference"],
    "String",
    ()=>__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$stellar$2f$js$2d$xdr$2f$src$2f$types$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["String"],
    "Struct",
    ()=>__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$stellar$2f$js$2d$xdr$2f$src$2f$types$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["Struct"],
    "Union",
    ()=>__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$stellar$2f$js$2d$xdr$2f$src$2f$types$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["Union"],
    "UnsignedHyper",
    ()=>__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$stellar$2f$js$2d$xdr$2f$src$2f$types$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["UnsignedHyper"],
    "UnsignedInt",
    ()=>__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$stellar$2f$js$2d$xdr$2f$src$2f$types$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["UnsignedInt"],
    "VarArray",
    ()=>__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$stellar$2f$js$2d$xdr$2f$src$2f$types$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["VarArray"],
    "VarOpaque",
    ()=>__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$stellar$2f$js$2d$xdr$2f$src$2f$types$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["VarOpaque"],
    "Void",
    ()=>__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$stellar$2f$js$2d$xdr$2f$src$2f$types$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["Void"],
    "XdrReader",
    ()=>__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$stellar$2f$js$2d$xdr$2f$src$2f$serialization$2f$xdr$2d$reader$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["XdrReader"],
    "XdrWriter",
    ()=>__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$stellar$2f$js$2d$xdr$2f$src$2f$serialization$2f$xdr$2d$writer$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["XdrWriter"],
    "config",
    ()=>__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$stellar$2f$js$2d$xdr$2f$src$2f$config$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["config"]
]);
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$stellar$2f$js$2d$xdr$2f$src$2f$index$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__$3c$locals$3e$__ = __turbopack_context__.i("[project]/node_modules/@stellar/js-xdr/src/index.js [app-ssr] (ecmascript) <locals>");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$stellar$2f$js$2d$xdr$2f$src$2f$types$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/@stellar/js-xdr/src/types.js [app-ssr] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$stellar$2f$js$2d$xdr$2f$src$2f$config$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/@stellar/js-xdr/src/config.js [app-ssr] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$stellar$2f$js$2d$xdr$2f$src$2f$serialization$2f$xdr$2d$reader$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/@stellar/js-xdr/src/serialization/xdr-reader.js [app-ssr] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$stellar$2f$js$2d$xdr$2f$src$2f$serialization$2f$xdr$2d$writer$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/@stellar/js-xdr/src/serialization/xdr-writer.js [app-ssr] (ecmascript)");
}),
"[project]/node_modules/safe-buffer/index.js [app-ssr] (ecmascript)", ((__turbopack_context__, module, exports) => {

/*! safe-buffer. MIT License. Feross Aboukhadijeh <https://feross.org/opensource> */ /* eslint-disable node/no-deprecated-api */ var buffer = __turbopack_context__.r("[externals]/buffer [external] (buffer, cjs)");
var Buffer = buffer.Buffer;
// alternative to using Object.keys for old browsers
function copyProps(src, dst) {
    for(var key in src){
        dst[key] = src[key];
    }
}
if (Buffer.from && Buffer.alloc && Buffer.allocUnsafe && Buffer.allocUnsafeSlow) {
    module.exports = buffer;
} else {
    // Copy properties from require('buffer')
    copyProps(buffer, exports);
    exports.Buffer = SafeBuffer;
}
function SafeBuffer(arg, encodingOrOffset, length) {
    return Buffer(arg, encodingOrOffset, length);
}
SafeBuffer.prototype = Object.create(Buffer.prototype);
// Copy static methods from Buffer
copyProps(Buffer, SafeBuffer);
SafeBuffer.from = function(arg, encodingOrOffset, length) {
    if (typeof arg === 'number') {
        throw new TypeError('Argument must not be a number');
    }
    return Buffer(arg, encodingOrOffset, length);
};
SafeBuffer.alloc = function(size, fill, encoding) {
    if (typeof size !== 'number') {
        throw new TypeError('Argument must be a number');
    }
    var buf = Buffer(size);
    if (fill !== undefined) {
        if (typeof encoding === 'string') {
            buf.fill(fill, encoding);
        } else {
            buf.fill(fill);
        }
    } else {
        buf.fill(0);
    }
    return buf;
};
SafeBuffer.allocUnsafe = function(size) {
    if (typeof size !== 'number') {
        throw new TypeError('Argument must be a number');
    }
    return Buffer(size);
};
SafeBuffer.allocUnsafeSlow = function(size) {
    if (typeof size !== 'number') {
        throw new TypeError('Argument must be a number');
    }
    return buffer.SlowBuffer(size);
};
}),
"[project]/node_modules/isarray/index.js [app-ssr] (ecmascript)", ((__turbopack_context__, module, exports) => {

var toString = {}.toString;
module.exports = Array.isArray || function(arr) {
    return toString.call(arr) == '[object Array]';
};
}),
"[project]/node_modules/call-bound/index.js [app-ssr] (ecmascript)", ((__turbopack_context__, module, exports) => {
"use strict";

var GetIntrinsic = __turbopack_context__.r("[project]/node_modules/get-intrinsic/index.js [app-ssr] (ecmascript)");
var callBindBasic = __turbopack_context__.r("[project]/node_modules/call-bind-apply-helpers/index.js [app-ssr] (ecmascript)");
/** @type {(thisArg: string, searchString: string, position?: number) => number} */ var $indexOf = callBindBasic([
    GetIntrinsic('%String.prototype.indexOf%')
]);
/** @type {import('.')} */ module.exports = function callBoundIntrinsic(name, allowMissing) {
    /* eslint no-extra-parens: 0 */ var intrinsic = GetIntrinsic(name, !!allowMissing);
    if (typeof intrinsic === 'function' && $indexOf(name, '.prototype.') > -1) {
        return callBindBasic([
            intrinsic
        ]);
    }
    return intrinsic;
};
}),
"[project]/node_modules/is-callable/index.js [app-ssr] (ecmascript)", ((__turbopack_context__, module, exports) => {
"use strict";

var fnToStr = Function.prototype.toString;
var reflectApply = typeof Reflect === 'object' && Reflect !== null && Reflect.apply;
var badArrayLike;
var isCallableMarker;
if (typeof reflectApply === 'function' && typeof Object.defineProperty === 'function') {
    try {
        badArrayLike = Object.defineProperty({}, 'length', {
            get: function() {
                throw isCallableMarker;
            }
        });
        isCallableMarker = {};
        // eslint-disable-next-line no-throw-literal
        reflectApply(function() {
            throw 42;
        }, null, badArrayLike);
    } catch (_) {
        if (_ !== isCallableMarker) {
            reflectApply = null;
        }
    }
} else {
    reflectApply = null;
}
var constructorRegex = /^\s*class\b/;
var isES6ClassFn = function isES6ClassFunction(value) {
    try {
        var fnStr = fnToStr.call(value);
        return constructorRegex.test(fnStr);
    } catch (e) {
        return false; // not a function
    }
};
var tryFunctionObject = function tryFunctionToStr(value) {
    try {
        if (isES6ClassFn(value)) {
            return false;
        }
        fnToStr.call(value);
        return true;
    } catch (e) {
        return false;
    }
};
var toStr = Object.prototype.toString;
var objectClass = '[object Object]';
var fnClass = '[object Function]';
var genClass = '[object GeneratorFunction]';
var ddaClass = '[object HTMLAllCollection]'; // IE 11
var ddaClass2 = '[object HTML document.all class]';
var ddaClass3 = '[object HTMLCollection]'; // IE 9-10
var hasToStringTag = typeof Symbol === 'function' && !!Symbol.toStringTag; // better: use `has-tostringtag`
var isIE68 = !(0 in [
    , 
]); // eslint-disable-line no-sparse-arrays, comma-spacing
var isDDA = function isDocumentDotAll() {
    return false;
};
if (typeof document === 'object') {
    // Firefox 3 canonicalizes DDA to undefined when it's not accessed directly
    var all = document.all;
    if (toStr.call(all) === toStr.call(document.all)) {
        isDDA = function isDocumentDotAll(value) {
            /* globals document: false */ // in IE 6-8, typeof document.all is "object" and it's truthy
            if ((isIE68 || !value) && (typeof value === 'undefined' || typeof value === 'object')) {
                try {
                    var str = toStr.call(value);
                    return (str === ddaClass || str === ddaClass2 || str === ddaClass3 // opera 12.16
                     || str === objectClass // IE 6-8
                    ) && value('') == null; // eslint-disable-line eqeqeq
                } catch (e) {}
            }
            return false;
        };
    }
}
module.exports = reflectApply ? function isCallable(value) {
    if (isDDA(value)) {
        return true;
    }
    if (!value) {
        return false;
    }
    if (typeof value !== 'function' && typeof value !== 'object') {
        return false;
    }
    try {
        reflectApply(value, null, badArrayLike);
    } catch (e) {
        if (e !== isCallableMarker) {
            return false;
        }
    }
    return !isES6ClassFn(value) && tryFunctionObject(value);
} : function isCallable(value) {
    if (isDDA(value)) {
        return true;
    }
    if (!value) {
        return false;
    }
    if (typeof value !== 'function' && typeof value !== 'object') {
        return false;
    }
    if (hasToStringTag) {
        return tryFunctionObject(value);
    }
    if (isES6ClassFn(value)) {
        return false;
    }
    var strClass = toStr.call(value);
    if (strClass !== fnClass && strClass !== genClass && !/^\[object HTML/.test(strClass)) {
        return false;
    }
    return tryFunctionObject(value);
};
}),
"[project]/node_modules/for-each/index.js [app-ssr] (ecmascript)", ((__turbopack_context__, module, exports) => {
"use strict";

var isCallable = __turbopack_context__.r("[project]/node_modules/is-callable/index.js [app-ssr] (ecmascript)");
var toStr = Object.prototype.toString;
var hasOwnProperty = Object.prototype.hasOwnProperty;
/** @type {<This, A extends readonly unknown[]>(arr: A, iterator: (this: This | void, value: A[number], index: number, arr: A) => void, receiver: This | undefined) => void} */ var forEachArray = function forEachArray(array, iterator, receiver) {
    for(var i = 0, len = array.length; i < len; i++){
        if (hasOwnProperty.call(array, i)) {
            if (receiver == null) {
                iterator(array[i], i, array);
            } else {
                iterator.call(receiver, array[i], i, array);
            }
        }
    }
};
/** @type {<This, S extends string>(string: S, iterator: (this: This | void, value: S[number], index: number, string: S) => void, receiver: This | undefined) => void} */ var forEachString = function forEachString(string, iterator, receiver) {
    for(var i = 0, len = string.length; i < len; i++){
        // no such thing as a sparse string.
        if (receiver == null) {
            iterator(string.charAt(i), i, string);
        } else {
            iterator.call(receiver, string.charAt(i), i, string);
        }
    }
};
/** @type {<This, O>(obj: O, iterator: (this: This | void, value: O[keyof O], index: keyof O, obj: O) => void, receiver: This | undefined) => void} */ var forEachObject = function forEachObject(object, iterator, receiver) {
    for(var k in object){
        if (hasOwnProperty.call(object, k)) {
            if (receiver == null) {
                iterator(object[k], k, object);
            } else {
                iterator.call(receiver, object[k], k, object);
            }
        }
    }
};
/** @type {(x: unknown) => x is readonly unknown[]} */ function isArray(x) {
    return toStr.call(x) === '[object Array]';
}
/** @type {import('.')._internal} */ module.exports = function forEach(list, iterator, thisArg) {
    if (!isCallable(iterator)) {
        throw new TypeError('iterator must be a function');
    }
    var receiver;
    if (arguments.length >= 3) {
        receiver = thisArg;
    }
    if (isArray(list)) {
        forEachArray(list, iterator, receiver);
    } else if (typeof list === 'string') {
        forEachString(list, iterator, receiver);
    } else {
        forEachObject(list, iterator, receiver);
    }
};
}),
"[project]/node_modules/possible-typed-array-names/index.js [app-ssr] (ecmascript)", ((__turbopack_context__, module, exports) => {
"use strict";

/** @type {import('.')} */ module.exports = [
    'Float16Array',
    'Float32Array',
    'Float64Array',
    'Int8Array',
    'Int16Array',
    'Int32Array',
    'Uint8Array',
    'Uint8ClampedArray',
    'Uint16Array',
    'Uint32Array',
    'BigInt64Array',
    'BigUint64Array'
];
}),
"[project]/node_modules/available-typed-arrays/index.js [app-ssr] (ecmascript)", ((__turbopack_context__, module, exports) => {
"use strict";

var possibleNames = __turbopack_context__.r("[project]/node_modules/possible-typed-array-names/index.js [app-ssr] (ecmascript)");
var g = typeof globalThis === 'undefined' ? /*TURBOPACK member replacement*/ __turbopack_context__.g : globalThis;
/** @type {import('.')} */ module.exports = function availableTypedArrays() {
    var /** @type {ReturnType<typeof availableTypedArrays>} */ out = [];
    for(var i = 0; i < possibleNames.length; i++){
        if (typeof g[possibleNames[i]] === 'function') {
            // @ts-expect-error
            out[out.length] = possibleNames[i];
        }
    }
    return out;
};
}),
"[project]/node_modules/define-data-property/index.js [app-ssr] (ecmascript)", ((__turbopack_context__, module, exports) => {
"use strict";

var $defineProperty = __turbopack_context__.r("[project]/node_modules/es-define-property/index.js [app-ssr] (ecmascript)");
var $SyntaxError = __turbopack_context__.r("[project]/node_modules/es-errors/syntax.js [app-ssr] (ecmascript)");
var $TypeError = __turbopack_context__.r("[project]/node_modules/es-errors/type.js [app-ssr] (ecmascript)");
var gopd = __turbopack_context__.r("[project]/node_modules/gopd/index.js [app-ssr] (ecmascript)");
/** @type {import('.')} */ module.exports = function defineDataProperty(obj, property, value) {
    if (!obj || typeof obj !== 'object' && typeof obj !== 'function') {
        throw new $TypeError('`obj` must be an object or a function`');
    }
    if (typeof property !== 'string' && typeof property !== 'symbol') {
        throw new $TypeError('`property` must be a string or a symbol`');
    }
    if (arguments.length > 3 && typeof arguments[3] !== 'boolean' && arguments[3] !== null) {
        throw new $TypeError('`nonEnumerable`, if provided, must be a boolean or null');
    }
    if (arguments.length > 4 && typeof arguments[4] !== 'boolean' && arguments[4] !== null) {
        throw new $TypeError('`nonWritable`, if provided, must be a boolean or null');
    }
    if (arguments.length > 5 && typeof arguments[5] !== 'boolean' && arguments[5] !== null) {
        throw new $TypeError('`nonConfigurable`, if provided, must be a boolean or null');
    }
    if (arguments.length > 6 && typeof arguments[6] !== 'boolean') {
        throw new $TypeError('`loose`, if provided, must be a boolean');
    }
    var nonEnumerable = arguments.length > 3 ? arguments[3] : null;
    var nonWritable = arguments.length > 4 ? arguments[4] : null;
    var nonConfigurable = arguments.length > 5 ? arguments[5] : null;
    var loose = arguments.length > 6 ? arguments[6] : false;
    /* @type {false | TypedPropertyDescriptor<unknown>} */ var desc = !!gopd && gopd(obj, property);
    if ($defineProperty) {
        $defineProperty(obj, property, {
            configurable: nonConfigurable === null && desc ? desc.configurable : !nonConfigurable,
            enumerable: nonEnumerable === null && desc ? desc.enumerable : !nonEnumerable,
            value: value,
            writable: nonWritable === null && desc ? desc.writable : !nonWritable
        });
    } else if (loose || !nonEnumerable && !nonWritable && !nonConfigurable) {
        // must fall back to [[Set]], and was not explicitly asked to make non-enumerable, non-writable, or non-configurable
        obj[property] = value; // eslint-disable-line no-param-reassign
    } else {
        throw new $SyntaxError('This environment does not support defining a property as non-configurable, non-writable, or non-enumerable.');
    }
};
}),
"[project]/node_modules/has-property-descriptors/index.js [app-ssr] (ecmascript)", ((__turbopack_context__, module, exports) => {
"use strict";

var $defineProperty = __turbopack_context__.r("[project]/node_modules/es-define-property/index.js [app-ssr] (ecmascript)");
var hasPropertyDescriptors = function hasPropertyDescriptors() {
    return !!$defineProperty;
};
hasPropertyDescriptors.hasArrayLengthDefineBug = function hasArrayLengthDefineBug() {
    // node v0.6 has a bug where array lengths can be Set but not Defined
    if (!$defineProperty) {
        return null;
    }
    try {
        return $defineProperty([], 'length', {
            value: 1
        }).length !== 1;
    } catch (e) {
        // In Firefox 4-22, defining length on an array throws an exception.
        return true;
    }
};
module.exports = hasPropertyDescriptors;
}),
"[project]/node_modules/set-function-length/index.js [app-ssr] (ecmascript)", ((__turbopack_context__, module, exports) => {
"use strict";

var GetIntrinsic = __turbopack_context__.r("[project]/node_modules/get-intrinsic/index.js [app-ssr] (ecmascript)");
var define = __turbopack_context__.r("[project]/node_modules/define-data-property/index.js [app-ssr] (ecmascript)");
var hasDescriptors = __turbopack_context__.r("[project]/node_modules/has-property-descriptors/index.js [app-ssr] (ecmascript)")();
var gOPD = __turbopack_context__.r("[project]/node_modules/gopd/index.js [app-ssr] (ecmascript)");
var $TypeError = __turbopack_context__.r("[project]/node_modules/es-errors/type.js [app-ssr] (ecmascript)");
var $floor = GetIntrinsic('%Math.floor%');
/** @type {import('.')} */ module.exports = function setFunctionLength(fn, length) {
    if (typeof fn !== 'function') {
        throw new $TypeError('`fn` is not a function');
    }
    if (typeof length !== 'number' || length < 0 || length > 0xFFFFFFFF || $floor(length) !== length) {
        throw new $TypeError('`length` must be a positive 32-bit integer');
    }
    var loose = arguments.length > 2 && !!arguments[2];
    var functionLengthIsConfigurable = true;
    var functionLengthIsWritable = true;
    if ('length' in fn && gOPD) {
        var desc = gOPD(fn, 'length');
        if (desc && !desc.configurable) {
            functionLengthIsConfigurable = false;
        }
        if (desc && !desc.writable) {
            functionLengthIsWritable = false;
        }
    }
    if (functionLengthIsConfigurable || functionLengthIsWritable || !loose) {
        if (hasDescriptors) {
            define(fn, 'length', length, true, true);
        } else {
            define(fn, 'length', length);
        }
    }
    return fn;
};
}),
"[project]/node_modules/call-bind/index.js [app-ssr] (ecmascript)", ((__turbopack_context__, module, exports) => {
"use strict";

var setFunctionLength = __turbopack_context__.r("[project]/node_modules/set-function-length/index.js [app-ssr] (ecmascript)");
var $defineProperty = __turbopack_context__.r("[project]/node_modules/es-define-property/index.js [app-ssr] (ecmascript)");
var callBindBasic = __turbopack_context__.r("[project]/node_modules/call-bind-apply-helpers/index.js [app-ssr] (ecmascript)");
var applyBind = __turbopack_context__.r("[project]/node_modules/call-bind-apply-helpers/applyBind.js [app-ssr] (ecmascript)");
module.exports = function callBind(originalFunction) {
    var func = callBindBasic(arguments);
    var adjustedLength = originalFunction.length - (arguments.length - 1);
    return setFunctionLength(func, 1 + (adjustedLength > 0 ? adjustedLength : 0), true);
};
if ($defineProperty) {
    $defineProperty(module.exports, 'apply', {
        value: applyBind
    });
} else {
    module.exports.apply = applyBind;
}
}),
"[project]/node_modules/which-typed-array/index.js [app-ssr] (ecmascript)", ((__turbopack_context__, module, exports) => {
"use strict";

var forEach = __turbopack_context__.r("[project]/node_modules/for-each/index.js [app-ssr] (ecmascript)");
var availableTypedArrays = __turbopack_context__.r("[project]/node_modules/available-typed-arrays/index.js [app-ssr] (ecmascript)");
var callBind = __turbopack_context__.r("[project]/node_modules/call-bind/index.js [app-ssr] (ecmascript)");
var callBound = __turbopack_context__.r("[project]/node_modules/call-bound/index.js [app-ssr] (ecmascript)");
var gOPD = __turbopack_context__.r("[project]/node_modules/gopd/index.js [app-ssr] (ecmascript)");
var getProto = __turbopack_context__.r("[project]/node_modules/get-proto/index.js [app-ssr] (ecmascript)");
var $toString = callBound('Object.prototype.toString');
var hasToStringTag = __turbopack_context__.r("[project]/node_modules/has-tostringtag/shams.js [app-ssr] (ecmascript)")();
var g = typeof globalThis === 'undefined' ? /*TURBOPACK member replacement*/ __turbopack_context__.g : globalThis;
var typedArrays = availableTypedArrays();
var $slice = callBound('String.prototype.slice');
/** @type {<T = unknown>(array: readonly T[], value: unknown) => number} */ var $indexOf = callBound('Array.prototype.indexOf', true) || function indexOf(array, value) {
    for(var i = 0; i < array.length; i += 1){
        if (array[i] === value) {
            return i;
        }
    }
    return -1;
};
/** @typedef {import('./types').Getter} Getter */ /** @type {import('./types').Cache} */ var cache = {
    __proto__: null
};
if (hasToStringTag && gOPD && getProto) {
    forEach(typedArrays, function(typedArray) {
        var arr = new g[typedArray]();
        if (Symbol.toStringTag in arr && getProto) {
            var proto = getProto(arr);
            // @ts-expect-error TS won't narrow inside a closure
            var descriptor = gOPD(proto, Symbol.toStringTag);
            if (!descriptor && proto) {
                var superProto = getProto(proto);
                // @ts-expect-error TS won't narrow inside a closure
                descriptor = gOPD(superProto, Symbol.toStringTag);
            }
            // @ts-expect-error TODO: fix
            cache['$' + typedArray] = callBind(descriptor.get);
        }
    });
} else {
    forEach(typedArrays, function(typedArray) {
        var arr = new g[typedArray]();
        var fn = arr.slice || arr.set;
        if (fn) {
            cache['$' + typedArray] = // @ts-expect-error TODO FIXME
            callBind(fn);
        }
    });
}
/** @type {(value: object) => false | import('.').TypedArrayName} */ var tryTypedArrays = function tryAllTypedArrays(value) {
    /** @type {ReturnType<typeof tryAllTypedArrays>} */ var found = false;
    forEach(cache, /** @type {(getter: Getter, name: `\$${import('.').TypedArrayName}`) => void} */ function(getter, typedArray) {
        if (!found) {
            try {
                // @ts-expect-error a throw is fine here
                if ('$' + getter(value) === typedArray) {
                    found = $slice(typedArray, 1);
                }
            } catch (e) {}
        }
    });
    return found;
};
/** @type {(value: object) => false | import('.').TypedArrayName} */ var trySlices = function tryAllSlices(value) {
    /** @type {ReturnType<typeof tryAllSlices>} */ var found = false;
    forEach(cache, /** @type {(getter: Getter, name: `\$${import('.').TypedArrayName}`) => void} */ function(getter, name) {
        if (!found) {
            try {
                // @ts-expect-error a throw is fine here
                getter(value);
                found = $slice(name, 1);
            } catch (e) {}
        }
    });
    return found;
};
/** @type {import('.')} */ module.exports = function whichTypedArray(value) {
    if (!value || typeof value !== 'object') {
        return false;
    }
    if (!hasToStringTag) {
        /** @type {string} */ var tag = $slice($toString(value), 8, -1);
        if ($indexOf(typedArrays, tag) > -1) {
            return tag;
        }
        if (tag !== 'Object') {
            return false;
        }
        // node < 0.6 hits here on real Typed Arrays
        return trySlices(value);
    }
    if (!gOPD) {
        return null;
    } // unknown engine
    return tryTypedArrays(value);
};
}),
"[project]/node_modules/is-typed-array/index.js [app-ssr] (ecmascript)", ((__turbopack_context__, module, exports) => {
"use strict";

var whichTypedArray = __turbopack_context__.r("[project]/node_modules/which-typed-array/index.js [app-ssr] (ecmascript)");
/** @type {import('.')} */ module.exports = function isTypedArray(value) {
    return !!whichTypedArray(value);
};
}),
"[project]/node_modules/typed-array-buffer/index.js [app-ssr] (ecmascript)", ((__turbopack_context__, module, exports) => {
"use strict";

var $TypeError = __turbopack_context__.r("[project]/node_modules/es-errors/type.js [app-ssr] (ecmascript)");
var callBound = __turbopack_context__.r("[project]/node_modules/call-bound/index.js [app-ssr] (ecmascript)");
/** @type {undefined | ((thisArg: import('.').TypedArray) => Buffer<ArrayBufferLike>)} */ var $typedArrayBuffer = callBound('TypedArray.prototype.buffer', true);
var isTypedArray = __turbopack_context__.r("[project]/node_modules/is-typed-array/index.js [app-ssr] (ecmascript)");
/** @type {import('.')} */ // node <= 0.10, < 0.11.4 has a nonconfigurable own property instead of a prototype getter
module.exports = $typedArrayBuffer || function typedArrayBuffer(x) {
    if (!isTypedArray(x)) {
        throw new $TypeError('Not a Typed Array');
    }
    return x.buffer;
};
}),
"[project]/node_modules/to-buffer/index.js [app-ssr] (ecmascript)", ((__turbopack_context__, module, exports) => {
"use strict";

var Buffer = __turbopack_context__.r("[project]/node_modules/safe-buffer/index.js [app-ssr] (ecmascript)").Buffer;
var isArray = __turbopack_context__.r("[project]/node_modules/isarray/index.js [app-ssr] (ecmascript)");
var typedArrayBuffer = __turbopack_context__.r("[project]/node_modules/typed-array-buffer/index.js [app-ssr] (ecmascript)");
var isView = ArrayBuffer.isView || function isView(obj) {
    try {
        typedArrayBuffer(obj);
        return true;
    } catch (e) {
        return false;
    }
};
var useUint8Array = typeof Uint8Array !== 'undefined';
var useArrayBuffer = typeof ArrayBuffer !== 'undefined' && typeof Uint8Array !== 'undefined';
var useFromArrayBuffer = useArrayBuffer && (Buffer.prototype instanceof Uint8Array || Buffer.TYPED_ARRAY_SUPPORT);
module.exports = function toBuffer(data, encoding) {
    if (Buffer.isBuffer(data)) {
        if (data.constructor && !('isBuffer' in data)) {
            // probably a SlowBuffer
            return Buffer.from(data);
        }
        return data;
    }
    if (typeof data === 'string') {
        return Buffer.from(data, encoding);
    }
    /*
	 * Wrap any TypedArray instances and DataViews
	 * Makes sense only on engines with full TypedArray support -- let Buffer detect that
	 */ if (useArrayBuffer && isView(data)) {
        // Bug in Node.js <6.3.1, which treats this as out-of-bounds
        if (data.byteLength === 0) {
            return Buffer.alloc(0);
        }
        // When Buffer is based on Uint8Array, we can just construct it from ArrayBuffer
        if (useFromArrayBuffer) {
            var res = Buffer.from(data.buffer, data.byteOffset, data.byteLength);
            /*
			 * Recheck result size, as offset/length doesn't work on Node.js <5.10
			 * We just go to Uint8Array case if this fails
			 */ if (res.byteLength === data.byteLength) {
                return res;
            }
        }
        // Convert to Uint8Array bytes and then to Buffer
        var uint8 = data instanceof Uint8Array ? data : new Uint8Array(data.buffer, data.byteOffset, data.byteLength);
        var result = Buffer.from(uint8);
        /*
		 * Let's recheck that conversion succeeded
		 * We have .length but not .byteLength when useFromArrayBuffer is false
		 */ if (result.length === data.byteLength) {
            return result;
        }
    }
    /*
	 * Uint8Array in engines where Buffer.from might not work with ArrayBuffer, just copy over
	 * Doesn't make sense with other TypedArray instances
	 */ if (useUint8Array && data instanceof Uint8Array) {
        return Buffer.from(data);
    }
    var isArr = isArray(data);
    if (isArr) {
        for(var i = 0; i < data.length; i += 1){
            var x = data[i];
            if (typeof x !== 'number' || x < 0 || x > 255 || ~~x !== x // NaN and integer check
            ) {
                throw new RangeError('Array items must be numbers in the range 0-255.');
            }
        }
    }
    /*
	 * Old Buffer polyfill on an engine that doesn't have TypedArray support
	 * Also, this is from a different Buffer polyfill implementation then we have, as instanceof check failed
	 * Convert to our current Buffer implementation
	 */ if (isArr || Buffer.isBuffer(data) && data.constructor && typeof data.constructor.isBuffer === 'function' && data.constructor.isBuffer(data)) {
        return Buffer.from(data);
    }
    throw new TypeError('The "data" argument must be a string, an Array, a Buffer, a Uint8Array, or a DataView.');
};
}),
"[project]/node_modules/sha.js/hash.js [app-ssr] (ecmascript)", ((__turbopack_context__, module, exports) => {
"use strict";

var Buffer = __turbopack_context__.r("[project]/node_modules/safe-buffer/index.js [app-ssr] (ecmascript)").Buffer;
var toBuffer = __turbopack_context__.r("[project]/node_modules/to-buffer/index.js [app-ssr] (ecmascript)");
// prototype class for hash functions
function Hash(blockSize, finalSize) {
    this._block = Buffer.alloc(blockSize);
    this._finalSize = finalSize;
    this._blockSize = blockSize;
    this._len = 0;
}
Hash.prototype.update = function(data, enc) {
    /* eslint no-param-reassign: 0 */ data = toBuffer(data, enc || 'utf8');
    var block = this._block;
    var blockSize = this._blockSize;
    var length = data.length;
    var accum = this._len;
    for(var offset = 0; offset < length;){
        var assigned = accum % blockSize;
        var remainder = Math.min(length - offset, blockSize - assigned);
        for(var i = 0; i < remainder; i++){
            block[assigned + i] = data[offset + i];
        }
        accum += remainder;
        offset += remainder;
        if (accum % blockSize === 0) {
            this._update(block);
        }
    }
    this._len += length;
    return this;
};
Hash.prototype.digest = function(enc) {
    var rem = this._len % this._blockSize;
    this._block[rem] = 0x80;
    /*
	 * zero (rem + 1) trailing bits, where (rem + 1) is the smallest
	 * non-negative solution to the equation (length + 1 + (rem + 1)) === finalSize mod blockSize
	 */ this._block.fill(0, rem + 1);
    if (rem >= this._finalSize) {
        this._update(this._block);
        this._block.fill(0);
    }
    var bits = this._len * 8;
    // uint32
    if (bits <= 0xffffffff) {
        this._block.writeUInt32BE(bits, this._blockSize - 4);
    // uint64
    } else {
        var lowBits = (bits & 0xffffffff) >>> 0;
        var highBits = (bits - lowBits) / 0x100000000;
        this._block.writeUInt32BE(highBits, this._blockSize - 8);
        this._block.writeUInt32BE(lowBits, this._blockSize - 4);
    }
    this._update(this._block);
    var hash = this._hash();
    return enc ? hash.toString(enc) : hash;
};
Hash.prototype._update = function() {
    throw new Error('_update must be implemented by subclass');
};
module.exports = Hash;
}),
"[project]/node_modules/sha.js/sha.js [app-ssr] (ecmascript)", ((__turbopack_context__, module, exports) => {
"use strict";

/*
 * A JavaScript implementation of the Secure Hash Algorithm, SHA-0, as defined
 * in FIPS PUB 180-1
 * This source code is derived from sha1.js of the same repository.
 * The difference between SHA-0 and SHA-1 is just a bitwise rotate left
 * operation was added.
 */ var inherits = __turbopack_context__.r("[project]/node_modules/inherits/inherits.js [app-ssr] (ecmascript)");
var Hash = __turbopack_context__.r("[project]/node_modules/sha.js/hash.js [app-ssr] (ecmascript)");
var Buffer = __turbopack_context__.r("[project]/node_modules/safe-buffer/index.js [app-ssr] (ecmascript)").Buffer;
var K = [
    0x5a827999,
    0x6ed9eba1,
    0x8f1bbcdc | 0,
    0xca62c1d6 | 0
];
var W = new Array(80);
function Sha() {
    this.init();
    this._w = W;
    Hash.call(this, 64, 56);
}
inherits(Sha, Hash);
Sha.prototype.init = function() {
    this._a = 0x67452301;
    this._b = 0xefcdab89;
    this._c = 0x98badcfe;
    this._d = 0x10325476;
    this._e = 0xc3d2e1f0;
    return this;
};
function rotl5(num) {
    return num << 5 | num >>> 27;
}
function rotl30(num) {
    return num << 30 | num >>> 2;
}
function ft(s, b, c, d) {
    if (s === 0) {
        return b & c | ~b & d;
    }
    if (s === 2) {
        return b & c | b & d | c & d;
    }
    return b ^ c ^ d;
}
Sha.prototype._update = function(M) {
    var w = this._w;
    var a = this._a | 0;
    var b = this._b | 0;
    var c = this._c | 0;
    var d = this._d | 0;
    var e = this._e | 0;
    for(var i = 0; i < 16; ++i){
        w[i] = M.readInt32BE(i * 4);
    }
    for(; i < 80; ++i){
        w[i] = w[i - 3] ^ w[i - 8] ^ w[i - 14] ^ w[i - 16];
    }
    for(var j = 0; j < 80; ++j){
        var s = ~~(j / 20);
        var t = rotl5(a) + ft(s, b, c, d) + e + w[j] + K[s] | 0;
        e = d;
        d = c;
        c = rotl30(b);
        b = a;
        a = t;
    }
    this._a = a + this._a | 0;
    this._b = b + this._b | 0;
    this._c = c + this._c | 0;
    this._d = d + this._d | 0;
    this._e = e + this._e | 0;
};
Sha.prototype._hash = function() {
    var H = Buffer.allocUnsafe(20);
    H.writeInt32BE(this._a | 0, 0);
    H.writeInt32BE(this._b | 0, 4);
    H.writeInt32BE(this._c | 0, 8);
    H.writeInt32BE(this._d | 0, 12);
    H.writeInt32BE(this._e | 0, 16);
    return H;
};
module.exports = Sha;
}),
"[project]/node_modules/sha.js/sha1.js [app-ssr] (ecmascript)", ((__turbopack_context__, module, exports) => {
"use strict";

/*
 * A JavaScript implementation of the Secure Hash Algorithm, SHA-1, as defined
 * in FIPS PUB 180-1
 * Version 2.1a Copyright Paul Johnston 2000 - 2002.
 * Other contributors: Greg Holt, Andrew Kepert, Ydnar, Lostinet
 * Distributed under the BSD License
 * See http://pajhome.org.uk/crypt/md5 for details.
 */ var inherits = __turbopack_context__.r("[project]/node_modules/inherits/inherits.js [app-ssr] (ecmascript)");
var Hash = __turbopack_context__.r("[project]/node_modules/sha.js/hash.js [app-ssr] (ecmascript)");
var Buffer = __turbopack_context__.r("[project]/node_modules/safe-buffer/index.js [app-ssr] (ecmascript)").Buffer;
var K = [
    0x5a827999,
    0x6ed9eba1,
    0x8f1bbcdc | 0,
    0xca62c1d6 | 0
];
var W = new Array(80);
function Sha1() {
    this.init();
    this._w = W;
    Hash.call(this, 64, 56);
}
inherits(Sha1, Hash);
Sha1.prototype.init = function() {
    this._a = 0x67452301;
    this._b = 0xefcdab89;
    this._c = 0x98badcfe;
    this._d = 0x10325476;
    this._e = 0xc3d2e1f0;
    return this;
};
function rotl1(num) {
    return num << 1 | num >>> 31;
}
function rotl5(num) {
    return num << 5 | num >>> 27;
}
function rotl30(num) {
    return num << 30 | num >>> 2;
}
function ft(s, b, c, d) {
    if (s === 0) {
        return b & c | ~b & d;
    }
    if (s === 2) {
        return b & c | b & d | c & d;
    }
    return b ^ c ^ d;
}
Sha1.prototype._update = function(M) {
    var w = this._w;
    var a = this._a | 0;
    var b = this._b | 0;
    var c = this._c | 0;
    var d = this._d | 0;
    var e = this._e | 0;
    for(var i = 0; i < 16; ++i){
        w[i] = M.readInt32BE(i * 4);
    }
    for(; i < 80; ++i){
        w[i] = rotl1(w[i - 3] ^ w[i - 8] ^ w[i - 14] ^ w[i - 16]);
    }
    for(var j = 0; j < 80; ++j){
        var s = ~~(j / 20);
        var t = rotl5(a) + ft(s, b, c, d) + e + w[j] + K[s] | 0;
        e = d;
        d = c;
        c = rotl30(b);
        b = a;
        a = t;
    }
    this._a = a + this._a | 0;
    this._b = b + this._b | 0;
    this._c = c + this._c | 0;
    this._d = d + this._d | 0;
    this._e = e + this._e | 0;
};
Sha1.prototype._hash = function() {
    var H = Buffer.allocUnsafe(20);
    H.writeInt32BE(this._a | 0, 0);
    H.writeInt32BE(this._b | 0, 4);
    H.writeInt32BE(this._c | 0, 8);
    H.writeInt32BE(this._d | 0, 12);
    H.writeInt32BE(this._e | 0, 16);
    return H;
};
module.exports = Sha1;
}),
"[project]/node_modules/sha.js/sha256.js [app-ssr] (ecmascript)", ((__turbopack_context__, module, exports) => {
"use strict";

/**
 * A JavaScript implementation of the Secure Hash Algorithm, SHA-256, as defined
 * in FIPS 180-2
 * Version 2.2-beta Copyright Angel Marin, Paul Johnston 2000 - 2009.
 * Other contributors: Greg Holt, Andrew Kepert, Ydnar, Lostinet
 *
 */ var inherits = __turbopack_context__.r("[project]/node_modules/inherits/inherits.js [app-ssr] (ecmascript)");
var Hash = __turbopack_context__.r("[project]/node_modules/sha.js/hash.js [app-ssr] (ecmascript)");
var Buffer = __turbopack_context__.r("[project]/node_modules/safe-buffer/index.js [app-ssr] (ecmascript)").Buffer;
var K = [
    0x428A2F98,
    0x71374491,
    0xB5C0FBCF,
    0xE9B5DBA5,
    0x3956C25B,
    0x59F111F1,
    0x923F82A4,
    0xAB1C5ED5,
    0xD807AA98,
    0x12835B01,
    0x243185BE,
    0x550C7DC3,
    0x72BE5D74,
    0x80DEB1FE,
    0x9BDC06A7,
    0xC19BF174,
    0xE49B69C1,
    0xEFBE4786,
    0x0FC19DC6,
    0x240CA1CC,
    0x2DE92C6F,
    0x4A7484AA,
    0x5CB0A9DC,
    0x76F988DA,
    0x983E5152,
    0xA831C66D,
    0xB00327C8,
    0xBF597FC7,
    0xC6E00BF3,
    0xD5A79147,
    0x06CA6351,
    0x14292967,
    0x27B70A85,
    0x2E1B2138,
    0x4D2C6DFC,
    0x53380D13,
    0x650A7354,
    0x766A0ABB,
    0x81C2C92E,
    0x92722C85,
    0xA2BFE8A1,
    0xA81A664B,
    0xC24B8B70,
    0xC76C51A3,
    0xD192E819,
    0xD6990624,
    0xF40E3585,
    0x106AA070,
    0x19A4C116,
    0x1E376C08,
    0x2748774C,
    0x34B0BCB5,
    0x391C0CB3,
    0x4ED8AA4A,
    0x5B9CCA4F,
    0x682E6FF3,
    0x748F82EE,
    0x78A5636F,
    0x84C87814,
    0x8CC70208,
    0x90BEFFFA,
    0xA4506CEB,
    0xBEF9A3F7,
    0xC67178F2
];
var W = new Array(64);
function Sha256() {
    this.init();
    this._w = W; // new Array(64)
    Hash.call(this, 64, 56);
}
inherits(Sha256, Hash);
Sha256.prototype.init = function() {
    this._a = 0x6a09e667;
    this._b = 0xbb67ae85;
    this._c = 0x3c6ef372;
    this._d = 0xa54ff53a;
    this._e = 0x510e527f;
    this._f = 0x9b05688c;
    this._g = 0x1f83d9ab;
    this._h = 0x5be0cd19;
    return this;
};
function ch(x, y, z) {
    return z ^ x & (y ^ z);
}
function maj(x, y, z) {
    return x & y | z & (x | y);
}
function sigma0(x) {
    return (x >>> 2 | x << 30) ^ (x >>> 13 | x << 19) ^ (x >>> 22 | x << 10);
}
function sigma1(x) {
    return (x >>> 6 | x << 26) ^ (x >>> 11 | x << 21) ^ (x >>> 25 | x << 7);
}
function gamma0(x) {
    return (x >>> 7 | x << 25) ^ (x >>> 18 | x << 14) ^ x >>> 3;
}
function gamma1(x) {
    return (x >>> 17 | x << 15) ^ (x >>> 19 | x << 13) ^ x >>> 10;
}
Sha256.prototype._update = function(M) {
    var w = this._w;
    var a = this._a | 0;
    var b = this._b | 0;
    var c = this._c | 0;
    var d = this._d | 0;
    var e = this._e | 0;
    var f = this._f | 0;
    var g = this._g | 0;
    var h = this._h | 0;
    for(var i = 0; i < 16; ++i){
        w[i] = M.readInt32BE(i * 4);
    }
    for(; i < 64; ++i){
        w[i] = gamma1(w[i - 2]) + w[i - 7] + gamma0(w[i - 15]) + w[i - 16] | 0;
    }
    for(var j = 0; j < 64; ++j){
        var T1 = h + sigma1(e) + ch(e, f, g) + K[j] + w[j] | 0;
        var T2 = sigma0(a) + maj(a, b, c) | 0;
        h = g;
        g = f;
        f = e;
        e = d + T1 | 0;
        d = c;
        c = b;
        b = a;
        a = T1 + T2 | 0;
    }
    this._a = a + this._a | 0;
    this._b = b + this._b | 0;
    this._c = c + this._c | 0;
    this._d = d + this._d | 0;
    this._e = e + this._e | 0;
    this._f = f + this._f | 0;
    this._g = g + this._g | 0;
    this._h = h + this._h | 0;
};
Sha256.prototype._hash = function() {
    var H = Buffer.allocUnsafe(32);
    H.writeInt32BE(this._a, 0);
    H.writeInt32BE(this._b, 4);
    H.writeInt32BE(this._c, 8);
    H.writeInt32BE(this._d, 12);
    H.writeInt32BE(this._e, 16);
    H.writeInt32BE(this._f, 20);
    H.writeInt32BE(this._g, 24);
    H.writeInt32BE(this._h, 28);
    return H;
};
module.exports = Sha256;
}),
"[project]/node_modules/sha.js/sha224.js [app-ssr] (ecmascript)", ((__turbopack_context__, module, exports) => {
"use strict";

/**
 * A JavaScript implementation of the Secure Hash Algorithm, SHA-256, as defined
 * in FIPS 180-2
 * Version 2.2-beta Copyright Angel Marin, Paul Johnston 2000 - 2009.
 * Other contributors: Greg Holt, Andrew Kepert, Ydnar, Lostinet
 *
 */ var inherits = __turbopack_context__.r("[project]/node_modules/inherits/inherits.js [app-ssr] (ecmascript)");
var Sha256 = __turbopack_context__.r("[project]/node_modules/sha.js/sha256.js [app-ssr] (ecmascript)");
var Hash = __turbopack_context__.r("[project]/node_modules/sha.js/hash.js [app-ssr] (ecmascript)");
var Buffer = __turbopack_context__.r("[project]/node_modules/safe-buffer/index.js [app-ssr] (ecmascript)").Buffer;
var W = new Array(64);
function Sha224() {
    this.init();
    this._w = W; // new Array(64)
    Hash.call(this, 64, 56);
}
inherits(Sha224, Sha256);
Sha224.prototype.init = function() {
    this._a = 0xc1059ed8;
    this._b = 0x367cd507;
    this._c = 0x3070dd17;
    this._d = 0xf70e5939;
    this._e = 0xffc00b31;
    this._f = 0x68581511;
    this._g = 0x64f98fa7;
    this._h = 0xbefa4fa4;
    return this;
};
Sha224.prototype._hash = function() {
    var H = Buffer.allocUnsafe(28);
    H.writeInt32BE(this._a, 0);
    H.writeInt32BE(this._b, 4);
    H.writeInt32BE(this._c, 8);
    H.writeInt32BE(this._d, 12);
    H.writeInt32BE(this._e, 16);
    H.writeInt32BE(this._f, 20);
    H.writeInt32BE(this._g, 24);
    return H;
};
module.exports = Sha224;
}),
"[project]/node_modules/sha.js/sha512.js [app-ssr] (ecmascript)", ((__turbopack_context__, module, exports) => {
"use strict";

var inherits = __turbopack_context__.r("[project]/node_modules/inherits/inherits.js [app-ssr] (ecmascript)");
var Hash = __turbopack_context__.r("[project]/node_modules/sha.js/hash.js [app-ssr] (ecmascript)");
var Buffer = __turbopack_context__.r("[project]/node_modules/safe-buffer/index.js [app-ssr] (ecmascript)").Buffer;
var K = [
    0x428a2f98,
    0xd728ae22,
    0x71374491,
    0x23ef65cd,
    0xb5c0fbcf,
    0xec4d3b2f,
    0xe9b5dba5,
    0x8189dbbc,
    0x3956c25b,
    0xf348b538,
    0x59f111f1,
    0xb605d019,
    0x923f82a4,
    0xaf194f9b,
    0xab1c5ed5,
    0xda6d8118,
    0xd807aa98,
    0xa3030242,
    0x12835b01,
    0x45706fbe,
    0x243185be,
    0x4ee4b28c,
    0x550c7dc3,
    0xd5ffb4e2,
    0x72be5d74,
    0xf27b896f,
    0x80deb1fe,
    0x3b1696b1,
    0x9bdc06a7,
    0x25c71235,
    0xc19bf174,
    0xcf692694,
    0xe49b69c1,
    0x9ef14ad2,
    0xefbe4786,
    0x384f25e3,
    0x0fc19dc6,
    0x8b8cd5b5,
    0x240ca1cc,
    0x77ac9c65,
    0x2de92c6f,
    0x592b0275,
    0x4a7484aa,
    0x6ea6e483,
    0x5cb0a9dc,
    0xbd41fbd4,
    0x76f988da,
    0x831153b5,
    0x983e5152,
    0xee66dfab,
    0xa831c66d,
    0x2db43210,
    0xb00327c8,
    0x98fb213f,
    0xbf597fc7,
    0xbeef0ee4,
    0xc6e00bf3,
    0x3da88fc2,
    0xd5a79147,
    0x930aa725,
    0x06ca6351,
    0xe003826f,
    0x14292967,
    0x0a0e6e70,
    0x27b70a85,
    0x46d22ffc,
    0x2e1b2138,
    0x5c26c926,
    0x4d2c6dfc,
    0x5ac42aed,
    0x53380d13,
    0x9d95b3df,
    0x650a7354,
    0x8baf63de,
    0x766a0abb,
    0x3c77b2a8,
    0x81c2c92e,
    0x47edaee6,
    0x92722c85,
    0x1482353b,
    0xa2bfe8a1,
    0x4cf10364,
    0xa81a664b,
    0xbc423001,
    0xc24b8b70,
    0xd0f89791,
    0xc76c51a3,
    0x0654be30,
    0xd192e819,
    0xd6ef5218,
    0xd6990624,
    0x5565a910,
    0xf40e3585,
    0x5771202a,
    0x106aa070,
    0x32bbd1b8,
    0x19a4c116,
    0xb8d2d0c8,
    0x1e376c08,
    0x5141ab53,
    0x2748774c,
    0xdf8eeb99,
    0x34b0bcb5,
    0xe19b48a8,
    0x391c0cb3,
    0xc5c95a63,
    0x4ed8aa4a,
    0xe3418acb,
    0x5b9cca4f,
    0x7763e373,
    0x682e6ff3,
    0xd6b2b8a3,
    0x748f82ee,
    0x5defb2fc,
    0x78a5636f,
    0x43172f60,
    0x84c87814,
    0xa1f0ab72,
    0x8cc70208,
    0x1a6439ec,
    0x90befffa,
    0x23631e28,
    0xa4506ceb,
    0xde82bde9,
    0xbef9a3f7,
    0xb2c67915,
    0xc67178f2,
    0xe372532b,
    0xca273ece,
    0xea26619c,
    0xd186b8c7,
    0x21c0c207,
    0xeada7dd6,
    0xcde0eb1e,
    0xf57d4f7f,
    0xee6ed178,
    0x06f067aa,
    0x72176fba,
    0x0a637dc5,
    0xa2c898a6,
    0x113f9804,
    0xbef90dae,
    0x1b710b35,
    0x131c471b,
    0x28db77f5,
    0x23047d84,
    0x32caab7b,
    0x40c72493,
    0x3c9ebe0a,
    0x15c9bebc,
    0x431d67c4,
    0x9c100d4c,
    0x4cc5d4be,
    0xcb3e42b6,
    0x597f299c,
    0xfc657e2a,
    0x5fcb6fab,
    0x3ad6faec,
    0x6c44198c,
    0x4a475817
];
var W = new Array(160);
function Sha512() {
    this.init();
    this._w = W;
    Hash.call(this, 128, 112);
}
inherits(Sha512, Hash);
Sha512.prototype.init = function() {
    this._ah = 0x6a09e667;
    this._bh = 0xbb67ae85;
    this._ch = 0x3c6ef372;
    this._dh = 0xa54ff53a;
    this._eh = 0x510e527f;
    this._fh = 0x9b05688c;
    this._gh = 0x1f83d9ab;
    this._hh = 0x5be0cd19;
    this._al = 0xf3bcc908;
    this._bl = 0x84caa73b;
    this._cl = 0xfe94f82b;
    this._dl = 0x5f1d36f1;
    this._el = 0xade682d1;
    this._fl = 0x2b3e6c1f;
    this._gl = 0xfb41bd6b;
    this._hl = 0x137e2179;
    return this;
};
function Ch(x, y, z) {
    return z ^ x & (y ^ z);
}
function maj(x, y, z) {
    return x & y | z & (x | y);
}
function sigma0(x, xl) {
    return (x >>> 28 | xl << 4) ^ (xl >>> 2 | x << 30) ^ (xl >>> 7 | x << 25);
}
function sigma1(x, xl) {
    return (x >>> 14 | xl << 18) ^ (x >>> 18 | xl << 14) ^ (xl >>> 9 | x << 23);
}
function Gamma0(x, xl) {
    return (x >>> 1 | xl << 31) ^ (x >>> 8 | xl << 24) ^ x >>> 7;
}
function Gamma0l(x, xl) {
    return (x >>> 1 | xl << 31) ^ (x >>> 8 | xl << 24) ^ (x >>> 7 | xl << 25);
}
function Gamma1(x, xl) {
    return (x >>> 19 | xl << 13) ^ (xl >>> 29 | x << 3) ^ x >>> 6;
}
function Gamma1l(x, xl) {
    return (x >>> 19 | xl << 13) ^ (xl >>> 29 | x << 3) ^ (x >>> 6 | xl << 26);
}
function getCarry(a, b) {
    return a >>> 0 < b >>> 0 ? 1 : 0;
}
Sha512.prototype._update = function(M) {
    var w = this._w;
    var ah = this._ah | 0;
    var bh = this._bh | 0;
    var ch = this._ch | 0;
    var dh = this._dh | 0;
    var eh = this._eh | 0;
    var fh = this._fh | 0;
    var gh = this._gh | 0;
    var hh = this._hh | 0;
    var al = this._al | 0;
    var bl = this._bl | 0;
    var cl = this._cl | 0;
    var dl = this._dl | 0;
    var el = this._el | 0;
    var fl = this._fl | 0;
    var gl = this._gl | 0;
    var hl = this._hl | 0;
    for(var i = 0; i < 32; i += 2){
        w[i] = M.readInt32BE(i * 4);
        w[i + 1] = M.readInt32BE(i * 4 + 4);
    }
    for(; i < 160; i += 2){
        var xh = w[i - 15 * 2];
        var xl = w[i - 15 * 2 + 1];
        var gamma0 = Gamma0(xh, xl);
        var gamma0l = Gamma0l(xl, xh);
        xh = w[i - 2 * 2];
        xl = w[i - 2 * 2 + 1];
        var gamma1 = Gamma1(xh, xl);
        var gamma1l = Gamma1l(xl, xh);
        // w[i] = gamma0 + w[i - 7] + gamma1 + w[i - 16]
        var Wi7h = w[i - 7 * 2];
        var Wi7l = w[i - 7 * 2 + 1];
        var Wi16h = w[i - 16 * 2];
        var Wi16l = w[i - 16 * 2 + 1];
        var Wil = gamma0l + Wi7l | 0;
        var Wih = gamma0 + Wi7h + getCarry(Wil, gamma0l) | 0;
        Wil = Wil + gamma1l | 0;
        Wih = Wih + gamma1 + getCarry(Wil, gamma1l) | 0;
        Wil = Wil + Wi16l | 0;
        Wih = Wih + Wi16h + getCarry(Wil, Wi16l) | 0;
        w[i] = Wih;
        w[i + 1] = Wil;
    }
    for(var j = 0; j < 160; j += 2){
        Wih = w[j];
        Wil = w[j + 1];
        var majh = maj(ah, bh, ch);
        var majl = maj(al, bl, cl);
        var sigma0h = sigma0(ah, al);
        var sigma0l = sigma0(al, ah);
        var sigma1h = sigma1(eh, el);
        var sigma1l = sigma1(el, eh);
        // t1 = h + sigma1 + ch + K[j] + w[j]
        var Kih = K[j];
        var Kil = K[j + 1];
        var chh = Ch(eh, fh, gh);
        var chl = Ch(el, fl, gl);
        var t1l = hl + sigma1l | 0;
        var t1h = hh + sigma1h + getCarry(t1l, hl) | 0;
        t1l = t1l + chl | 0;
        t1h = t1h + chh + getCarry(t1l, chl) | 0;
        t1l = t1l + Kil | 0;
        t1h = t1h + Kih + getCarry(t1l, Kil) | 0;
        t1l = t1l + Wil | 0;
        t1h = t1h + Wih + getCarry(t1l, Wil) | 0;
        // t2 = sigma0 + maj
        var t2l = sigma0l + majl | 0;
        var t2h = sigma0h + majh + getCarry(t2l, sigma0l) | 0;
        hh = gh;
        hl = gl;
        gh = fh;
        gl = fl;
        fh = eh;
        fl = el;
        el = dl + t1l | 0;
        eh = dh + t1h + getCarry(el, dl) | 0;
        dh = ch;
        dl = cl;
        ch = bh;
        cl = bl;
        bh = ah;
        bl = al;
        al = t1l + t2l | 0;
        ah = t1h + t2h + getCarry(al, t1l) | 0;
    }
    this._al = this._al + al | 0;
    this._bl = this._bl + bl | 0;
    this._cl = this._cl + cl | 0;
    this._dl = this._dl + dl | 0;
    this._el = this._el + el | 0;
    this._fl = this._fl + fl | 0;
    this._gl = this._gl + gl | 0;
    this._hl = this._hl + hl | 0;
    this._ah = this._ah + ah + getCarry(this._al, al) | 0;
    this._bh = this._bh + bh + getCarry(this._bl, bl) | 0;
    this._ch = this._ch + ch + getCarry(this._cl, cl) | 0;
    this._dh = this._dh + dh + getCarry(this._dl, dl) | 0;
    this._eh = this._eh + eh + getCarry(this._el, el) | 0;
    this._fh = this._fh + fh + getCarry(this._fl, fl) | 0;
    this._gh = this._gh + gh + getCarry(this._gl, gl) | 0;
    this._hh = this._hh + hh + getCarry(this._hl, hl) | 0;
};
Sha512.prototype._hash = function() {
    var H = Buffer.allocUnsafe(64);
    function writeInt64BE(h, l, offset) {
        H.writeInt32BE(h, offset);
        H.writeInt32BE(l, offset + 4);
    }
    writeInt64BE(this._ah, this._al, 0);
    writeInt64BE(this._bh, this._bl, 8);
    writeInt64BE(this._ch, this._cl, 16);
    writeInt64BE(this._dh, this._dl, 24);
    writeInt64BE(this._eh, this._el, 32);
    writeInt64BE(this._fh, this._fl, 40);
    writeInt64BE(this._gh, this._gl, 48);
    writeInt64BE(this._hh, this._hl, 56);
    return H;
};
module.exports = Sha512;
}),
"[project]/node_modules/sha.js/sha384.js [app-ssr] (ecmascript)", ((__turbopack_context__, module, exports) => {
"use strict";

var inherits = __turbopack_context__.r("[project]/node_modules/inherits/inherits.js [app-ssr] (ecmascript)");
var SHA512 = __turbopack_context__.r("[project]/node_modules/sha.js/sha512.js [app-ssr] (ecmascript)");
var Hash = __turbopack_context__.r("[project]/node_modules/sha.js/hash.js [app-ssr] (ecmascript)");
var Buffer = __turbopack_context__.r("[project]/node_modules/safe-buffer/index.js [app-ssr] (ecmascript)").Buffer;
var W = new Array(160);
function Sha384() {
    this.init();
    this._w = W;
    Hash.call(this, 128, 112);
}
inherits(Sha384, SHA512);
Sha384.prototype.init = function() {
    this._ah = 0xcbbb9d5d;
    this._bh = 0x629a292a;
    this._ch = 0x9159015a;
    this._dh = 0x152fecd8;
    this._eh = 0x67332667;
    this._fh = 0x8eb44a87;
    this._gh = 0xdb0c2e0d;
    this._hh = 0x47b5481d;
    this._al = 0xc1059ed8;
    this._bl = 0x367cd507;
    this._cl = 0x3070dd17;
    this._dl = 0xf70e5939;
    this._el = 0xffc00b31;
    this._fl = 0x68581511;
    this._gl = 0x64f98fa7;
    this._hl = 0xbefa4fa4;
    return this;
};
Sha384.prototype._hash = function() {
    var H = Buffer.allocUnsafe(48);
    function writeInt64BE(h, l, offset) {
        H.writeInt32BE(h, offset);
        H.writeInt32BE(l, offset + 4);
    }
    writeInt64BE(this._ah, this._al, 0);
    writeInt64BE(this._bh, this._bl, 8);
    writeInt64BE(this._ch, this._cl, 16);
    writeInt64BE(this._dh, this._dl, 24);
    writeInt64BE(this._eh, this._el, 32);
    writeInt64BE(this._fh, this._fl, 40);
    return H;
};
module.exports = Sha384;
}),
"[project]/node_modules/sha.js/index.js [app-ssr] (ecmascript)", ((__turbopack_context__, module, exports) => {
"use strict";

module.exports = function SHA(algorithm) {
    var alg = algorithm.toLowerCase();
    var Algorithm = module.exports[alg];
    if (!Algorithm) {
        throw new Error(alg + ' is not supported (we accept pull requests)');
    }
    return new Algorithm();
};
module.exports.sha = __turbopack_context__.r("[project]/node_modules/sha.js/sha.js [app-ssr] (ecmascript)");
module.exports.sha1 = __turbopack_context__.r("[project]/node_modules/sha.js/sha1.js [app-ssr] (ecmascript)");
module.exports.sha224 = __turbopack_context__.r("[project]/node_modules/sha.js/sha224.js [app-ssr] (ecmascript)");
module.exports.sha256 = __turbopack_context__.r("[project]/node_modules/sha.js/sha256.js [app-ssr] (ecmascript)");
module.exports.sha384 = __turbopack_context__.r("[project]/node_modules/sha.js/sha384.js [app-ssr] (ecmascript)");
module.exports.sha512 = __turbopack_context__.r("[project]/node_modules/sha.js/sha512.js [app-ssr] (ecmascript)");
}),
"[project]/node_modules/require-addon/lib/runtime.js [app-ssr] (ecmascript)", ((__turbopack_context__, module, exports) => {

module.exports = typeof Bare !== 'undefined' ? 'bare' : typeof process !== 'undefined' ? 'node' : 'unknown';
}),
"[project]/node_modules/require-addon/lib/runtime/default.js [app-ssr] (ecmascript)", ((__turbopack_context__, module, exports) => {

if (typeof /*TURBOPACK member replacement*/ __turbopack_context__.t.addon === 'function') {
    module.exports = /*TURBOPACK member replacement*/ __turbopack_context__.t.addon.bind(/*TURBOPACK member replacement*/ __turbopack_context__.t);
} else {
    module.exports = function addon(specifier, parentURL) {
        throw new Error(`Cannot find addon '${specifier}' imported from '${parentURL}'`);
    };
}
}),
"[project]/node_modules/require-addon/lib/runtime/node.js [app-ssr] (ecmascript)", ((__turbopack_context__, module, exports) => {

if (typeof /*TURBOPACK member replacement*/ __turbopack_context__.t.addon === 'function') {
    module.exports = /*TURBOPACK member replacement*/ __turbopack_context__.t.addon.bind(/*TURBOPACK member replacement*/ __turbopack_context__.t);
} else {
    const url = __turbopack_context__.r("[externals]/url [external] (url, cjs)");
    const resolve = __turbopack_context__.r("[project]/node_modules/bare-addon-resolve/index.js [app-ssr] (ecmascript)");
    const host = process.platform + '-' + process.arch;
    const conditions = [
        'node',
        process.platform,
        process.arch
    ];
    const extensions = [
        '.node'
    ];
    module.exports = function addon(specifier, parentURL) {
        if (typeof parentURL === 'string') parentURL = url.pathToFileURL(parentURL);
        for (const resolution of resolve(specifier, parentURL, {
            host,
            conditions,
            extensions
        }, readPackage)){
            switch(resolution.protocol){
                case 'file:':
                    try {
                        return (()=>{
                            const e = new Error("Cannot find module as expression is too dynamic");
                            e.code = 'MODULE_NOT_FOUND';
                            throw e;
                        })();
                    } catch  {
                        continue;
                    }
            }
        }
        throw new Error(`Cannot find addon '${specifier}' imported from '${parentURL.href}'`);
        function readPackage(packageURL) {
            try {
                return (()=>{
                    const e = new Error("Cannot find module as expression is too dynamic");
                    e.code = 'MODULE_NOT_FOUND';
                    throw e;
                })();
            } catch (err) {
                return null;
            }
        }
    };
}
}),
"[project]/node_modules/require-addon/lib/runtime/bare.js [app-ssr] (ecmascript)", ((__turbopack_context__, module, exports) => {

module.exports = /*TURBOPACK member replacement*/ __turbopack_context__.t.addon.bind(/*TURBOPACK member replacement*/ __turbopack_context__.t);
}),
"[project]/node_modules/require-addon/index.js [app-ssr] (ecmascript)", ((__turbopack_context__, module, exports) => {

const runtime = __turbopack_context__.r("[project]/node_modules/require-addon/lib/runtime.js [app-ssr] (ecmascript)");
if (runtime === 'bare') {
    module.exports = __turbopack_context__.r("[project]/node_modules/require-addon/lib/runtime/bare.js [app-ssr] (ecmascript)");
} else if (runtime === 'node') {
    module.exports = __turbopack_context__.r("[project]/node_modules/require-addon/lib/runtime/node.js [app-ssr] (ecmascript)");
} else {
    module.exports = __turbopack_context__.r("[project]/node_modules/require-addon/lib/runtime/default.js [app-ssr] (ecmascript)");
}
}),
"[project]/node_modules/bare-semver/lib/constants.js [app-ssr] (ecmascript)", ((__turbopack_context__, module, exports) => {

module.exports = {
    EQ: 1,
    LT: 2,
    LTE: 3,
    GT: 4,
    GTE: 5
};
}),
"[project]/node_modules/bare-semver/lib/errors.js [app-ssr] (ecmascript)", ((__turbopack_context__, module, exports) => {

module.exports = class SemVerError extends Error {
    constructor(msg, code, fn = SemVerError){
        super(`${code}: ${msg}`);
        this.code = code;
        if (Error.captureStackTrace) {
            Error.captureStackTrace(this, fn);
        }
    }
    get name() {
        return 'SemVerError';
    }
    static INVALID_VERSION(msg, fn = SemVerError.INVALID_VERSION) {
        return new SemVerError(msg, 'INVALID_VERSION', fn);
    }
    static INVALID_RANGE(msg, fn = SemVerError.INVALID_RANGE) {
        return new SemVerError(msg, 'INVALID_RANGE', fn);
    }
};
}),
"[project]/node_modules/bare-semver/lib/version.js [app-ssr] (ecmascript)", ((__turbopack_context__, module, exports) => {

const errors = __turbopack_context__.r("[project]/node_modules/bare-semver/lib/errors.js [app-ssr] (ecmascript)");
class Version {
    constructor(major, minor, patch, opts = {}){
        const { prerelease = [], build = [] } = opts;
        this.major = major;
        this.minor = minor;
        this.patch = patch;
        this.prerelease = prerelease;
        this.build = build;
    }
    compare(version) {
        return exports.compare(this, version);
    }
    toString() {
        let result = `${this.major}.${this.minor}.${this.patch}`;
        if (this.prerelease.length) {
            result += '-' + this.prerelease.join('.');
        }
        if (this.build.length) {
            result += '+' + this.build.join('.');
        }
        return result;
    }
}
module.exports = exports = Version;
exports.parse = function parse(input, state = {
    position: 0,
    partial: false,
    range: false
}) {
    let i = state.position;
    let c;
    const unexpected = (expected)=>{
        let msg;
        if (i >= input.length) {
            msg = `Unexpected end of input in '${input}'`;
        } else {
            msg = `Unexpected token '${input[i]}' in '${input}' at position ${i}`;
        }
        if (expected) msg += `, ${expected}`;
        throw errors.INVALID_VERSION(msg, unexpected);
    };
    const components = [
        0,
        0,
        0
    ];
    let k = 0;
    while(k < 3){
        c = input[i];
        if (k > 0) {
            if (c === '.') c = input[++i];
            else if (state.range) break;
            else unexpected("expected '.'");
        }
        if (c === '0') {
            i++;
            k++;
        } else if (c >= '1' && c <= '9') {
            let j = 0;
            do c = input[i + ++j];
            while (c >= '0' && c <= '9')
            components[k++] = parseInt(input.substring(i, i + j));
            i += j;
        } else unexpected('expected /[0-9]/');
    }
    const prerelease = [];
    if (k === 3 && input[i] === '-') {
        i++;
        while(true){
            c = input[i];
            let tag = '';
            let j = 0;
            while(c >= '0' && c <= '9')c = input[i + ++j];
            let isNumeric = false;
            if (j) {
                tag += input.substring(i, i + j);
                c = input[i += j];
                isNumeric = tag[0] !== '0' || tag.length === 1;
            }
            j = 0;
            while(c >= '0' && c <= '9' || c >= 'a' && c <= 'z' || c >= 'A' && c <= 'Z' || c === '-')c = input[i + ++j];
            if (j) {
                tag += input.substring(i, i + j);
                c = input[i += j];
            } else if (!isNumeric) unexpected('expected /[a-zA-Z-]/');
            prerelease.push(tag);
            if (c === '.') c = input[++i];
            else break;
        }
    }
    const build = [];
    if (k === 3 && input[i] === '+') {
        i++;
        while(true){
            c = input[i];
            let tag = '';
            let j = 0;
            while(c >= '0' && c <= '9' || c >= 'a' && c <= 'z' || c >= 'A' && c <= 'Z' || c === '-')c = input[i + ++j];
            if (j) {
                tag += input.substring(i, i + j);
                c = input[i += j];
            } else unexpected('expected /[0-9a-zA-Z-]/');
            build.push(tag);
            if (c === '.') c = input[++i];
            else break;
        }
    }
    if (i < input.length && state.partial === false) {
        unexpected('expected end of input');
    }
    state.position = i;
    return new Version(...components, {
        prerelease,
        build
    });
};
const integer = /^[0-9]+$/;
exports.compare = function compare(a, b) {
    if (a.major > b.major) return 1;
    if (a.major < b.major) return -1;
    if (a.minor > b.minor) return 1;
    if (a.minor < b.minor) return -1;
    if (a.patch > b.patch) return 1;
    if (a.patch < b.patch) return -1;
    if (a.prerelease.length === 0) return b.prerelease.length === 0 ? 0 : 1;
    if (b.prerelease.length === 0) return -1;
    let i = 0;
    do {
        let x = a.prerelease[i];
        let y = b.prerelease[i];
        if (x === undefined) return y === undefined ? 0 : -1;
        if (y === undefined) return 1;
        if (x === y) continue;
        const xInt = integer.test(x);
        const yInt = integer.test(y);
        if (xInt && yInt) {
            x = +x;
            y = +y;
        } else {
            if (xInt) return -1;
            if (yInt) return 1;
        }
        return x > y ? 1 : -1;
    }while (++i)
};
}),
"[project]/node_modules/bare-semver/lib/comparator.js [app-ssr] (ecmascript)", ((__turbopack_context__, module, exports) => {

const constants = __turbopack_context__.r("[project]/node_modules/bare-semver/lib/constants.js [app-ssr] (ecmascript)");
const symbols = {
    [constants.EQ]: '=',
    [constants.LT]: '<',
    [constants.LTE]: '<=',
    [constants.GT]: '>',
    [constants.GTE]: '>='
};
module.exports = class Comparator {
    constructor(operator, version){
        this.operator = operator;
        this.version = version;
    }
    test(version) {
        const result = version.compare(this.version);
        switch(this.operator){
            case constants.LT:
                return result < 0;
            case constants.LTE:
                return result <= 0;
            case constants.GT:
                return result > 0;
            case constants.GTE:
                return result >= 0;
            default:
                return result === 0;
        }
    }
    toString() {
        return symbols[this.operator] + this.version;
    }
};
}),
"[project]/node_modules/bare-semver/lib/range.js [app-ssr] (ecmascript)", ((__turbopack_context__, module, exports) => {

const constants = __turbopack_context__.r("[project]/node_modules/bare-semver/lib/constants.js [app-ssr] (ecmascript)");
const errors = __turbopack_context__.r("[project]/node_modules/bare-semver/lib/errors.js [app-ssr] (ecmascript)");
const Version = __turbopack_context__.r("[project]/node_modules/bare-semver/lib/version.js [app-ssr] (ecmascript)");
const Comparator = __turbopack_context__.r("[project]/node_modules/bare-semver/lib/comparator.js [app-ssr] (ecmascript)");
class Range {
    constructor(comparators = []){
        this.comparators = comparators;
    }
    test(version) {
        for (const set of this.comparators){
            let matches = true;
            for (const comparator of set){
                if (comparator.test(version)) continue;
                matches = false;
                break;
            }
            if (matches) return true;
        }
        return false;
    }
    toString() {
        let result = '';
        let first = true;
        for (const set of this.comparators){
            if (first) first = false;
            else result += ' || ';
            result += set.join(' ');
        }
        return result;
    }
}
module.exports = exports = Range;
exports.parse = function parse(input, state = {
    position: 0,
    partial: false
}) {
    let i = state.position;
    let c;
    const unexpected = (expected)=>{
        let msg;
        if (i >= input.length) {
            msg = `Unexpected end of input in '${input}'`;
        } else {
            msg = `Unexpected token '${input[i]}' in '${input}' at position ${i}`;
        }
        if (expected) msg += `, ${expected}`;
        throw errors.INVALID_VERSION(msg, unexpected);
    };
    const comparators = [];
    while(i < input.length){
        const set = [];
        while(i < input.length){
            c = input[i];
            let operator = constants.EQ;
            if (c === '<') {
                operator = constants.LT;
                c = input[++i];
                if (c === '=') {
                    operator = constants.LTE;
                    c = input[++i];
                }
            } else if (c === '>') {
                operator = constants.GT;
                c = input[++i];
                if (c === '=') {
                    operator = constants.GTE;
                    c = input[++i];
                }
            } else if (c === '=') {
                c = input[++i];
            }
            const state = {
                position: i,
                partial: true,
                range: true
            };
            set.push(new Comparator(operator, Version.parse(input, state)));
            c = input[i = state.position];
            while(c === ' ')c = input[++i];
            if (c === '|' && input[i + 1] === '|') {
                c = input[i += 2];
                while(c === ' ')c = input[++i];
                break;
            }
            if (c && c !== '<' && c !== '>') unexpected("expected '||', '<', or '>'");
        }
        if (set.length) comparators.push(set);
    }
    if (i < input.length && state.partial === false) {
        unexpected('expected end of input');
    }
    state.position = i;
    return new Range(comparators);
};
}),
"[project]/node_modules/bare-semver/index.js [app-ssr] (ecmascript)", ((__turbopack_context__, module, exports) => {

exports.constants = __turbopack_context__.r("[project]/node_modules/bare-semver/lib/constants.js [app-ssr] (ecmascript)");
exports.errors = __turbopack_context__.r("[project]/node_modules/bare-semver/lib/errors.js [app-ssr] (ecmascript)");
const Version = exports.Version = __turbopack_context__.r("[project]/node_modules/bare-semver/lib/version.js [app-ssr] (ecmascript)");
const Range = exports.Range = __turbopack_context__.r("[project]/node_modules/bare-semver/lib/range.js [app-ssr] (ecmascript)");
exports.Comparator = __turbopack_context__.r("[project]/node_modules/bare-semver/lib/comparator.js [app-ssr] (ecmascript)");
exports.satisfies = function satisfies(version, range) {
    if (typeof version === 'string') version = Version.parse(version);
    if (typeof range === 'string') range = Range.parse(range);
    return range.test(version);
};
}),
"[project]/node_modules/bare-module-resolve/lib/errors.js [app-ssr] (ecmascript)", ((__turbopack_context__, module, exports) => {

module.exports = class ModuleResolveError extends Error {
    constructor(msg, code, fn = ModuleResolveError){
        super(`${code}: ${msg}`);
        this.code = code;
        if (Error.captureStackTrace) {
            Error.captureStackTrace(this, fn);
        }
    }
    get name() {
        return 'ModuleResolveError';
    }
    static INVALID_MODULE_SPECIFIER(msg) {
        return new ModuleResolveError(msg, 'INVALID_MODULE_SPECIFIER', ModuleResolveError.INVALID_MODULE_SPECIFIER);
    }
    static INVALID_PACKAGE_TARGET(msg) {
        return new ModuleResolveError(msg, 'INVALID_PACKAGE_TARGET', ModuleResolveError.INVALID_PACKAGE_TARGET);
    }
    static PACKAGE_PATH_NOT_EXPORTED(msg) {
        return new ModuleResolveError(msg, 'PACKAGE_PATH_NOT_EXPORTED', ModuleResolveError.PACKAGE_PATH_NOT_EXPORTED);
    }
    static PACKAGE_IMPORT_NOT_DEFINED(msg) {
        return new ModuleResolveError(msg, 'PACKAGE_IMPORT_NOT_DEFINED', ModuleResolveError.PACKAGE_IMPORT_NOT_DEFINED);
    }
    static UNSUPPORTED_ENGINE(msg) {
        return new ModuleResolveError(msg, 'UNSUPPORTED_ENGINE', ModuleResolveError.UNSUPPORTED_ENGINE);
    }
};
}),
"[project]/node_modules/bare-module-resolve/index.js [app-ssr] (ecmascript)", ((__turbopack_context__, module, exports) => {

const { satisfies } = __turbopack_context__.r("[project]/node_modules/bare-semver/index.js [app-ssr] (ecmascript)");
const errors = __turbopack_context__.r("[project]/node_modules/bare-module-resolve/lib/errors.js [app-ssr] (ecmascript)");
module.exports = exports = function resolve(specifier, parentURL, opts, readPackage) {
    if (typeof opts === 'function') {
        readPackage = opts;
        opts = {};
    } else if (typeof readPackage !== 'function') {
        readPackage = defaultReadPackage;
    }
    return {
        *[Symbol.iterator] () {
            const generator = exports.module(specifier, parentURL, opts);
            let next = generator.next();
            while(next.done !== true){
                const value = next.value;
                if (value.package) {
                    next = generator.next(readPackage(value.package));
                } else {
                    next = generator.next((yield value.resolution));
                }
            }
            return next.value;
        },
        async *[Symbol.asyncIterator] () {
            const generator = exports.module(specifier, parentURL, opts);
            let next = generator.next();
            while(next.done !== true){
                const value = next.value;
                if (value.package) {
                    next = generator.next(await readPackage(value.package));
                } else {
                    next = generator.next((yield value.resolution));
                }
            }
            return next.value;
        }
    };
};
function defaultReadPackage() {
    return null;
}
// No resolution candidate was yielded
const UNRESOLVED = 0x0;
// At least 1 resolution candidate was yielded
const YIELDED = 0x1;
// At least 1 resolution candidate was yielded and resolved
const RESOLVED = YIELDED | 0x2;
exports.constants = {
    UNRESOLVED,
    YIELDED,
    RESOLVED
};
exports.module = function*(specifier, parentURL, opts = {}) {
    const { resolutions = null, imports = null } = opts;
    if (exports.startsWithWindowsDriveLetter(specifier)) {
        specifier = '/' + specifier;
    }
    let status;
    if (resolutions) {
        status = yield* exports.preresolved(specifier, resolutions, parentURL, opts);
        if (status) return status;
    }
    status = yield* exports.url(specifier, parentURL, opts);
    if (status) return status;
    status = yield* exports.packageImports(specifier, parentURL, opts);
    if (status) return status;
    if (specifier === '.' || specifier === '..' || specifier[0] === '/' || specifier[0] === '\\' || specifier.startsWith('./') || specifier.startsWith('.\\') || specifier.startsWith('../') || specifier.startsWith('..\\')) {
        if (imports) {
            status = yield* exports.packageImportsExports(specifier, imports, parentURL, true, opts);
            if (status) return status;
        }
        status = yield* exports.deferred(specifier, opts);
        if (status) return status;
        status = yield* exports.file(specifier, parentURL, false, opts);
        if (status === RESOLVED) return status;
        return yield* exports.directory(specifier, parentURL, opts);
    }
    return yield* exports.package(specifier, parentURL, opts);
};
exports.url = function*(url, parentURL, opts = {}) {
    const { imports = null, deferredProtocol = 'deferred:' } = opts;
    let resolution;
    try {
        resolution = new URL(url);
    } catch  {
        return UNRESOLVED;
    }
    if (imports) {
        const status = yield* exports.packageImportsExports(resolution.href, imports, parentURL, true, opts);
        if (status) return status;
    }
    if (resolution.protocol === deferredProtocol) {
        const specifier = resolution.pathname;
        return yield* exports.module(specifier, parentURL, opts);
    }
    if (resolution.protocol === 'node:') {
        const specifier = resolution.pathname;
        if (specifier === '.' || specifier === '..' || specifier[0] === '/' || specifier.startsWith('./') || specifier.startsWith('../')) {
            throw errors.INVALID_MODULE_SPECIFIER(`Module specifier '${url}' is not a valid package name`);
        }
        return yield* exports.package(specifier, parentURL, opts);
    }
    const resolved = yield {
        resolution
    };
    return resolved ? RESOLVED : YIELDED;
};
exports.preresolved = function*(specifier, resolutions, parentURL, opts = {}) {
    const imports = resolutions[parentURL.href];
    if (typeof imports === 'object' && imports !== null) {
        return yield* exports.packageImportsExports(specifier, imports, parentURL, true, opts);
    }
    return UNRESOLVED;
};
exports.deferred = function*(specifier, opts = {}) {
    const { deferredProtocol = 'deferred:', defer = [] } = opts;
    if (defer.includes(specifier)) {
        const resolved = yield {
            resolution: new URL(deferredProtocol + specifier)
        };
        return resolved ? RESOLVED : YIELDED;
    }
    return UNRESOLVED;
};
exports.package = function*(packageSpecifier, parentURL, opts = {}) {
    const { builtins = [] } = opts;
    if (packageSpecifier === '') {
        throw errors.INVALID_MODULE_SPECIFIER(`Module specifier '${packageSpecifier}' is not a valid package name`);
    }
    let packageName;
    if (packageSpecifier[0] !== '@') {
        packageName = packageSpecifier.split('/', 1).join();
    } else {
        if (!packageSpecifier.includes('/')) {
            throw errors.INVALID_MODULE_SPECIFIER(`Module specifier '${packageSpecifier}' is not a valid package name`);
        }
        packageName = packageSpecifier.split('/', 2).join('/');
    }
    if (packageName[0] === '.' || packageName.includes('\\') || packageName.includes('%')) {
        throw errors.INVALID_MODULE_SPECIFIER(`Module specifier '${packageSpecifier}' is not a valid package name`);
    }
    let status;
    status = yield* exports.builtinTarget(packageSpecifier, null, builtins, opts);
    if (status) return status;
    status = yield* exports.deferred(packageSpecifier, opts);
    if (status) return status;
    let packageSubpath = '.' + packageSpecifier.substring(packageName.length);
    status = yield* exports.packageSelf(packageName, packageSubpath, parentURL, opts);
    if (status) return status;
    parentURL = new URL(parentURL.href);
    do {
        const packageURL = new URL('node_modules/' + packageName + '/', parentURL);
        parentURL.pathname = parentURL.pathname.substring(0, parentURL.pathname.lastIndexOf('/'));
        const info = yield {
            package: new URL('package.json', packageURL)
        };
        if (info) {
            if (info.engines) exports.validateEngines(packageURL, info.engines, opts);
            if (info.exports) {
                return yield* exports.packageExports(packageURL, packageSubpath, info.exports, opts);
            }
            if (packageSubpath === '.') {
                if (typeof info.main === 'string' && info.main !== '') {
                    packageSubpath = info.main;
                } else {
                    return yield* exports.file('index', packageURL, true, opts);
                }
            }
            status = yield* exports.file(packageSubpath, packageURL, false, opts);
            if (status === RESOLVED) return status;
            return yield* exports.directory(packageSubpath, packageURL, opts);
        }
    }while (parentURL.pathname !== '' && parentURL.pathname !== '/')
    return UNRESOLVED;
};
exports.packageSelf = function*(packageName, packageSubpath, parentURL, opts = {}) {
    for (const packageURL of exports.lookupPackageScope(parentURL, opts)){
        const info = yield {
            package: packageURL
        };
        if (info) {
            if (info.name !== packageName) return false;
            if (info.exports) {
                return yield* exports.packageExports(packageURL, packageSubpath, info.exports, opts);
            }
            if (packageSubpath === '.') {
                if (typeof info.main === 'string' && info.main !== '') {
                    packageSubpath = info.main;
                } else {
                    return yield* exports.file('index', packageURL, true, opts);
                }
            }
            const status = yield* exports.file(packageSubpath, packageURL, false, opts);
            if (status === RESOLVED) return status;
            return yield* exports.directory(packageSubpath, packageURL, opts);
        }
    }
    return UNRESOLVED;
};
exports.packageExports = function*(packageURL, subpath, packageExports, opts = {}) {
    if (subpath === '.') {
        let mainExport;
        if (typeof packageExports === 'string' || Array.isArray(packageExports)) {
            mainExport = packageExports;
        } else if (typeof packageExports === 'object' && packageExports !== null) {
            const keys = Object.keys(packageExports);
            if (keys.some((key)=>key.startsWith('.'))) {
                if ('.' in packageExports) mainExport = packageExports['.'];
            } else {
                mainExport = packageExports;
            }
        }
        if (mainExport) {
            const status = yield* exports.packageTarget(packageURL, mainExport, null, false, opts);
            if (status) return status;
        }
    } else if (typeof packageExports === 'object' && packageExports !== null) {
        const keys = Object.keys(packageExports);
        if (keys.every((key)=>key.startsWith('.'))) {
            const status = yield* exports.packageImportsExports(subpath, packageExports, packageURL, false, opts);
            if (status) return status;
        }
    }
    packageURL = new URL('package.json', packageURL);
    throw errors.PACKAGE_PATH_NOT_EXPORTED(`Package subpath '${subpath}' is not defined by "exports" in '${packageURL}'`);
};
exports.packageImports = function*(specifier, parentURL, opts = {}) {
    const { imports = null } = opts;
    if (specifier === '#' || specifier.startsWith('#/')) {
        throw errors.INVALID_MODULE_SPECIFIER(`Module specifier '${specifier}' is not a valid internal imports specifier`);
    }
    for (const packageURL of exports.lookupPackageScope(parentURL, opts)){
        const info = yield {
            package: packageURL
        };
        if (info) {
            if (info.imports) {
                const status = yield* exports.packageImportsExports(specifier, info.imports, packageURL, true, opts);
                if (status) return status;
            }
            if (specifier.startsWith('#')) {
                throw errors.PACKAGE_IMPORT_NOT_DEFINED(`Package import specifier '${specifier}' is not defined by "imports" in '${packageURL}'`);
            }
            break;
        }
    }
    if (imports) {
        const status = yield* exports.packageImportsExports(specifier, imports, parentURL, true, opts);
        if (status) return status;
    }
    return UNRESOLVED;
};
exports.packageImportsExports = function*(matchKey, matchObject, packageURL, isImports, opts = {}) {
    if (matchKey in matchObject && !matchKey.includes('*')) {
        const target = matchObject[matchKey];
        return yield* exports.packageTarget(packageURL, target, null, isImports, opts);
    }
    const expansionKeys = Object.keys(matchObject).filter((key)=>key.includes('*')).sort(exports.patternKeyCompare);
    for (const expansionKey of expansionKeys){
        const patternIndex = expansionKey.indexOf('*');
        const patternBase = expansionKey.substring(0, patternIndex);
        if (matchKey.startsWith(patternBase) && matchKey !== patternBase) {
            const patternTrailer = expansionKey.substring(patternIndex + 1);
            if (patternTrailer === '' || matchKey.endsWith(patternTrailer) && matchKey.length >= expansionKey.length) {
                const target = matchObject[expansionKey];
                const patternMatch = matchKey.substring(patternBase.length, matchKey.length - patternTrailer.length);
                return yield* exports.packageTarget(packageURL, target, patternMatch, isImports, opts);
            }
        }
    }
    return UNRESOLVED;
};
exports.validateEngines = function validateEngines(packageURL, packageEngines, opts = {}) {
    const { engines = {} } = opts;
    for (const [engine, range] of Object.entries(packageEngines)){
        if (engine in engines) {
            const version = engines[engine];
            if (!satisfies(version, range)) {
                packageURL = new URL('package.json', packageURL);
                throw errors.UNSUPPORTED_ENGINE(`Package not compatible with engine '${engine}' ${version}, requires range '${range}' defined by "engines" in '${packageURL}'`);
            }
        }
    }
};
exports.patternKeyCompare = function patternKeyCompare(keyA, keyB) {
    const patternIndexA = keyA.indexOf('*');
    const patternIndexB = keyB.indexOf('*');
    const baseLengthA = patternIndexA === -1 ? keyA.length : patternIndexA + 1;
    const baseLengthB = patternIndexB === -1 ? keyB.length : patternIndexB + 1;
    if (baseLengthA > baseLengthB) return -1;
    if (baseLengthB > baseLengthA) return 1;
    if (patternIndexA === -1) return 1;
    if (patternIndexB === -1) return -1;
    if (keyA.length > keyB.length) return -1;
    if (keyB.length > keyA.length) return 1;
    return 0;
};
exports.packageTarget = function*(packageURL, target, patternMatch, isImports, opts = {}) {
    const { conditions = [], matchedConditions = [] } = opts;
    if (typeof target === 'string') {
        if (!target.startsWith('./') && !isImports) {
            packageURL = new URL('package.json', packageURL);
            throw errors.INVALID_PACKAGE_TARGET(`Invalid target '${target}' defined by "exports" in '${packageURL}'`);
        }
        if (patternMatch !== null) {
            target = target.replaceAll('*', patternMatch);
        }
        const status = yield* exports.url(target, packageURL, opts);
        if (status) return status;
        if (target === '.' || target === '..' || target[0] === '/' || target.startsWith('./') || target.startsWith('../')) {
            const resolved = yield {
                resolution: new URL(target, packageURL)
            };
            return resolved ? RESOLVED : YIELDED;
        }
        return yield* exports.package(target, packageURL, opts);
    }
    if (Array.isArray(target)) {
        for (const targetValue of target){
            const status = yield* exports.packageTarget(packageURL, targetValue, patternMatch, isImports, opts);
            if (status) return status;
        }
    } else if (typeof target === 'object' && target !== null) {
        let status = UNRESOLVED;
        for (const [condition, targetValue, subset] of exports.conditionMatches(target, conditions, opts)){
            matchedConditions.push(condition);
            status |= yield* exports.packageTarget(packageURL, targetValue, patternMatch, isImports, {
                ...opts,
                conditions: subset
            });
            matchedConditions.pop();
        }
        if (status) return status;
    }
    return UNRESOLVED;
};
exports.builtinTarget = function*(packageSpecifier, packageVersion, target, opts = {}) {
    const { builtinProtocol = 'builtin:', conditions = [], matchedConditions = [] } = opts;
    if (typeof target === 'string') {
        const targetParts = target.split('@');
        let targetName;
        let targetVersion;
        if (target[0] !== '@') {
            targetName = targetParts[0];
            targetVersion = targetParts[1] || null;
        } else {
            targetName = targetParts.slice(0, 2).join('@');
            targetVersion = targetParts[2] || null;
        }
        if (packageSpecifier === targetName) {
            if (packageVersion === null && targetVersion === null) {
                const resolved = yield {
                    resolution: new URL(builtinProtocol + packageSpecifier)
                };
                return resolved ? RESOLVED : YIELDED;
            }
            let version = null;
            if (packageVersion === null) {
                version = targetVersion;
            } else if (targetVersion === null || packageVersion === targetVersion) {
                version = packageVersion;
            }
            if (version !== null) {
                const resolved = yield {
                    resolution: new URL(builtinProtocol + packageSpecifier + '@' + version)
                };
                return resolved ? RESOLVED : YIELDED;
            }
        }
    } else if (Array.isArray(target)) {
        for (const targetValue of target){
            const status = yield* exports.builtinTarget(packageSpecifier, packageVersion, targetValue, opts);
            if (status) return status;
        }
    } else if (typeof target === 'object' && target !== null) {
        let status = UNRESOLVED;
        for (const [condition, targetValue, subset] of exports.conditionMatches(target, conditions, opts)){
            matchedConditions.push(condition);
            status |= yield* exports.builtinTarget(packageSpecifier, packageVersion, targetValue, {
                ...opts,
                conditions: subset
            });
            matchedConditions.pop();
        }
        if (status) return status;
    }
    return UNRESOLVED;
};
exports.conditionMatches = function* conditionMatches(target, conditions, opts = {}) {
    if (conditions.every((condition)=>typeof condition === 'string')) {
        const keys = Object.keys(target);
        for (const condition of keys){
            if (condition === 'default' || conditions.includes(condition)) {
                yield [
                    condition,
                    target[condition],
                    conditions
                ];
                return true;
            }
        }
        return false;
    }
    let yielded = false;
    for (const subset of conditions){
        if (yield* conditionMatches(target, subset, opts)) {
            yielded = true;
        }
    }
    return yielded;
};
exports.lookupPackageScope = function* lookupPackageScope(url, opts = {}) {
    const { resolutions = null } = opts;
    if (resolutions) {
        for (const { resolution } of exports.preresolved('#package', resolutions, url, opts)){
            if (resolution) return yield resolution;
        }
    }
    const scopeURL = new URL(url.href);
    do {
        if (scopeURL.pathname.endsWith('/node_modules')) break;
        yield new URL('package.json', scopeURL);
        scopeURL.pathname = scopeURL.pathname.substring(0, scopeURL.pathname.lastIndexOf('/'));
        if (scopeURL.pathname.length === 3 && exports.isWindowsDriveLetter(scopeURL.pathname.substring(1))) {
            break;
        }
    }while (scopeURL.pathname !== '' && scopeURL.pathname !== '/')
};
exports.file = function*(filename, parentURL, isIndex, opts = {}) {
    if (filename === '.' || filename === '..' || filename[filename.length - 1] === '/' || filename[filename.length - 1] === '\\') {
        return UNRESOLVED;
    }
    if (parentURL.protocol === 'file:' && /%2f|%5c/i.test(filename)) {
        throw errors.INVALID_MODULE_SPECIFIER(`Module specifier '${filename}' is invalid`);
    }
    const { extensions = [] } = opts;
    let status = UNRESOLVED;
    if (!isIndex) {
        if (yield {
            resolution: new URL(filename, parentURL)
        }) {
            return RESOLVED;
        }
        status = YIELDED;
    }
    for (const ext of extensions){
        if (yield {
            resolution: new URL(filename + ext, parentURL)
        }) {
            return RESOLVED;
        }
        status = YIELDED;
    }
    return status;
};
exports.directory = function*(dirname, parentURL, opts = {}) {
    let directoryURL;
    if (dirname[dirname.length - 1] === '/' || dirname[dirname.length - 1] === '\\') {
        directoryURL = new URL(dirname, parentURL);
    } else {
        directoryURL = new URL(dirname + '/', parentURL);
    }
    const info = yield {
        package: new URL('package.json', directoryURL)
    };
    if (info) {
        if (info.exports) {
            return yield* exports.packageExports(directoryURL, '.', info.exports, opts);
        }
        if (typeof info.main === 'string' && info.main !== '') {
            const status = yield* exports.file(info.main, directoryURL, false, opts);
            if (status === RESOLVED) return status;
            return yield* exports.directory(info.main, directoryURL, opts);
        }
    }
    return yield* exports.file('index', directoryURL, true, opts);
};
// https://infra.spec.whatwg.org/#ascii-upper-alpha
function isASCIIUpperAlpha(c) {
    return c >= 0x41 && c <= 0x5a;
}
// https://infra.spec.whatwg.org/#ascii-lower-alpha
function isASCIILowerAlpha(c) {
    return c >= 0x61 && c <= 0x7a;
}
// https://infra.spec.whatwg.org/#ascii-alpha
function isASCIIAlpha(c) {
    return isASCIIUpperAlpha(c) || isASCIILowerAlpha(c);
}
// https://url.spec.whatwg.org/#windows-drive-letter
exports.isWindowsDriveLetter = function isWindowsDriveLetter(input) {
    return input.length >= 2 && isASCIIAlpha(input.charCodeAt(0)) && (input.charCodeAt(1) === 0x3a || input.charCodeAt(1) === 0x7c);
};
// https://url.spec.whatwg.org/#start-with-a-windows-drive-letter
exports.startsWithWindowsDriveLetter = function startsWithWindowsDriveLetter(input) {
    return input.length >= 2 && exports.isWindowsDriveLetter(input) && (input.length === 2 || input.charCodeAt(2) === 0x2f || input.charCodeAt(2) === 0x5c || input.charCodeAt(2) === 0x3f || input.charCodeAt(2) === 0x23);
};
}),
"[project]/node_modules/bare-addon-resolve/lib/errors.js [app-ssr] (ecmascript)", ((__turbopack_context__, module, exports) => {

module.exports = class AddonResolveError extends Error {
    constructor(msg, code, fn = AddonResolveError){
        super(`${code}: ${msg}`);
        this.code = code;
        if (Error.captureStackTrace) {
            Error.captureStackTrace(this, fn);
        }
    }
    get name() {
        return 'AddonResolveError';
    }
    static INVALID_ADDON_SPECIFIER(msg) {
        return new AddonResolveError(msg, 'INVALID_ADDON_SPECIFIER', AddonResolveError.INVALID_ADDON_SPECIFIER);
    }
    static INVALID_PACKAGE_NAME(msg) {
        return new AddonResolveError(msg, 'INVALID_PACKAGE_NAME', AddonResolveError.INVALID_PACKAGE_NAME);
    }
};
}),
"[project]/node_modules/bare-addon-resolve/index.js [app-ssr] (ecmascript)", ((__turbopack_context__, module, exports) => {

const resolve = __turbopack_context__.r("[project]/node_modules/bare-module-resolve/index.js [app-ssr] (ecmascript)");
const { Version } = __turbopack_context__.r("[project]/node_modules/bare-semver/index.js [app-ssr] (ecmascript)");
const errors = __turbopack_context__.r("[project]/node_modules/bare-addon-resolve/lib/errors.js [app-ssr] (ecmascript)");
module.exports = exports = function resolve(specifier, parentURL, opts, readPackage) {
    if (typeof opts === 'function') {
        readPackage = opts;
        opts = {};
    } else if (typeof readPackage !== 'function') {
        readPackage = defaultReadPackage;
    }
    return {
        *[Symbol.iterator] () {
            const generator = exports.addon(specifier, parentURL, opts);
            let next = generator.next();
            while(next.done !== true){
                const value = next.value;
                if (value.package) {
                    next = generator.next(readPackage(value.package));
                } else {
                    next = generator.next((yield value.resolution));
                }
            }
            return next.value;
        },
        async *[Symbol.asyncIterator] () {
            const generator = exports.addon(specifier, parentURL, opts);
            let next = generator.next();
            while(next.done !== true){
                const value = next.value;
                if (value.package) {
                    next = generator.next(await readPackage(value.package));
                } else {
                    next = generator.next((yield value.resolution));
                }
            }
            return next.value;
        }
    };
};
function defaultReadPackage() {
    return null;
}
const { UNRESOLVED, YIELDED, RESOLVED } = resolve.constants;
exports.constants = {
    UNRESOLVED,
    YIELDED,
    RESOLVED
};
exports.addon = function*(specifier, parentURL, opts = {}) {
    const { resolutions = null } = opts;
    if (exports.startsWithWindowsDriveLetter(specifier)) {
        specifier = '/' + specifier;
    }
    let status;
    if (resolutions) {
        status = yield* resolve.preresolved(specifier, resolutions, parentURL, opts);
        if (status) return status;
    }
    status = yield* exports.url(specifier, parentURL, opts);
    if (status) return status;
    let version = null;
    const i = specifier.lastIndexOf('@');
    if (i > 0) {
        version = specifier.substring(i + 1);
        try {
            Version.parse(version);
            specifier = specifier.substring(0, i);
        } catch  {
            version = null;
        }
    }
    if (specifier === '.' || specifier === '..' || specifier[0] === '/' || specifier[0] === '\\' || specifier.startsWith('./') || specifier.startsWith('.\\') || specifier.startsWith('../') || specifier.startsWith('..\\')) {
        return yield* exports.directory(specifier, version, parentURL, opts);
    }
    return yield* exports.package(specifier, version, parentURL, opts);
};
exports.url = function*(url, parentURL, opts = {}) {
    let resolution;
    try {
        resolution = new URL(url);
    } catch  {
        return UNRESOLVED;
    }
    const resolved = yield {
        resolution
    };
    return resolved ? RESOLVED : YIELDED;
};
exports.package = function*(packageSpecifier, packageVersion, parentURL, opts = {}) {
    if (packageSpecifier === '') {
        throw errors.INVALID_ADDON_SPECIFIER(`Addon specifier '${packageSpecifier}' is not a valid package name`);
    }
    let packageName;
    if (packageSpecifier[0] !== '@') {
        packageName = packageSpecifier.split('/', 1).join();
    } else {
        if (!packageSpecifier.includes('/')) {
            throw errors.INVALID_ADDON_SPECIFIER(`Addon specifier '${packageSpecifier}' is not a valid package name`);
        }
        packageName = packageSpecifier.split('/', 2).join('/');
    }
    if (packageName[0] === '.' || packageName.includes('\\') || packageName.includes('%')) {
        throw errors.INVALID_ADDON_SPECIFIER(`Addon specifier '${packageSpecifier}' is not a valid package name`);
    }
    const packageSubpath = '.' + packageSpecifier.substring(packageName.length);
    const status = yield* exports.packageSelf(packageName, packageSubpath, packageVersion, parentURL, opts);
    if (status) return status;
    parentURL = new URL(parentURL.href);
    do {
        const packageURL = new URL('node_modules/' + packageName + '/', parentURL);
        parentURL.pathname = parentURL.pathname.substring(0, parentURL.pathname.lastIndexOf('/'));
        const info = yield {
            package: new URL('package.json', packageURL)
        };
        if (info) {
            return yield* exports.directory(packageSubpath, packageVersion, packageURL, opts);
        }
    }while (parentURL.pathname !== '' && parentURL.pathname !== '/')
    return UNRESOLVED;
};
exports.packageSelf = function*(packageName, packageSubpath, packageVersion, parentURL, opts = {}) {
    for (const packageURL of resolve.lookupPackageScope(parentURL, opts)){
        const info = yield {
            package: packageURL
        };
        if (info) {
            if (info.name === packageName) {
                return yield* exports.directory(packageSubpath, packageVersion, packageURL, opts);
            }
            break;
        }
    }
    return UNRESOLVED;
};
exports.lookupPrebuildsScope = function* lookupPrebuildsScope(url, opts = {}) {
    const { resolutions = null } = opts;
    if (resolutions) {
        for (const { resolution } of resolve.preresolved('#prebuilds', resolutions, url, opts)){
            if (resolution) return yield resolution;
        }
    }
    const scopeURL = new URL(url.href);
    do {
        yield new URL('prebuilds/', scopeURL);
        scopeURL.pathname = scopeURL.pathname.substring(0, scopeURL.pathname.lastIndexOf('/'));
        if (scopeURL.pathname.length === 3 && exports.isWindowsDriveLetter(scopeURL.pathname.substring(1))) {
            break;
        }
    }while (scopeURL.pathname !== '' && scopeURL.pathname !== '/')
};
exports.file = function*(filename, parentURL, opts = {}) {
    if (parentURL.protocol === 'file:' && /%2f|%5c/i.test(filename)) {
        throw errors.INVALID_ADDON_SPECIFIER(`Addon specifier '${filename}' is invalid`);
    }
    const { extensions = [] } = opts;
    let status = UNRESOLVED;
    for (const ext of extensions){
        if (yield {
            resolution: new URL(filename + ext, parentURL)
        }) {
            return RESOLVED;
        }
        status = YIELDED;
    }
    return status;
};
exports.directory = function*(dirname, version, parentURL, opts = {}) {
    const { host = null, hosts = host !== null ? [
        host
    ] : [], builtins = [], matchedConditions = [] } = opts;
    let directoryURL;
    if (dirname[dirname.length - 1] === '/' || dirname[dirname.length - 1] === '\\') {
        directoryURL = new URL(dirname, parentURL);
    } else {
        directoryURL = new URL(dirname + '/', parentURL);
    }
    const unversioned = version === null;
    let name = null;
    const info = yield {
        package: new URL('package.json', directoryURL)
    };
    if (info) {
        if (typeof info.name === 'string' && info.name !== '') {
            if (info.name.includes('__')) {
                throw errors.INVALID_PACKAGE_NAME(`Package name '${info.name}' is invalid`);
            }
            name = info.name.replace(/\//g, '__').replace(/^@/, '');
        } else {
            return UNRESOLVED;
        }
        if (typeof info.version === 'string' && info.version !== '') {
            if (version !== null && info.version !== version) return UNRESOLVED;
            version = info.version;
        }
    } else {
        return UNRESOLVED;
    }
    let status;
    status = yield* resolve.builtinTarget(name, version, builtins, opts);
    if (status) return status;
    for (const prebuildsURL of exports.lookupPrebuildsScope(directoryURL, opts)){
        status = UNRESOLVED;
        for (const host of hosts){
            const conditions = host.split('-');
            matchedConditions.push(...conditions);
            if (version !== null) {
                status |= yield* exports.file(host + '/' + name + '@' + version, prebuildsURL, opts);
            }
            if (unversioned) {
                status |= yield* exports.file(host + '/' + name, prebuildsURL, opts);
            }
            for (const _ of conditions)matchedConditions.pop();
        }
        if (status === RESOLVED) return status;
    }
    return yield* exports.linked(name, version, opts);
};
exports.linked = function*(name, version = null, opts = {}) {
    const { linked = true, host = null, hosts = host !== null ? [
        host
    ] : [], matchedConditions = [] } = opts;
    if (linked === false || hosts.length === 0) return UNRESOLVED;
    let status = UNRESOLVED;
    for (const host of hosts){
        const [platform = null] = host.split('-', 1);
        if (platform === null) continue;
        matchedConditions.push(platform);
        status |= yield* platformArtefact(name, version, platform, opts);
        matchedConditions.pop();
    }
    return status;
};
function* platformArtefact(name, version = null, platform, opts = {}) {
    const { linkedProtocol = 'linked:' } = opts;
    if (platform === 'darwin' || platform === 'ios') {
        if (version !== null) {
            if (yield {
                resolution: new URL(`${linkedProtocol}${name}.${version}.framework/${name}.${version}`)
            }) {
                return RESOLVED;
            }
            if (platform === 'darwin') {
                if (yield {
                    resolution: new URL(`${linkedProtocol}lib${name}.${version}.dylib`)
                }) {
                    return RESOLVED;
                }
            }
        }
        if (yield {
            resolution: new URL(`${linkedProtocol}${name}.framework/${name}`)
        }) {
            return RESOLVED;
        }
        if (platform === 'darwin') {
            if (yield {
                resolution: new URL(`${linkedProtocol}lib${name}.dylib`)
            }) {
                return RESOLVED;
            }
        }
        return YIELDED;
    }
    if (platform === 'linux' || platform === 'android') {
        if (version !== null) {
            if (yield {
                resolution: new URL(`${linkedProtocol}lib${name}.${version}.so`)
            }) {
                return RESOLVED;
            }
        }
        if (yield {
            resolution: new URL(`${linkedProtocol}lib${name}.so`)
        }) {
            return RESOLVED;
        }
        return YIELDED;
    }
    if (platform === 'win32') {
        if (version !== null) {
            if (yield {
                resolution: new URL(`${linkedProtocol}${name}-${version}.dll`)
            }) {
                return RESOLVED;
            }
        }
        if (yield {
            resolution: new URL(`${linkedProtocol}${name}.dll`)
        }) {
            return RESOLVED;
        }
    }
    return UNRESOLVED;
}
exports.isWindowsDriveLetter = resolve.isWindowsDriveLetter;
exports.startsWithWindowsDriveLetter = resolve.startsWithWindowsDriveLetter;
}),
"[project]/node_modules/sodium-native/index.js [app-ssr] (ecmascript)", ((__turbopack_context__, module, exports) => {

/*TURBOPACK member replacement*/ __turbopack_context__.t.addon = __turbopack_context__.r("[project]/node_modules/require-addon/index.js [app-ssr] (ecmascript)");
module.exports = /*TURBOPACK member replacement*/ __turbopack_context__.t.addon('.', ("TURBOPACK compile-time value", "/ROOT/node_modules/sodium-native/index.js"));
}),
"[project]/node_modules/base32.js/base32.js [app-ssr] (ecmascript)", ((__turbopack_context__, module, exports) => {
"use strict";

/**
 * Generate a character map.
 * @param {string} alphabet e.g. "ABCDEFGHIJKLMNOPQRSTUVWXYZ234567"
 * @param {object} mappings map overrides from key to value
 * @method
 */ var charmap = function(alphabet, mappings) {
    mappings || (mappings = {});
    alphabet.split("").forEach(function(c, i) {
        if (!(c in mappings)) mappings[c] = i;
    });
    return mappings;
};
/**
 * The RFC 4648 base 32 alphabet and character map.
 * @see {@link https://tools.ietf.org/html/rfc4648}
 */ var rfc4648 = {
    alphabet: "ABCDEFGHIJKLMNOPQRSTUVWXYZ234567",
    charmap: {
        0: 14,
        1: 8
    }
};
rfc4648.charmap = charmap(rfc4648.alphabet, rfc4648.charmap);
/**
 * The Crockford base 32 alphabet and character map.
 * @see {@link http://www.crockford.com/wrmg/base32.html}
 */ var crockford = {
    alphabet: "0123456789ABCDEFGHJKMNPQRSTVWXYZ",
    charmap: {
        O: 0,
        I: 1,
        L: 1
    }
};
crockford.charmap = charmap(crockford.alphabet, crockford.charmap);
/**
 * base32hex
 * @see {@link https://en.wikipedia.org/wiki/Base32#base32hex}
 */ var base32hex = {
    alphabet: "0123456789ABCDEFGHIJKLMNOPQRSTUV",
    charmap: {}
};
base32hex.charmap = charmap(base32hex.alphabet, base32hex.charmap);
/**
 * Create a new `Decoder` with the given options.
 *
 * @param {object} [options]
 *   @param {string} [type] Supported Base-32 variants are "rfc4648" and
 *     "crockford".
 *   @param {object} [charmap] Override the character map used in decoding.
 * @constructor
 */ function Decoder(options) {
    this.buf = [];
    this.shift = 8;
    this.carry = 0;
    if (options) {
        switch(options.type){
            case "rfc4648":
                this.charmap = exports.rfc4648.charmap;
                break;
            case "crockford":
                this.charmap = exports.crockford.charmap;
                break;
            case "base32hex":
                this.charmap = exports.base32hex.charmap;
                break;
            default:
                throw new Error("invalid type");
        }
        if (options.charmap) this.charmap = options.charmap;
    }
}
/**
 * The default character map coresponds to RFC4648.
 */ Decoder.prototype.charmap = rfc4648.charmap;
/**
 * Decode a string, continuing from the previous state.
 *
 * @param {string} str
 * @return {Decoder} this
 */ Decoder.prototype.write = function(str) {
    var charmap = this.charmap;
    var buf = this.buf;
    var shift = this.shift;
    var carry = this.carry;
    // decode string
    str.toUpperCase().split("").forEach(function(char) {
        // ignore padding
        if (char == "=") return;
        // lookup symbol
        var symbol = charmap[char] & 0xff;
        // 1: 00000 000
        // 2:          00 00000 0
        // 3:                    0000 0000
        // 4:                             0 00000 00
        // 5:                                       000 00000
        // 6:                                                00000 000
        // 7:                                                         00 00000 0
        shift -= 5;
        if (shift > 0) {
            carry |= symbol << shift;
        } else if (shift < 0) {
            buf.push(carry | symbol >> -shift);
            shift += 8;
            carry = symbol << shift & 0xff;
        } else {
            buf.push(carry | symbol);
            shift = 8;
            carry = 0;
        }
    });
    // save state
    this.shift = shift;
    this.carry = carry;
    // for chaining
    return this;
};
/**
 * Finish decoding.
 *
 * @param {string} [str] The final string to decode.
 * @return {Array} Decoded byte array.
 */ Decoder.prototype.finalize = function(str) {
    if (str) {
        this.write(str);
    }
    if (this.shift !== 8 && this.carry !== 0) {
        this.buf.push(this.carry);
        this.shift = 8;
        this.carry = 0;
    }
    return this.buf;
};
/**
 * Create a new `Encoder` with the given options.
 *
 * @param {object} [options]
 *   @param {string} [type] Supported Base-32 variants are "rfc4648" and
 *     "crockford".
 *   @param {object} [alphabet] Override the alphabet used in encoding.
 * @constructor
 */ function Encoder(options) {
    this.buf = "";
    this.shift = 3;
    this.carry = 0;
    if (options) {
        switch(options.type){
            case "rfc4648":
                this.alphabet = exports.rfc4648.alphabet;
                break;
            case "crockford":
                this.alphabet = exports.crockford.alphabet;
                break;
            case "base32hex":
                this.alphabet = exports.base32hex.alphabet;
                break;
            default:
                throw new Error("invalid type");
        }
        if (options.alphabet) this.alphabet = options.alphabet;
        else if (options.lc) this.alphabet = this.alphabet.toLowerCase();
    }
}
/**
 * The default alphabet coresponds to RFC4648.
 */ Encoder.prototype.alphabet = rfc4648.alphabet;
/**
 * Encode a byte array, continuing from the previous state.
 *
 * @param {byte[]} buf The byte array to encode.
 * @return {Encoder} this
 */ Encoder.prototype.write = function(buf) {
    var shift = this.shift;
    var carry = this.carry;
    var symbol;
    var byte;
    var i;
    // encode each byte in buf
    for(i = 0; i < buf.length; i++){
        byte = buf[i];
        // 1: 00000 000
        // 2:          00 00000 0
        // 3:                    0000 0000
        // 4:                             0 00000 00
        // 5:                                       000 00000
        // 6:                                                00000 000
        // 7:                                                         00 00000 0
        symbol = carry | byte >> shift;
        this.buf += this.alphabet[symbol & 0x1f];
        if (shift > 5) {
            shift -= 5;
            symbol = byte >> shift;
            this.buf += this.alphabet[symbol & 0x1f];
        }
        shift = 5 - shift;
        carry = byte << shift;
        shift = 8 - shift;
    }
    // save state
    this.shift = shift;
    this.carry = carry;
    // for chaining
    return this;
};
/**
 * Finish encoding.
 *
 * @param {byte[]} [buf] The final byte array to encode.
 * @return {string} The encoded byte array.
 */ Encoder.prototype.finalize = function(buf) {
    if (buf) {
        this.write(buf);
    }
    if (this.shift !== 3) {
        this.buf += this.alphabet[this.carry & 0x1f];
        this.shift = 3;
        this.carry = 0;
    }
    return this.buf;
};
/**
 * Convenience encoder.
 *
 * @param {byte[]} buf The byte array to encode.
 * @param {object} [options] Options to pass to the encoder.
 * @return {string} The encoded string.
 */ exports.encode = function(buf, options) {
    return new Encoder(options).finalize(buf);
};
/**
 * Convenience decoder.
 *
 * @param {string} str The string to decode.
 * @param {object} [options] Options to pass to the decoder.
 * @return {byte[]} The decoded byte array.
 */ exports.decode = function(str, options) {
    return new Decoder(options).finalize(str);
};
// Exports.
exports.Decoder = Decoder;
exports.Encoder = Encoder;
exports.charmap = charmap;
exports.crockford = crockford;
exports.rfc4648 = rfc4648;
exports.base32hex = base32hex;
}),
"[project]/node_modules/base32.js/index.js [app-ssr] (ecmascript)", ((__turbopack_context__, module, exports) => {
"use strict";

// Module dependencies.
var base32 = __turbopack_context__.r("[project]/node_modules/base32.js/base32.js [app-ssr] (ecmascript)");
// Wrap decoder finalize to return a buffer;
var finalizeDecode = base32.Decoder.prototype.finalize;
base32.Decoder.prototype.finalize = function(buf) {
    var bytes = finalizeDecode.call(this, buf);
    return new Buffer(bytes);
};
// Export Base32.
module.exports = base32;
}),
"[project]/node_modules/bignumber.js/bignumber.js [app-ssr] (ecmascript)", ((__turbopack_context__, module, exports) => {

;
(function(globalObject) {
    'use strict';
    /*
 *      bignumber.js v9.3.1
 *      A JavaScript library for arbitrary-precision arithmetic.
 *      https://github.com/MikeMcl/bignumber.js
 *      Copyright (c) 2025 Michael Mclaughlin <M8ch88l@gmail.com>
 *      MIT Licensed.
 *
 *      BigNumber.prototype methods     |  BigNumber methods
 *                                      |
 *      absoluteValue            abs    |  clone
 *      comparedTo                      |  config               set
 *      decimalPlaces            dp     |      DECIMAL_PLACES
 *      dividedBy                div    |      ROUNDING_MODE
 *      dividedToIntegerBy       idiv   |      EXPONENTIAL_AT
 *      exponentiatedBy          pow    |      RANGE
 *      integerValue                    |      CRYPTO
 *      isEqualTo                eq     |      MODULO_MODE
 *      isFinite                        |      POW_PRECISION
 *      isGreaterThan            gt     |      FORMAT
 *      isGreaterThanOrEqualTo   gte    |      ALPHABET
 *      isInteger                       |  isBigNumber
 *      isLessThan               lt     |  maximum              max
 *      isLessThanOrEqualTo      lte    |  minimum              min
 *      isNaN                           |  random
 *      isNegative                      |  sum
 *      isPositive                      |
 *      isZero                          |
 *      minus                           |
 *      modulo                   mod    |
 *      multipliedBy             times  |
 *      negated                         |
 *      plus                            |
 *      precision                sd     |
 *      shiftedBy                       |
 *      squareRoot               sqrt   |
 *      toExponential                   |
 *      toFixed                         |
 *      toFormat                        |
 *      toFraction                      |
 *      toJSON                          |
 *      toNumber                        |
 *      toPrecision                     |
 *      toString                        |
 *      valueOf                         |
 *
 */ var BigNumber, isNumeric = /^-?(?:\d+(?:\.\d*)?|\.\d+)(?:e[+-]?\d+)?$/i, mathceil = Math.ceil, mathfloor = Math.floor, bignumberError = '[BigNumber Error] ', tooManyDigits = bignumberError + 'Number primitive has more than 15 significant digits: ', BASE = 1e14, LOG_BASE = 14, MAX_SAFE_INTEGER = 0x1fffffffffffff, // MAX_INT32 = 0x7fffffff,                   // 2^31 - 1
    POWS_TEN = [
        1,
        10,
        100,
        1e3,
        1e4,
        1e5,
        1e6,
        1e7,
        1e8,
        1e9,
        1e10,
        1e11,
        1e12,
        1e13
    ], SQRT_BASE = 1e7, // EDITABLE
    // The limit on the value of DECIMAL_PLACES, TO_EXP_NEG, TO_EXP_POS, MIN_EXP, MAX_EXP, and
    // the arguments to toExponential, toFixed, toFormat, and toPrecision.
    MAX = 1E9; // 0 to MAX_INT32
    /*
   * Create and return a BigNumber constructor.
   */ function clone(configObject) {
        var div, convertBase, parseNumeric, P = BigNumber.prototype = {
            constructor: BigNumber,
            toString: null,
            valueOf: null
        }, ONE = new BigNumber(1), //----------------------------- EDITABLE CONFIG DEFAULTS -------------------------------
        // The default values below must be integers within the inclusive ranges stated.
        // The values can also be changed at run-time using BigNumber.set.
        // The maximum number of decimal places for operations involving division.
        DECIMAL_PLACES = 20, // The rounding mode used when rounding to the above decimal places, and when using
        // toExponential, toFixed, toFormat and toPrecision, and round (default value).
        // UP         0 Away from zero.
        // DOWN       1 Towards zero.
        // CEIL       2 Towards +Infinity.
        // FLOOR      3 Towards -Infinity.
        // HALF_UP    4 Towards nearest neighbour. If equidistant, up.
        // HALF_DOWN  5 Towards nearest neighbour. If equidistant, down.
        // HALF_EVEN  6 Towards nearest neighbour. If equidistant, towards even neighbour.
        // HALF_CEIL  7 Towards nearest neighbour. If equidistant, towards +Infinity.
        // HALF_FLOOR 8 Towards nearest neighbour. If equidistant, towards -Infinity.
        ROUNDING_MODE = 4, // EXPONENTIAL_AT : [TO_EXP_NEG , TO_EXP_POS]
        // The exponent value at and beneath which toString returns exponential notation.
        // Number type: -7
        TO_EXP_NEG = -7, // The exponent value at and above which toString returns exponential notation.
        // Number type: 21
        TO_EXP_POS = 21, // RANGE : [MIN_EXP, MAX_EXP]
        // The minimum exponent value, beneath which underflow to zero occurs.
        // Number type: -324  (5e-324)
        MIN_EXP = -1e7, // The maximum exponent value, above which overflow to Infinity occurs.
        // Number type:  308  (1.7976931348623157e+308)
        // For MAX_EXP > 1e7, e.g. new BigNumber('1e100000000').plus(1) may be slow.
        MAX_EXP = 1e7, // Whether to use cryptographically-secure random number generation, if available.
        CRYPTO = false, // The modulo mode used when calculating the modulus: a mod n.
        // The quotient (q = a / n) is calculated according to the corresponding rounding mode.
        // The remainder (r) is calculated as: r = a - n * q.
        //
        // UP        0 The remainder is positive if the dividend is negative, else is negative.
        // DOWN      1 The remainder has the same sign as the dividend.
        //             This modulo mode is commonly known as 'truncated division' and is
        //             equivalent to (a % n) in JavaScript.
        // FLOOR     3 The remainder has the same sign as the divisor (Python %).
        // HALF_EVEN 6 This modulo mode implements the IEEE 754 remainder function.
        // EUCLID    9 Euclidian division. q = sign(n) * floor(a / abs(n)).
        //             The remainder is always positive.
        //
        // The truncated division, floored division, Euclidian division and IEEE 754 remainder
        // modes are commonly used for the modulus operation.
        // Although the other rounding modes can also be used, they may not give useful results.
        MODULO_MODE = 1, // The maximum number of significant digits of the result of the exponentiatedBy operation.
        // If POW_PRECISION is 0, there will be unlimited significant digits.
        POW_PRECISION = 0, // The format specification used by the BigNumber.prototype.toFormat method.
        FORMAT = {
            prefix: '',
            groupSize: 3,
            secondaryGroupSize: 0,
            groupSeparator: ',',
            decimalSeparator: '.',
            fractionGroupSize: 0,
            fractionGroupSeparator: '\xA0',
            suffix: ''
        }, // The alphabet used for base conversion. It must be at least 2 characters long, with no '+',
        // '-', '.', whitespace, or repeated character.
        // '0123456789abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ$_'
        ALPHABET = '0123456789abcdefghijklmnopqrstuvwxyz', alphabetHasNormalDecimalDigits = true;
        //------------------------------------------------------------------------------------------
        // CONSTRUCTOR
        /*
     * The BigNumber constructor and exported function.
     * Create and return a new instance of a BigNumber object.
     *
     * v {number|string|BigNumber} A numeric value.
     * [b] {number} The base of v. Integer, 2 to ALPHABET.length inclusive.
     */ function BigNumber(v, b) {
            var alphabet, c, caseChanged, e, i, isNum, len, str, x = this;
            // Enable constructor call without `new`.
            if (!(x instanceof BigNumber)) return new BigNumber(v, b);
            if (b == null) {
                if (v && v._isBigNumber === true) {
                    x.s = v.s;
                    if (!v.c || v.e > MAX_EXP) {
                        x.c = x.e = null;
                    } else if (v.e < MIN_EXP) {
                        x.c = [
                            x.e = 0
                        ];
                    } else {
                        x.e = v.e;
                        x.c = v.c.slice();
                    }
                    return;
                }
                if ((isNum = typeof v == 'number') && v * 0 == 0) {
                    // Use `1 / n` to handle minus zero also.
                    x.s = 1 / v < 0 ? (v = -v, -1) : 1;
                    // Fast path for integers, where n < 2147483648 (2**31).
                    if (v === ~~v) {
                        for(e = 0, i = v; i >= 10; i /= 10, e++);
                        if (e > MAX_EXP) {
                            x.c = x.e = null;
                        } else {
                            x.e = e;
                            x.c = [
                                v
                            ];
                        }
                        return;
                    }
                    str = String(v);
                } else {
                    if (!isNumeric.test(str = String(v))) return parseNumeric(x, str, isNum);
                    x.s = str.charCodeAt(0) == 45 ? (str = str.slice(1), -1) : 1;
                }
                // Decimal point?
                if ((e = str.indexOf('.')) > -1) str = str.replace('.', '');
                // Exponential form?
                if ((i = str.search(/e/i)) > 0) {
                    // Determine exponent.
                    if (e < 0) e = i;
                    e += +str.slice(i + 1);
                    str = str.substring(0, i);
                } else if (e < 0) {
                    // Integer.
                    e = str.length;
                }
            } else {
                // '[BigNumber Error] Base {not a primitive number|not an integer|out of range}: {b}'
                intCheck(b, 2, ALPHABET.length, 'Base');
                // Allow exponential notation to be used with base 10 argument, while
                // also rounding to DECIMAL_PLACES as with other bases.
                if (b == 10 && alphabetHasNormalDecimalDigits) {
                    x = new BigNumber(v);
                    return round(x, DECIMAL_PLACES + x.e + 1, ROUNDING_MODE);
                }
                str = String(v);
                if (isNum = typeof v == 'number') {
                    // Avoid potential interpretation of Infinity and NaN as base 44+ values.
                    if (v * 0 != 0) return parseNumeric(x, str, isNum, b);
                    x.s = 1 / v < 0 ? (str = str.slice(1), -1) : 1;
                    // '[BigNumber Error] Number primitive has more than 15 significant digits: {n}'
                    if (BigNumber.DEBUG && str.replace(/^0\.0*|\./, '').length > 15) {
                        throw Error(tooManyDigits + v);
                    }
                } else {
                    x.s = str.charCodeAt(0) === 45 ? (str = str.slice(1), -1) : 1;
                }
                alphabet = ALPHABET.slice(0, b);
                e = i = 0;
                // Check that str is a valid base b number.
                // Don't use RegExp, so alphabet can contain special characters.
                for(len = str.length; i < len; i++){
                    if (alphabet.indexOf(c = str.charAt(i)) < 0) {
                        if (c == '.') {
                            // If '.' is not the first character and it has not be found before.
                            if (i > e) {
                                e = len;
                                continue;
                            }
                        } else if (!caseChanged) {
                            // Allow e.g. hexadecimal 'FF' as well as 'ff'.
                            if (str == str.toUpperCase() && (str = str.toLowerCase()) || str == str.toLowerCase() && (str = str.toUpperCase())) {
                                caseChanged = true;
                                i = -1;
                                e = 0;
                                continue;
                            }
                        }
                        return parseNumeric(x, String(v), isNum, b);
                    }
                }
                // Prevent later check for length on converted number.
                isNum = false;
                str = convertBase(str, b, 10, x.s);
                // Decimal point?
                if ((e = str.indexOf('.')) > -1) str = str.replace('.', '');
                else e = str.length;
            }
            // Determine leading zeros.
            for(i = 0; str.charCodeAt(i) === 48; i++);
            // Determine trailing zeros.
            for(len = str.length; str.charCodeAt(--len) === 48;);
            if (str = str.slice(i, ++len)) {
                len -= i;
                // '[BigNumber Error] Number primitive has more than 15 significant digits: {n}'
                if (isNum && BigNumber.DEBUG && len > 15 && (v > MAX_SAFE_INTEGER || v !== mathfloor(v))) {
                    throw Error(tooManyDigits + x.s * v);
                }
                // Overflow?
                if ((e = e - i - 1) > MAX_EXP) {
                    // Infinity.
                    x.c = x.e = null;
                // Underflow?
                } else if (e < MIN_EXP) {
                    // Zero.
                    x.c = [
                        x.e = 0
                    ];
                } else {
                    x.e = e;
                    x.c = [];
                    // Transform base
                    // e is the base 10 exponent.
                    // i is where to slice str to get the first element of the coefficient array.
                    i = (e + 1) % LOG_BASE;
                    if (e < 0) i += LOG_BASE; // i < 1
                    if (i < len) {
                        if (i) x.c.push(+str.slice(0, i));
                        for(len -= LOG_BASE; i < len;){
                            x.c.push(+str.slice(i, i += LOG_BASE));
                        }
                        i = LOG_BASE - (str = str.slice(i)).length;
                    } else {
                        i -= len;
                    }
                    for(; i--; str += '0');
                    x.c.push(+str);
                }
            } else {
                // Zero.
                x.c = [
                    x.e = 0
                ];
            }
        }
        // CONSTRUCTOR PROPERTIES
        BigNumber.clone = clone;
        BigNumber.ROUND_UP = 0;
        BigNumber.ROUND_DOWN = 1;
        BigNumber.ROUND_CEIL = 2;
        BigNumber.ROUND_FLOOR = 3;
        BigNumber.ROUND_HALF_UP = 4;
        BigNumber.ROUND_HALF_DOWN = 5;
        BigNumber.ROUND_HALF_EVEN = 6;
        BigNumber.ROUND_HALF_CEIL = 7;
        BigNumber.ROUND_HALF_FLOOR = 8;
        BigNumber.EUCLID = 9;
        /*
     * Configure infrequently-changing library-wide settings.
     *
     * Accept an object with the following optional properties (if the value of a property is
     * a number, it must be an integer within the inclusive range stated):
     *
     *   DECIMAL_PLACES   {number}           0 to MAX
     *   ROUNDING_MODE    {number}           0 to 8
     *   EXPONENTIAL_AT   {number|number[]}  -MAX to MAX  or  [-MAX to 0, 0 to MAX]
     *   RANGE            {number|number[]}  -MAX to MAX (not zero)  or  [-MAX to -1, 1 to MAX]
     *   CRYPTO           {boolean}          true or false
     *   MODULO_MODE      {number}           0 to 9
     *   POW_PRECISION       {number}           0 to MAX
     *   ALPHABET         {string}           A string of two or more unique characters which does
     *                                       not contain '.'.
     *   FORMAT           {object}           An object with some of the following properties:
     *     prefix                 {string}
     *     groupSize              {number}
     *     secondaryGroupSize     {number}
     *     groupSeparator         {string}
     *     decimalSeparator       {string}
     *     fractionGroupSize      {number}
     *     fractionGroupSeparator {string}
     *     suffix                 {string}
     *
     * (The values assigned to the above FORMAT object properties are not checked for validity.)
     *
     * E.g.
     * BigNumber.config({ DECIMAL_PLACES : 20, ROUNDING_MODE : 4 })
     *
     * Ignore properties/parameters set to null or undefined, except for ALPHABET.
     *
     * Return an object with the properties current values.
     */ BigNumber.config = BigNumber.set = function(obj) {
            var p, v;
            if (obj != null) {
                if (typeof obj == 'object') {
                    // DECIMAL_PLACES {number} Integer, 0 to MAX inclusive.
                    // '[BigNumber Error] DECIMAL_PLACES {not a primitive number|not an integer|out of range}: {v}'
                    if (obj.hasOwnProperty(p = 'DECIMAL_PLACES')) {
                        v = obj[p];
                        intCheck(v, 0, MAX, p);
                        DECIMAL_PLACES = v;
                    }
                    // ROUNDING_MODE {number} Integer, 0 to 8 inclusive.
                    // '[BigNumber Error] ROUNDING_MODE {not a primitive number|not an integer|out of range}: {v}'
                    if (obj.hasOwnProperty(p = 'ROUNDING_MODE')) {
                        v = obj[p];
                        intCheck(v, 0, 8, p);
                        ROUNDING_MODE = v;
                    }
                    // EXPONENTIAL_AT {number|number[]}
                    // Integer, -MAX to MAX inclusive or
                    // [integer -MAX to 0 inclusive, 0 to MAX inclusive].
                    // '[BigNumber Error] EXPONENTIAL_AT {not a primitive number|not an integer|out of range}: {v}'
                    if (obj.hasOwnProperty(p = 'EXPONENTIAL_AT')) {
                        v = obj[p];
                        if (v && v.pop) {
                            intCheck(v[0], -MAX, 0, p);
                            intCheck(v[1], 0, MAX, p);
                            TO_EXP_NEG = v[0];
                            TO_EXP_POS = v[1];
                        } else {
                            intCheck(v, -MAX, MAX, p);
                            TO_EXP_NEG = -(TO_EXP_POS = v < 0 ? -v : v);
                        }
                    }
                    // RANGE {number|number[]} Non-zero integer, -MAX to MAX inclusive or
                    // [integer -MAX to -1 inclusive, integer 1 to MAX inclusive].
                    // '[BigNumber Error] RANGE {not a primitive number|not an integer|out of range|cannot be zero}: {v}'
                    if (obj.hasOwnProperty(p = 'RANGE')) {
                        v = obj[p];
                        if (v && v.pop) {
                            intCheck(v[0], -MAX, -1, p);
                            intCheck(v[1], 1, MAX, p);
                            MIN_EXP = v[0];
                            MAX_EXP = v[1];
                        } else {
                            intCheck(v, -MAX, MAX, p);
                            if (v) {
                                MIN_EXP = -(MAX_EXP = v < 0 ? -v : v);
                            } else {
                                throw Error(bignumberError + p + ' cannot be zero: ' + v);
                            }
                        }
                    }
                    // CRYPTO {boolean} true or false.
                    // '[BigNumber Error] CRYPTO not true or false: {v}'
                    // '[BigNumber Error] crypto unavailable'
                    if (obj.hasOwnProperty(p = 'CRYPTO')) {
                        v = obj[p];
                        if (v === !!v) {
                            if (v) {
                                if (typeof crypto != 'undefined' && crypto && (crypto.getRandomValues || crypto.randomBytes)) {
                                    CRYPTO = v;
                                } else {
                                    CRYPTO = !v;
                                    throw Error(bignumberError + 'crypto unavailable');
                                }
                            } else {
                                CRYPTO = v;
                            }
                        } else {
                            throw Error(bignumberError + p + ' not true or false: ' + v);
                        }
                    }
                    // MODULO_MODE {number} Integer, 0 to 9 inclusive.
                    // '[BigNumber Error] MODULO_MODE {not a primitive number|not an integer|out of range}: {v}'
                    if (obj.hasOwnProperty(p = 'MODULO_MODE')) {
                        v = obj[p];
                        intCheck(v, 0, 9, p);
                        MODULO_MODE = v;
                    }
                    // POW_PRECISION {number} Integer, 0 to MAX inclusive.
                    // '[BigNumber Error] POW_PRECISION {not a primitive number|not an integer|out of range}: {v}'
                    if (obj.hasOwnProperty(p = 'POW_PRECISION')) {
                        v = obj[p];
                        intCheck(v, 0, MAX, p);
                        POW_PRECISION = v;
                    }
                    // FORMAT {object}
                    // '[BigNumber Error] FORMAT not an object: {v}'
                    if (obj.hasOwnProperty(p = 'FORMAT')) {
                        v = obj[p];
                        if (typeof v == 'object') FORMAT = v;
                        else throw Error(bignumberError + p + ' not an object: ' + v);
                    }
                    // ALPHABET {string}
                    // '[BigNumber Error] ALPHABET invalid: {v}'
                    if (obj.hasOwnProperty(p = 'ALPHABET')) {
                        v = obj[p];
                        // Disallow if less than two characters,
                        // or if it contains '+', '-', '.', whitespace, or a repeated character.
                        if (typeof v == 'string' && !/^.?$|[+\-.\s]|(.).*\1/.test(v)) {
                            alphabetHasNormalDecimalDigits = v.slice(0, 10) == '0123456789';
                            ALPHABET = v;
                        } else {
                            throw Error(bignumberError + p + ' invalid: ' + v);
                        }
                    }
                } else {
                    // '[BigNumber Error] Object expected: {v}'
                    throw Error(bignumberError + 'Object expected: ' + obj);
                }
            }
            return {
                DECIMAL_PLACES: DECIMAL_PLACES,
                ROUNDING_MODE: ROUNDING_MODE,
                EXPONENTIAL_AT: [
                    TO_EXP_NEG,
                    TO_EXP_POS
                ],
                RANGE: [
                    MIN_EXP,
                    MAX_EXP
                ],
                CRYPTO: CRYPTO,
                MODULO_MODE: MODULO_MODE,
                POW_PRECISION: POW_PRECISION,
                FORMAT: FORMAT,
                ALPHABET: ALPHABET
            };
        };
        /*
     * Return true if v is a BigNumber instance, otherwise return false.
     *
     * If BigNumber.DEBUG is true, throw if a BigNumber instance is not well-formed.
     *
     * v {any}
     *
     * '[BigNumber Error] Invalid BigNumber: {v}'
     */ BigNumber.isBigNumber = function(v) {
            if (!v || v._isBigNumber !== true) return false;
            if (!BigNumber.DEBUG) return true;
            var i, n, c = v.c, e = v.e, s = v.s;
            out: if (({}).toString.call(c) == '[object Array]') {
                if ((s === 1 || s === -1) && e >= -MAX && e <= MAX && e === mathfloor(e)) {
                    // If the first element is zero, the BigNumber value must be zero.
                    if (c[0] === 0) {
                        if (e === 0 && c.length === 1) return true;
                        break out;
                    }
                    // Calculate number of digits that c[0] should have, based on the exponent.
                    i = (e + 1) % LOG_BASE;
                    if (i < 1) i += LOG_BASE;
                    // Calculate number of digits of c[0].
                    //if (Math.ceil(Math.log(c[0] + 1) / Math.LN10) == i) {
                    if (String(c[0]).length == i) {
                        for(i = 0; i < c.length; i++){
                            n = c[i];
                            if (n < 0 || n >= BASE || n !== mathfloor(n)) break out;
                        }
                        // Last element cannot be zero, unless it is the only element.
                        if (n !== 0) return true;
                    }
                }
            // Infinity/NaN
            } else if (c === null && e === null && (s === null || s === 1 || s === -1)) {
                return true;
            }
            throw Error(bignumberError + 'Invalid BigNumber: ' + v);
        };
        /*
     * Return a new BigNumber whose value is the maximum of the arguments.
     *
     * arguments {number|string|BigNumber}
     */ BigNumber.maximum = BigNumber.max = function() {
            return maxOrMin(arguments, -1);
        };
        /*
     * Return a new BigNumber whose value is the minimum of the arguments.
     *
     * arguments {number|string|BigNumber}
     */ BigNumber.minimum = BigNumber.min = function() {
            return maxOrMin(arguments, 1);
        };
        /*
     * Return a new BigNumber with a random value equal to or greater than 0 and less than 1,
     * and with dp, or DECIMAL_PLACES if dp is omitted, decimal places (or less if trailing
     * zeros are produced).
     *
     * [dp] {number} Decimal places. Integer, 0 to MAX inclusive.
     *
     * '[BigNumber Error] Argument {not a primitive number|not an integer|out of range}: {dp}'
     * '[BigNumber Error] crypto unavailable'
     */ BigNumber.random = function() {
            var pow2_53 = 0x20000000000000;
            // Return a 53 bit integer n, where 0 <= n < 9007199254740992.
            // Check if Math.random() produces more than 32 bits of randomness.
            // If it does, assume at least 53 bits are produced, otherwise assume at least 30 bits.
            // 0x40000000 is 2^30, 0x800000 is 2^23, 0x1fffff is 2^21 - 1.
            var random53bitInt = Math.random() * pow2_53 & 0x1fffff ? function() {
                return mathfloor(Math.random() * pow2_53);
            } : function() {
                return (Math.random() * 0x40000000 | 0) * 0x800000 + (Math.random() * 0x800000 | 0);
            };
            return function(dp) {
                var a, b, e, k, v, i = 0, c = [], rand = new BigNumber(ONE);
                if (dp == null) dp = DECIMAL_PLACES;
                else intCheck(dp, 0, MAX);
                k = mathceil(dp / LOG_BASE);
                if (CRYPTO) {
                    // Browsers supporting crypto.getRandomValues.
                    if (crypto.getRandomValues) {
                        a = crypto.getRandomValues(new Uint32Array(k *= 2));
                        for(; i < k;){
                            // 53 bits:
                            // ((Math.pow(2, 32) - 1) * Math.pow(2, 21)).toString(2)
                            // 11111 11111111 11111111 11111111 11100000 00000000 00000000
                            // ((Math.pow(2, 32) - 1) >>> 11).toString(2)
                            //                                     11111 11111111 11111111
                            // 0x20000 is 2^21.
                            v = a[i] * 0x20000 + (a[i + 1] >>> 11);
                            // Rejection sampling:
                            // 0 <= v < 9007199254740992
                            // Probability that v >= 9e15, is
                            // 7199254740992 / 9007199254740992 ~= 0.0008, i.e. 1 in 1251
                            if (v >= 9e15) {
                                b = crypto.getRandomValues(new Uint32Array(2));
                                a[i] = b[0];
                                a[i + 1] = b[1];
                            } else {
                                // 0 <= v <= 8999999999999999
                                // 0 <= (v % 1e14) <= 99999999999999
                                c.push(v % 1e14);
                                i += 2;
                            }
                        }
                        i = k / 2;
                    // Node.js supporting crypto.randomBytes.
                    } else if (crypto.randomBytes) {
                        // buffer
                        a = crypto.randomBytes(k *= 7);
                        for(; i < k;){
                            // 0x1000000000000 is 2^48, 0x10000000000 is 2^40
                            // 0x100000000 is 2^32, 0x1000000 is 2^24
                            // 11111 11111111 11111111 11111111 11111111 11111111 11111111
                            // 0 <= v < 9007199254740992
                            v = (a[i] & 31) * 0x1000000000000 + a[i + 1] * 0x10000000000 + a[i + 2] * 0x100000000 + a[i + 3] * 0x1000000 + (a[i + 4] << 16) + (a[i + 5] << 8) + a[i + 6];
                            if (v >= 9e15) {
                                crypto.randomBytes(7).copy(a, i);
                            } else {
                                // 0 <= (v % 1e14) <= 99999999999999
                                c.push(v % 1e14);
                                i += 7;
                            }
                        }
                        i = k / 7;
                    } else {
                        CRYPTO = false;
                        throw Error(bignumberError + 'crypto unavailable');
                    }
                }
                // Use Math.random.
                if (!CRYPTO) {
                    for(; i < k;){
                        v = random53bitInt();
                        if (v < 9e15) c[i++] = v % 1e14;
                    }
                }
                k = c[--i];
                dp %= LOG_BASE;
                // Convert trailing digits to zeros according to dp.
                if (k && dp) {
                    v = POWS_TEN[LOG_BASE - dp];
                    c[i] = mathfloor(k / v) * v;
                }
                // Remove trailing elements which are zero.
                for(; c[i] === 0; c.pop(), i--);
                // Zero?
                if (i < 0) {
                    c = [
                        e = 0
                    ];
                } else {
                    // Remove leading elements which are zero and adjust exponent accordingly.
                    for(e = -1; c[0] === 0; c.splice(0, 1), e -= LOG_BASE);
                    // Count the digits of the first element of c to determine leading zeros, and...
                    for(i = 1, v = c[0]; v >= 10; v /= 10, i++);
                    // adjust the exponent accordingly.
                    if (i < LOG_BASE) e -= LOG_BASE - i;
                }
                rand.e = e;
                rand.c = c;
                return rand;
            };
        }();
        /*
     * Return a BigNumber whose value is the sum of the arguments.
     *
     * arguments {number|string|BigNumber}
     */ BigNumber.sum = function() {
            var i = 1, args = arguments, sum = new BigNumber(args[0]);
            for(; i < args.length;)sum = sum.plus(args[i++]);
            return sum;
        };
        // PRIVATE FUNCTIONS
        // Called by BigNumber and BigNumber.prototype.toString.
        convertBase = function() {
            var decimal = '0123456789';
            /*
       * Convert string of baseIn to an array of numbers of baseOut.
       * Eg. toBaseOut('255', 10, 16) returns [15, 15].
       * Eg. toBaseOut('ff', 16, 10) returns [2, 5, 5].
       */ function toBaseOut(str, baseIn, baseOut, alphabet) {
                var j, arr = [
                    0
                ], arrL, i = 0, len = str.length;
                for(; i < len;){
                    for(arrL = arr.length; arrL--; arr[arrL] *= baseIn);
                    arr[0] += alphabet.indexOf(str.charAt(i++));
                    for(j = 0; j < arr.length; j++){
                        if (arr[j] > baseOut - 1) {
                            if (arr[j + 1] == null) arr[j + 1] = 0;
                            arr[j + 1] += arr[j] / baseOut | 0;
                            arr[j] %= baseOut;
                        }
                    }
                }
                return arr.reverse();
            }
            // Convert a numeric string of baseIn to a numeric string of baseOut.
            // If the caller is toString, we are converting from base 10 to baseOut.
            // If the caller is BigNumber, we are converting from baseIn to base 10.
            return function(str, baseIn, baseOut, sign, callerIsToString) {
                var alphabet, d, e, k, r, x, xc, y, i = str.indexOf('.'), dp = DECIMAL_PLACES, rm = ROUNDING_MODE;
                // Non-integer.
                if (i >= 0) {
                    k = POW_PRECISION;
                    // Unlimited precision.
                    POW_PRECISION = 0;
                    str = str.replace('.', '');
                    y = new BigNumber(baseIn);
                    x = y.pow(str.length - i);
                    POW_PRECISION = k;
                    // Convert str as if an integer, then restore the fraction part by dividing the
                    // result by its base raised to a power.
                    y.c = toBaseOut(toFixedPoint(coeffToString(x.c), x.e, '0'), 10, baseOut, decimal);
                    y.e = y.c.length;
                }
                // Convert the number as integer.
                xc = toBaseOut(str, baseIn, baseOut, callerIsToString ? (alphabet = ALPHABET, decimal) : (alphabet = decimal, ALPHABET));
                // xc now represents str as an integer and converted to baseOut. e is the exponent.
                e = k = xc.length;
                // Remove trailing zeros.
                for(; xc[--k] == 0; xc.pop());
                // Zero?
                if (!xc[0]) return alphabet.charAt(0);
                // Does str represent an integer? If so, no need for the division.
                if (i < 0) {
                    --e;
                } else {
                    x.c = xc;
                    x.e = e;
                    // The sign is needed for correct rounding.
                    x.s = sign;
                    x = div(x, y, dp, rm, baseOut);
                    xc = x.c;
                    r = x.r;
                    e = x.e;
                }
                // xc now represents str converted to baseOut.
                // The index of the rounding digit.
                d = e + dp + 1;
                // The rounding digit: the digit to the right of the digit that may be rounded up.
                i = xc[d];
                // Look at the rounding digits and mode to determine whether to round up.
                k = baseOut / 2;
                r = r || d < 0 || xc[d + 1] != null;
                r = rm < 4 ? (i != null || r) && (rm == 0 || rm == (x.s < 0 ? 3 : 2)) : i > k || i == k && (rm == 4 || r || rm == 6 && xc[d - 1] & 1 || rm == (x.s < 0 ? 8 : 7));
                // If the index of the rounding digit is not greater than zero, or xc represents
                // zero, then the result of the base conversion is zero or, if rounding up, a value
                // such as 0.00001.
                if (d < 1 || !xc[0]) {
                    // 1^-dp or 0
                    str = r ? toFixedPoint(alphabet.charAt(1), -dp, alphabet.charAt(0)) : alphabet.charAt(0);
                } else {
                    // Truncate xc to the required number of decimal places.
                    xc.length = d;
                    // Round up?
                    if (r) {
                        // Rounding up may mean the previous digit has to be rounded up and so on.
                        for(--baseOut; ++xc[--d] > baseOut;){
                            xc[d] = 0;
                            if (!d) {
                                ++e;
                                xc = [
                                    1
                                ].concat(xc);
                            }
                        }
                    }
                    // Determine trailing zeros.
                    for(k = xc.length; !xc[--k];);
                    // E.g. [4, 11, 15] becomes 4bf.
                    for(i = 0, str = ''; i <= k; str += alphabet.charAt(xc[i++]));
                    // Add leading zeros, decimal point and trailing zeros as required.
                    str = toFixedPoint(str, e, alphabet.charAt(0));
                }
                // The caller will add the sign.
                return str;
            };
        }();
        // Perform division in the specified base. Called by div and convertBase.
        div = function() {
            // Assume non-zero x and k.
            function multiply(x, k, base) {
                var m, temp, xlo, xhi, carry = 0, i = x.length, klo = k % SQRT_BASE, khi = k / SQRT_BASE | 0;
                for(x = x.slice(); i--;){
                    xlo = x[i] % SQRT_BASE;
                    xhi = x[i] / SQRT_BASE | 0;
                    m = khi * xlo + xhi * klo;
                    temp = klo * xlo + m % SQRT_BASE * SQRT_BASE + carry;
                    carry = (temp / base | 0) + (m / SQRT_BASE | 0) + khi * xhi;
                    x[i] = temp % base;
                }
                if (carry) x = [
                    carry
                ].concat(x);
                return x;
            }
            function compare(a, b, aL, bL) {
                var i, cmp;
                if (aL != bL) {
                    cmp = aL > bL ? 1 : -1;
                } else {
                    for(i = cmp = 0; i < aL; i++){
                        if (a[i] != b[i]) {
                            cmp = a[i] > b[i] ? 1 : -1;
                            break;
                        }
                    }
                }
                return cmp;
            }
            function subtract(a, b, aL, base) {
                var i = 0;
                // Subtract b from a.
                for(; aL--;){
                    a[aL] -= i;
                    i = a[aL] < b[aL] ? 1 : 0;
                    a[aL] = i * base + a[aL] - b[aL];
                }
                // Remove leading zeros.
                for(; !a[0] && a.length > 1; a.splice(0, 1));
            }
            // x: dividend, y: divisor.
            return function(x, y, dp, rm, base) {
                var cmp, e, i, more, n, prod, prodL, q, qc, rem, remL, rem0, xi, xL, yc0, yL, yz, s = x.s == y.s ? 1 : -1, xc = x.c, yc = y.c;
                // Either NaN, Infinity or 0?
                if (!xc || !xc[0] || !yc || !yc[0]) {
                    return new BigNumber(// Return NaN if either NaN, or both Infinity or 0.
                    !x.s || !y.s || (xc ? yc && xc[0] == yc[0] : !yc) ? NaN : // Return 0 if x is 0 or y is Infinity, or return Infinity as y is 0.
                    xc && xc[0] == 0 || !yc ? s * 0 : s / 0);
                }
                q = new BigNumber(s);
                qc = q.c = [];
                e = x.e - y.e;
                s = dp + e + 1;
                if (!base) {
                    base = BASE;
                    e = bitFloor(x.e / LOG_BASE) - bitFloor(y.e / LOG_BASE);
                    s = s / LOG_BASE | 0;
                }
                // Result exponent may be one less then the current value of e.
                // The coefficients of the BigNumbers from convertBase may have trailing zeros.
                for(i = 0; yc[i] == (xc[i] || 0); i++);
                if (yc[i] > (xc[i] || 0)) e--;
                if (s < 0) {
                    qc.push(1);
                    more = true;
                } else {
                    xL = xc.length;
                    yL = yc.length;
                    i = 0;
                    s += 2;
                    // Normalise xc and yc so highest order digit of yc is >= base / 2.
                    n = mathfloor(base / (yc[0] + 1));
                    // Not necessary, but to handle odd bases where yc[0] == (base / 2) - 1.
                    // if (n > 1 || n++ == 1 && yc[0] < base / 2) {
                    if (n > 1) {
                        yc = multiply(yc, n, base);
                        xc = multiply(xc, n, base);
                        yL = yc.length;
                        xL = xc.length;
                    }
                    xi = yL;
                    rem = xc.slice(0, yL);
                    remL = rem.length;
                    // Add zeros to make remainder as long as divisor.
                    for(; remL < yL; rem[remL++] = 0);
                    yz = yc.slice();
                    yz = [
                        0
                    ].concat(yz);
                    yc0 = yc[0];
                    if (yc[1] >= base / 2) yc0++;
                    // Not necessary, but to prevent trial digit n > base, when using base 3.
                    // else if (base == 3 && yc0 == 1) yc0 = 1 + 1e-15;
                    do {
                        n = 0;
                        // Compare divisor and remainder.
                        cmp = compare(yc, rem, yL, remL);
                        // If divisor < remainder.
                        if (cmp < 0) {
                            // Calculate trial digit, n.
                            rem0 = rem[0];
                            if (yL != remL) rem0 = rem0 * base + (rem[1] || 0);
                            // n is how many times the divisor goes into the current remainder.
                            n = mathfloor(rem0 / yc0);
                            //  Algorithm:
                            //  product = divisor multiplied by trial digit (n).
                            //  Compare product and remainder.
                            //  If product is greater than remainder:
                            //    Subtract divisor from product, decrement trial digit.
                            //  Subtract product from remainder.
                            //  If product was less than remainder at the last compare:
                            //    Compare new remainder and divisor.
                            //    If remainder is greater than divisor:
                            //      Subtract divisor from remainder, increment trial digit.
                            if (n > 1) {
                                // n may be > base only when base is 3.
                                if (n >= base) n = base - 1;
                                // product = divisor * trial digit.
                                prod = multiply(yc, n, base);
                                prodL = prod.length;
                                remL = rem.length;
                                // Compare product and remainder.
                                // If product > remainder then trial digit n too high.
                                // n is 1 too high about 5% of the time, and is not known to have
                                // ever been more than 1 too high.
                                while(compare(prod, rem, prodL, remL) == 1){
                                    n--;
                                    // Subtract divisor from product.
                                    subtract(prod, yL < prodL ? yz : yc, prodL, base);
                                    prodL = prod.length;
                                    cmp = 1;
                                }
                            } else {
                                // n is 0 or 1, cmp is -1.
                                // If n is 0, there is no need to compare yc and rem again below,
                                // so change cmp to 1 to avoid it.
                                // If n is 1, leave cmp as -1, so yc and rem are compared again.
                                if (n == 0) {
                                    // divisor < remainder, so n must be at least 1.
                                    cmp = n = 1;
                                }
                                // product = divisor
                                prod = yc.slice();
                                prodL = prod.length;
                            }
                            if (prodL < remL) prod = [
                                0
                            ].concat(prod);
                            // Subtract product from remainder.
                            subtract(rem, prod, remL, base);
                            remL = rem.length;
                            // If product was < remainder.
                            if (cmp == -1) {
                                // Compare divisor and new remainder.
                                // If divisor < new remainder, subtract divisor from remainder.
                                // Trial digit n too low.
                                // n is 1 too low about 5% of the time, and very rarely 2 too low.
                                while(compare(yc, rem, yL, remL) < 1){
                                    n++;
                                    // Subtract divisor from remainder.
                                    subtract(rem, yL < remL ? yz : yc, remL, base);
                                    remL = rem.length;
                                }
                            }
                        } else if (cmp === 0) {
                            n++;
                            rem = [
                                0
                            ];
                        } // else cmp === 1 and n will be 0
                        // Add the next digit, n, to the result array.
                        qc[i++] = n;
                        // Update the remainder.
                        if (rem[0]) {
                            rem[remL++] = xc[xi] || 0;
                        } else {
                            rem = [
                                xc[xi]
                            ];
                            remL = 1;
                        }
                    }while ((xi++ < xL || rem[0] != null) && s--)
                    more = rem[0] != null;
                    // Leading zero?
                    if (!qc[0]) qc.splice(0, 1);
                }
                if (base == BASE) {
                    // To calculate q.e, first get the number of digits of qc[0].
                    for(i = 1, s = qc[0]; s >= 10; s /= 10, i++);
                    round(q, dp + (q.e = i + e * LOG_BASE - 1) + 1, rm, more);
                // Caller is convertBase.
                } else {
                    q.e = e;
                    q.r = +more;
                }
                return q;
            };
        }();
        /*
     * Return a string representing the value of BigNumber n in fixed-point or exponential
     * notation rounded to the specified decimal places or significant digits.
     *
     * n: a BigNumber.
     * i: the index of the last digit required (i.e. the digit that may be rounded up).
     * rm: the rounding mode.
     * id: 1 (toExponential) or 2 (toPrecision).
     */ function format(n, i, rm, id) {
            var c0, e, ne, len, str;
            if (rm == null) rm = ROUNDING_MODE;
            else intCheck(rm, 0, 8);
            if (!n.c) return n.toString();
            c0 = n.c[0];
            ne = n.e;
            if (i == null) {
                str = coeffToString(n.c);
                str = id == 1 || id == 2 && (ne <= TO_EXP_NEG || ne >= TO_EXP_POS) ? toExponential(str, ne) : toFixedPoint(str, ne, '0');
            } else {
                n = round(new BigNumber(n), i, rm);
                // n.e may have changed if the value was rounded up.
                e = n.e;
                str = coeffToString(n.c);
                len = str.length;
                // toPrecision returns exponential notation if the number of significant digits
                // specified is less than the number of digits necessary to represent the integer
                // part of the value in fixed-point notation.
                // Exponential notation.
                if (id == 1 || id == 2 && (i <= e || e <= TO_EXP_NEG)) {
                    // Append zeros?
                    for(; len < i; str += '0', len++);
                    str = toExponential(str, e);
                // Fixed-point notation.
                } else {
                    i -= ne + (id === 2 && e > ne);
                    str = toFixedPoint(str, e, '0');
                    // Append zeros?
                    if (e + 1 > len) {
                        if (--i > 0) for(str += '.'; i--; str += '0');
                    } else {
                        i += e - len;
                        if (i > 0) {
                            if (e + 1 == len) str += '.';
                            for(; i--; str += '0');
                        }
                    }
                }
            }
            return n.s < 0 && c0 ? '-' + str : str;
        }
        // Handle BigNumber.max and BigNumber.min.
        // If any number is NaN, return NaN.
        function maxOrMin(args, n) {
            var k, y, i = 1, x = new BigNumber(args[0]);
            for(; i < args.length; i++){
                y = new BigNumber(args[i]);
                if (!y.s || (k = compare(x, y)) === n || k === 0 && x.s === n) {
                    x = y;
                }
            }
            return x;
        }
        /*
     * Strip trailing zeros, calculate base 10 exponent and check against MIN_EXP and MAX_EXP.
     * Called by minus, plus and times.
     */ function normalise(n, c, e) {
            var i = 1, j = c.length;
            // Remove trailing zeros.
            for(; !c[--j]; c.pop());
            // Calculate the base 10 exponent. First get the number of digits of c[0].
            for(j = c[0]; j >= 10; j /= 10, i++);
            // Overflow?
            if ((e = i + e * LOG_BASE - 1) > MAX_EXP) {
                // Infinity.
                n.c = n.e = null;
            // Underflow?
            } else if (e < MIN_EXP) {
                // Zero.
                n.c = [
                    n.e = 0
                ];
            } else {
                n.e = e;
                n.c = c;
            }
            return n;
        }
        // Handle values that fail the validity test in BigNumber.
        parseNumeric = function() {
            var basePrefix = /^(-?)0([xbo])(?=\w[\w.]*$)/i, dotAfter = /^([^.]+)\.$/, dotBefore = /^\.([^.]+)$/, isInfinityOrNaN = /^-?(Infinity|NaN)$/, whitespaceOrPlus = /^\s*\+(?=[\w.])|^\s+|\s+$/g;
            return function(x, str, isNum, b) {
                var base, s = isNum ? str : str.replace(whitespaceOrPlus, '');
                // No exception on Infinity or NaN.
                if (isInfinityOrNaN.test(s)) {
                    x.s = isNaN(s) ? null : s < 0 ? -1 : 1;
                } else {
                    if (!isNum) {
                        // basePrefix = /^(-?)0([xbo])(?=\w[\w.]*$)/i
                        s = s.replace(basePrefix, function(m, p1, p2) {
                            base = (p2 = p2.toLowerCase()) == 'x' ? 16 : p2 == 'b' ? 2 : 8;
                            return !b || b == base ? p1 : m;
                        });
                        if (b) {
                            base = b;
                            // E.g. '1.' to '1', '.1' to '0.1'
                            s = s.replace(dotAfter, '$1').replace(dotBefore, '0.$1');
                        }
                        if (str != s) return new BigNumber(s, base);
                    }
                    // '[BigNumber Error] Not a number: {n}'
                    // '[BigNumber Error] Not a base {b} number: {n}'
                    if (BigNumber.DEBUG) {
                        throw Error(bignumberError + 'Not a' + (b ? ' base ' + b : '') + ' number: ' + str);
                    }
                    // NaN
                    x.s = null;
                }
                x.c = x.e = null;
            };
        }();
        /*
     * Round x to sd significant digits using rounding mode rm. Check for over/under-flow.
     * If r is truthy, it is known that there are more digits after the rounding digit.
     */ function round(x, sd, rm, r) {
            var d, i, j, k, n, ni, rd, xc = x.c, pows10 = POWS_TEN;
            // if x is not Infinity or NaN...
            if (xc) {
                // rd is the rounding digit, i.e. the digit after the digit that may be rounded up.
                // n is a base 1e14 number, the value of the element of array x.c containing rd.
                // ni is the index of n within x.c.
                // d is the number of digits of n.
                // i is the index of rd within n including leading zeros.
                // j is the actual index of rd within n (if < 0, rd is a leading zero).
                out: {
                    // Get the number of digits of the first element of xc.
                    for(d = 1, k = xc[0]; k >= 10; k /= 10, d++);
                    i = sd - d;
                    // If the rounding digit is in the first element of xc...
                    if (i < 0) {
                        i += LOG_BASE;
                        j = sd;
                        n = xc[ni = 0];
                        // Get the rounding digit at index j of n.
                        rd = mathfloor(n / pows10[d - j - 1] % 10);
                    } else {
                        ni = mathceil((i + 1) / LOG_BASE);
                        if (ni >= xc.length) {
                            if (r) {
                                // Needed by sqrt.
                                for(; xc.length <= ni; xc.push(0));
                                n = rd = 0;
                                d = 1;
                                i %= LOG_BASE;
                                j = i - LOG_BASE + 1;
                            } else {
                                break out;
                            }
                        } else {
                            n = k = xc[ni];
                            // Get the number of digits of n.
                            for(d = 1; k >= 10; k /= 10, d++);
                            // Get the index of rd within n.
                            i %= LOG_BASE;
                            // Get the index of rd within n, adjusted for leading zeros.
                            // The number of leading zeros of n is given by LOG_BASE - d.
                            j = i - LOG_BASE + d;
                            // Get the rounding digit at index j of n.
                            rd = j < 0 ? 0 : mathfloor(n / pows10[d - j - 1] % 10);
                        }
                    }
                    r = r || sd < 0 || // Are there any non-zero digits after the rounding digit?
                    // The expression  n % pows10[d - j - 1]  returns all digits of n to the right
                    // of the digit at j, e.g. if n is 908714 and j is 2, the expression gives 714.
                    xc[ni + 1] != null || (j < 0 ? n : n % pows10[d - j - 1]);
                    r = rm < 4 ? (rd || r) && (rm == 0 || rm == (x.s < 0 ? 3 : 2)) : rd > 5 || rd == 5 && (rm == 4 || r || rm == 6 && // Check whether the digit to the left of the rounding digit is odd.
                    (i > 0 ? j > 0 ? n / pows10[d - j] : 0 : xc[ni - 1]) % 10 & 1 || rm == (x.s < 0 ? 8 : 7));
                    if (sd < 1 || !xc[0]) {
                        xc.length = 0;
                        if (r) {
                            // Convert sd to decimal places.
                            sd -= x.e + 1;
                            // 1, 0.1, 0.01, 0.001, 0.0001 etc.
                            xc[0] = pows10[(LOG_BASE - sd % LOG_BASE) % LOG_BASE];
                            x.e = -sd || 0;
                        } else {
                            // Zero.
                            xc[0] = x.e = 0;
                        }
                        return x;
                    }
                    // Remove excess digits.
                    if (i == 0) {
                        xc.length = ni;
                        k = 1;
                        ni--;
                    } else {
                        xc.length = ni + 1;
                        k = pows10[LOG_BASE - i];
                        // E.g. 56700 becomes 56000 if 7 is the rounding digit.
                        // j > 0 means i > number of leading zeros of n.
                        xc[ni] = j > 0 ? mathfloor(n / pows10[d - j] % pows10[j]) * k : 0;
                    }
                    // Round up?
                    if (r) {
                        for(;;){
                            // If the digit to be rounded up is in the first element of xc...
                            if (ni == 0) {
                                // i will be the length of xc[0] before k is added.
                                for(i = 1, j = xc[0]; j >= 10; j /= 10, i++);
                                j = xc[0] += k;
                                for(k = 1; j >= 10; j /= 10, k++);
                                // if i != k the length has increased.
                                if (i != k) {
                                    x.e++;
                                    if (xc[0] == BASE) xc[0] = 1;
                                }
                                break;
                            } else {
                                xc[ni] += k;
                                if (xc[ni] != BASE) break;
                                xc[ni--] = 0;
                                k = 1;
                            }
                        }
                    }
                    // Remove trailing zeros.
                    for(i = xc.length; xc[--i] === 0; xc.pop());
                }
                // Overflow? Infinity.
                if (x.e > MAX_EXP) {
                    x.c = x.e = null;
                // Underflow? Zero.
                } else if (x.e < MIN_EXP) {
                    x.c = [
                        x.e = 0
                    ];
                }
            }
            return x;
        }
        function valueOf(n) {
            var str, e = n.e;
            if (e === null) return n.toString();
            str = coeffToString(n.c);
            str = e <= TO_EXP_NEG || e >= TO_EXP_POS ? toExponential(str, e) : toFixedPoint(str, e, '0');
            return n.s < 0 ? '-' + str : str;
        }
        // PROTOTYPE/INSTANCE METHODS
        /*
     * Return a new BigNumber whose value is the absolute value of this BigNumber.
     */ P.absoluteValue = P.abs = function() {
            var x = new BigNumber(this);
            if (x.s < 0) x.s = 1;
            return x;
        };
        /*
     * Return
     *   1 if the value of this BigNumber is greater than the value of BigNumber(y, b),
     *   -1 if the value of this BigNumber is less than the value of BigNumber(y, b),
     *   0 if they have the same value,
     *   or null if the value of either is NaN.
     */ P.comparedTo = function(y, b) {
            return compare(this, new BigNumber(y, b));
        };
        /*
     * If dp is undefined or null or true or false, return the number of decimal places of the
     * value of this BigNumber, or null if the value of this BigNumber is Infinity or NaN.
     *
     * Otherwise, if dp is a number, return a new BigNumber whose value is the value of this
     * BigNumber rounded to a maximum of dp decimal places using rounding mode rm, or
     * ROUNDING_MODE if rm is omitted.
     *
     * [dp] {number} Decimal places: integer, 0 to MAX inclusive.
     * [rm] {number} Rounding mode. Integer, 0 to 8 inclusive.
     *
     * '[BigNumber Error] Argument {not a primitive number|not an integer|out of range}: {dp|rm}'
     */ P.decimalPlaces = P.dp = function(dp, rm) {
            var c, n, v, x = this;
            if (dp != null) {
                intCheck(dp, 0, MAX);
                if (rm == null) rm = ROUNDING_MODE;
                else intCheck(rm, 0, 8);
                return round(new BigNumber(x), dp + x.e + 1, rm);
            }
            if (!(c = x.c)) return null;
            n = ((v = c.length - 1) - bitFloor(this.e / LOG_BASE)) * LOG_BASE;
            // Subtract the number of trailing zeros of the last number.
            if (v = c[v]) for(; v % 10 == 0; v /= 10, n--);
            if (n < 0) n = 0;
            return n;
        };
        /*
     *  n / 0 = I
     *  n / N = N
     *  n / I = 0
     *  0 / n = 0
     *  0 / 0 = N
     *  0 / N = N
     *  0 / I = 0
     *  N / n = N
     *  N / 0 = N
     *  N / N = N
     *  N / I = N
     *  I / n = I
     *  I / 0 = I
     *  I / N = N
     *  I / I = N
     *
     * Return a new BigNumber whose value is the value of this BigNumber divided by the value of
     * BigNumber(y, b), rounded according to DECIMAL_PLACES and ROUNDING_MODE.
     */ P.dividedBy = P.div = function(y, b) {
            return div(this, new BigNumber(y, b), DECIMAL_PLACES, ROUNDING_MODE);
        };
        /*
     * Return a new BigNumber whose value is the integer part of dividing the value of this
     * BigNumber by the value of BigNumber(y, b).
     */ P.dividedToIntegerBy = P.idiv = function(y, b) {
            return div(this, new BigNumber(y, b), 0, 1);
        };
        /*
     * Return a BigNumber whose value is the value of this BigNumber exponentiated by n.
     *
     * If m is present, return the result modulo m.
     * If n is negative round according to DECIMAL_PLACES and ROUNDING_MODE.
     * If POW_PRECISION is non-zero and m is not present, round to POW_PRECISION using ROUNDING_MODE.
     *
     * The modular power operation works efficiently when x, n, and m are integers, otherwise it
     * is equivalent to calculating x.exponentiatedBy(n).modulo(m) with a POW_PRECISION of 0.
     *
     * n {number|string|BigNumber} The exponent. An integer.
     * [m] {number|string|BigNumber} The modulus.
     *
     * '[BigNumber Error] Exponent not an integer: {n}'
     */ P.exponentiatedBy = P.pow = function(n, m) {
            var half, isModExp, i, k, more, nIsBig, nIsNeg, nIsOdd, y, x = this;
            n = new BigNumber(n);
            // Allow NaN and Infinity, but not other non-integers.
            if (n.c && !n.isInteger()) {
                throw Error(bignumberError + 'Exponent not an integer: ' + valueOf(n));
            }
            if (m != null) m = new BigNumber(m);
            // Exponent of MAX_SAFE_INTEGER is 15.
            nIsBig = n.e > 14;
            // If x is NaN, Infinity, 0 or 1, or n is Infinity, NaN or 0.
            if (!x.c || !x.c[0] || x.c[0] == 1 && !x.e && x.c.length == 1 || !n.c || !n.c[0]) {
                // The sign of the result of pow when x is negative depends on the evenness of n.
                // If +n overflows to Infinity, the evenness of n would be not be known.
                y = new BigNumber(Math.pow(+valueOf(x), nIsBig ? n.s * (2 - isOdd(n)) : +valueOf(n)));
                return m ? y.mod(m) : y;
            }
            nIsNeg = n.s < 0;
            if (m) {
                // x % m returns NaN if abs(m) is zero, or m is NaN.
                if (m.c ? !m.c[0] : !m.s) return new BigNumber(NaN);
                isModExp = !nIsNeg && x.isInteger() && m.isInteger();
                if (isModExp) x = x.mod(m);
            // Overflow to Infinity: >=2**1e10 or >=1.0000024**1e15.
            // Underflow to 0: <=0.79**1e10 or <=0.9999975**1e15.
            } else if (n.e > 9 && (x.e > 0 || x.e < -1 || (x.e == 0 ? x.c[0] > 1 || nIsBig && x.c[1] >= 24e7 : x.c[0] < 8e13 || nIsBig && x.c[0] <= 9999975e7))) {
                // If x is negative and n is odd, k = -0, else k = 0.
                k = x.s < 0 && isOdd(n) ? -0 : 0;
                // If x >= 1, k = Infinity.
                if (x.e > -1) k = 1 / k;
                // If n is negative return 0, else return Infinity.
                return new BigNumber(nIsNeg ? 1 / k : k);
            } else if (POW_PRECISION) {
                // Truncating each coefficient array to a length of k after each multiplication
                // equates to truncating significant digits to POW_PRECISION + [28, 41],
                // i.e. there will be a minimum of 28 guard digits retained.
                k = mathceil(POW_PRECISION / LOG_BASE + 2);
            }
            if (nIsBig) {
                half = new BigNumber(0.5);
                if (nIsNeg) n.s = 1;
                nIsOdd = isOdd(n);
            } else {
                i = Math.abs(+valueOf(n));
                nIsOdd = i % 2;
            }
            y = new BigNumber(ONE);
            // Performs 54 loop iterations for n of 9007199254740991.
            for(;;){
                if (nIsOdd) {
                    y = y.times(x);
                    if (!y.c) break;
                    if (k) {
                        if (y.c.length > k) y.c.length = k;
                    } else if (isModExp) {
                        y = y.mod(m); //y = y.minus(div(y, m, 0, MODULO_MODE).times(m));
                    }
                }
                if (i) {
                    i = mathfloor(i / 2);
                    if (i === 0) break;
                    nIsOdd = i % 2;
                } else {
                    n = n.times(half);
                    round(n, n.e + 1, 1);
                    if (n.e > 14) {
                        nIsOdd = isOdd(n);
                    } else {
                        i = +valueOf(n);
                        if (i === 0) break;
                        nIsOdd = i % 2;
                    }
                }
                x = x.times(x);
                if (k) {
                    if (x.c && x.c.length > k) x.c.length = k;
                } else if (isModExp) {
                    x = x.mod(m); //x = x.minus(div(x, m, 0, MODULO_MODE).times(m));
                }
            }
            if (isModExp) return y;
            if (nIsNeg) y = ONE.div(y);
            return m ? y.mod(m) : k ? round(y, POW_PRECISION, ROUNDING_MODE, more) : y;
        };
        /*
     * Return a new BigNumber whose value is the value of this BigNumber rounded to an integer
     * using rounding mode rm, or ROUNDING_MODE if rm is omitted.
     *
     * [rm] {number} Rounding mode. Integer, 0 to 8 inclusive.
     *
     * '[BigNumber Error] Argument {not a primitive number|not an integer|out of range}: {rm}'
     */ P.integerValue = function(rm) {
            var n = new BigNumber(this);
            if (rm == null) rm = ROUNDING_MODE;
            else intCheck(rm, 0, 8);
            return round(n, n.e + 1, rm);
        };
        /*
     * Return true if the value of this BigNumber is equal to the value of BigNumber(y, b),
     * otherwise return false.
     */ P.isEqualTo = P.eq = function(y, b) {
            return compare(this, new BigNumber(y, b)) === 0;
        };
        /*
     * Return true if the value of this BigNumber is a finite number, otherwise return false.
     */ P.isFinite = function() {
            return !!this.c;
        };
        /*
     * Return true if the value of this BigNumber is greater than the value of BigNumber(y, b),
     * otherwise return false.
     */ P.isGreaterThan = P.gt = function(y, b) {
            return compare(this, new BigNumber(y, b)) > 0;
        };
        /*
     * Return true if the value of this BigNumber is greater than or equal to the value of
     * BigNumber(y, b), otherwise return false.
     */ P.isGreaterThanOrEqualTo = P.gte = function(y, b) {
            return (b = compare(this, new BigNumber(y, b))) === 1 || b === 0;
        };
        /*
     * Return true if the value of this BigNumber is an integer, otherwise return false.
     */ P.isInteger = function() {
            return !!this.c && bitFloor(this.e / LOG_BASE) > this.c.length - 2;
        };
        /*
     * Return true if the value of this BigNumber is less than the value of BigNumber(y, b),
     * otherwise return false.
     */ P.isLessThan = P.lt = function(y, b) {
            return compare(this, new BigNumber(y, b)) < 0;
        };
        /*
     * Return true if the value of this BigNumber is less than or equal to the value of
     * BigNumber(y, b), otherwise return false.
     */ P.isLessThanOrEqualTo = P.lte = function(y, b) {
            return (b = compare(this, new BigNumber(y, b))) === -1 || b === 0;
        };
        /*
     * Return true if the value of this BigNumber is NaN, otherwise return false.
     */ P.isNaN = function() {
            return !this.s;
        };
        /*
     * Return true if the value of this BigNumber is negative, otherwise return false.
     */ P.isNegative = function() {
            return this.s < 0;
        };
        /*
     * Return true if the value of this BigNumber is positive, otherwise return false.
     */ P.isPositive = function() {
            return this.s > 0;
        };
        /*
     * Return true if the value of this BigNumber is 0 or -0, otherwise return false.
     */ P.isZero = function() {
            return !!this.c && this.c[0] == 0;
        };
        /*
     *  n - 0 = n
     *  n - N = N
     *  n - I = -I
     *  0 - n = -n
     *  0 - 0 = 0
     *  0 - N = N
     *  0 - I = -I
     *  N - n = N
     *  N - 0 = N
     *  N - N = N
     *  N - I = N
     *  I - n = I
     *  I - 0 = I
     *  I - N = N
     *  I - I = N
     *
     * Return a new BigNumber whose value is the value of this BigNumber minus the value of
     * BigNumber(y, b).
     */ P.minus = function(y, b) {
            var i, j, t, xLTy, x = this, a = x.s;
            y = new BigNumber(y, b);
            b = y.s;
            // Either NaN?
            if (!a || !b) return new BigNumber(NaN);
            // Signs differ?
            if (a != b) {
                y.s = -b;
                return x.plus(y);
            }
            var xe = x.e / LOG_BASE, ye = y.e / LOG_BASE, xc = x.c, yc = y.c;
            if (!xe || !ye) {
                // Either Infinity?
                if (!xc || !yc) return xc ? (y.s = -b, y) : new BigNumber(yc ? x : NaN);
                // Either zero?
                if (!xc[0] || !yc[0]) {
                    // Return y if y is non-zero, x if x is non-zero, or zero if both are zero.
                    return yc[0] ? (y.s = -b, y) : new BigNumber(xc[0] ? x : // IEEE 754 (2008) 6.3: n - n = -0 when rounding to -Infinity
                    ROUNDING_MODE == 3 ? -0 : 0);
                }
            }
            xe = bitFloor(xe);
            ye = bitFloor(ye);
            xc = xc.slice();
            // Determine which is the bigger number.
            if (a = xe - ye) {
                if (xLTy = a < 0) {
                    a = -a;
                    t = xc;
                } else {
                    ye = xe;
                    t = yc;
                }
                t.reverse();
                // Prepend zeros to equalise exponents.
                for(b = a; b--; t.push(0));
                t.reverse();
            } else {
                // Exponents equal. Check digit by digit.
                j = (xLTy = (a = xc.length) < (b = yc.length)) ? a : b;
                for(a = b = 0; b < j; b++){
                    if (xc[b] != yc[b]) {
                        xLTy = xc[b] < yc[b];
                        break;
                    }
                }
            }
            // x < y? Point xc to the array of the bigger number.
            if (xLTy) {
                t = xc;
                xc = yc;
                yc = t;
                y.s = -y.s;
            }
            b = (j = yc.length) - (i = xc.length);
            // Append zeros to xc if shorter.
            // No need to add zeros to yc if shorter as subtract only needs to start at yc.length.
            if (b > 0) for(; b--; xc[i++] = 0);
            b = BASE - 1;
            // Subtract yc from xc.
            for(; j > a;){
                if (xc[--j] < yc[j]) {
                    for(i = j; i && !xc[--i]; xc[i] = b);
                    --xc[i];
                    xc[j] += BASE;
                }
                xc[j] -= yc[j];
            }
            // Remove leading zeros and adjust exponent accordingly.
            for(; xc[0] == 0; xc.splice(0, 1), --ye);
            // Zero?
            if (!xc[0]) {
                // Following IEEE 754 (2008) 6.3,
                // n - n = +0  but  n - n = -0  when rounding towards -Infinity.
                y.s = ROUNDING_MODE == 3 ? -1 : 1;
                y.c = [
                    y.e = 0
                ];
                return y;
            }
            // No need to check for Infinity as +x - +y != Infinity && -x - -y != Infinity
            // for finite x and y.
            return normalise(y, xc, ye);
        };
        /*
     *   n % 0 =  N
     *   n % N =  N
     *   n % I =  n
     *   0 % n =  0
     *  -0 % n = -0
     *   0 % 0 =  N
     *   0 % N =  N
     *   0 % I =  0
     *   N % n =  N
     *   N % 0 =  N
     *   N % N =  N
     *   N % I =  N
     *   I % n =  N
     *   I % 0 =  N
     *   I % N =  N
     *   I % I =  N
     *
     * Return a new BigNumber whose value is the value of this BigNumber modulo the value of
     * BigNumber(y, b). The result depends on the value of MODULO_MODE.
     */ P.modulo = P.mod = function(y, b) {
            var q, s, x = this;
            y = new BigNumber(y, b);
            // Return NaN if x is Infinity or NaN, or y is NaN or zero.
            if (!x.c || !y.s || y.c && !y.c[0]) {
                return new BigNumber(NaN);
            // Return x if y is Infinity or x is zero.
            } else if (!y.c || x.c && !x.c[0]) {
                return new BigNumber(x);
            }
            if (MODULO_MODE == 9) {
                // Euclidian division: q = sign(y) * floor(x / abs(y))
                // r = x - qy    where  0 <= r < abs(y)
                s = y.s;
                y.s = 1;
                q = div(x, y, 0, 3);
                y.s = s;
                q.s *= s;
            } else {
                q = div(x, y, 0, MODULO_MODE);
            }
            y = x.minus(q.times(y));
            // To match JavaScript %, ensure sign of zero is sign of dividend.
            if (!y.c[0] && MODULO_MODE == 1) y.s = x.s;
            return y;
        };
        /*
     *  n * 0 = 0
     *  n * N = N
     *  n * I = I
     *  0 * n = 0
     *  0 * 0 = 0
     *  0 * N = N
     *  0 * I = N
     *  N * n = N
     *  N * 0 = N
     *  N * N = N
     *  N * I = N
     *  I * n = I
     *  I * 0 = N
     *  I * N = N
     *  I * I = I
     *
     * Return a new BigNumber whose value is the value of this BigNumber multiplied by the value
     * of BigNumber(y, b).
     */ P.multipliedBy = P.times = function(y, b) {
            var c, e, i, j, k, m, xcL, xlo, xhi, ycL, ylo, yhi, zc, base, sqrtBase, x = this, xc = x.c, yc = (y = new BigNumber(y, b)).c;
            // Either NaN, Infinity or 0?
            if (!xc || !yc || !xc[0] || !yc[0]) {
                // Return NaN if either is NaN, or one is 0 and the other is Infinity.
                if (!x.s || !y.s || xc && !xc[0] && !yc || yc && !yc[0] && !xc) {
                    y.c = y.e = y.s = null;
                } else {
                    y.s *= x.s;
                    // Return Infinity if either is Infinity.
                    if (!xc || !yc) {
                        y.c = y.e = null;
                    // Return 0 if either is 0.
                    } else {
                        y.c = [
                            0
                        ];
                        y.e = 0;
                    }
                }
                return y;
            }
            e = bitFloor(x.e / LOG_BASE) + bitFloor(y.e / LOG_BASE);
            y.s *= x.s;
            xcL = xc.length;
            ycL = yc.length;
            // Ensure xc points to longer array and xcL to its length.
            if (xcL < ycL) {
                zc = xc;
                xc = yc;
                yc = zc;
                i = xcL;
                xcL = ycL;
                ycL = i;
            }
            // Initialise the result array with zeros.
            for(i = xcL + ycL, zc = []; i--; zc.push(0));
            base = BASE;
            sqrtBase = SQRT_BASE;
            for(i = ycL; --i >= 0;){
                c = 0;
                ylo = yc[i] % sqrtBase;
                yhi = yc[i] / sqrtBase | 0;
                for(k = xcL, j = i + k; j > i;){
                    xlo = xc[--k] % sqrtBase;
                    xhi = xc[k] / sqrtBase | 0;
                    m = yhi * xlo + xhi * ylo;
                    xlo = ylo * xlo + m % sqrtBase * sqrtBase + zc[j] + c;
                    c = (xlo / base | 0) + (m / sqrtBase | 0) + yhi * xhi;
                    zc[j--] = xlo % base;
                }
                zc[j] = c;
            }
            if (c) {
                ++e;
            } else {
                zc.splice(0, 1);
            }
            return normalise(y, zc, e);
        };
        /*
     * Return a new BigNumber whose value is the value of this BigNumber negated,
     * i.e. multiplied by -1.
     */ P.negated = function() {
            var x = new BigNumber(this);
            x.s = -x.s || null;
            return x;
        };
        /*
     *  n + 0 = n
     *  n + N = N
     *  n + I = I
     *  0 + n = n
     *  0 + 0 = 0
     *  0 + N = N
     *  0 + I = I
     *  N + n = N
     *  N + 0 = N
     *  N + N = N
     *  N + I = N
     *  I + n = I
     *  I + 0 = I
     *  I + N = N
     *  I + I = I
     *
     * Return a new BigNumber whose value is the value of this BigNumber plus the value of
     * BigNumber(y, b).
     */ P.plus = function(y, b) {
            var t, x = this, a = x.s;
            y = new BigNumber(y, b);
            b = y.s;
            // Either NaN?
            if (!a || !b) return new BigNumber(NaN);
            // Signs differ?
            if (a != b) {
                y.s = -b;
                return x.minus(y);
            }
            var xe = x.e / LOG_BASE, ye = y.e / LOG_BASE, xc = x.c, yc = y.c;
            if (!xe || !ye) {
                // Return Infinity if either Infinity.
                if (!xc || !yc) return new BigNumber(a / 0);
                // Either zero?
                // Return y if y is non-zero, x if x is non-zero, or zero if both are zero.
                if (!xc[0] || !yc[0]) return yc[0] ? y : new BigNumber(xc[0] ? x : a * 0);
            }
            xe = bitFloor(xe);
            ye = bitFloor(ye);
            xc = xc.slice();
            // Prepend zeros to equalise exponents. Faster to use reverse then do unshifts.
            if (a = xe - ye) {
                if (a > 0) {
                    ye = xe;
                    t = yc;
                } else {
                    a = -a;
                    t = xc;
                }
                t.reverse();
                for(; a--; t.push(0));
                t.reverse();
            }
            a = xc.length;
            b = yc.length;
            // Point xc to the longer array, and b to the shorter length.
            if (a - b < 0) {
                t = yc;
                yc = xc;
                xc = t;
                b = a;
            }
            // Only start adding at yc.length - 1 as the further digits of xc can be ignored.
            for(a = 0; b;){
                a = (xc[--b] = xc[b] + yc[b] + a) / BASE | 0;
                xc[b] = BASE === xc[b] ? 0 : xc[b] % BASE;
            }
            if (a) {
                xc = [
                    a
                ].concat(xc);
                ++ye;
            }
            // No need to check for zero, as +x + +y != 0 && -x + -y != 0
            // ye = MAX_EXP + 1 possible
            return normalise(y, xc, ye);
        };
        /*
     * If sd is undefined or null or true or false, return the number of significant digits of
     * the value of this BigNumber, or null if the value of this BigNumber is Infinity or NaN.
     * If sd is true include integer-part trailing zeros in the count.
     *
     * Otherwise, if sd is a number, return a new BigNumber whose value is the value of this
     * BigNumber rounded to a maximum of sd significant digits using rounding mode rm, or
     * ROUNDING_MODE if rm is omitted.
     *
     * sd {number|boolean} number: significant digits: integer, 1 to MAX inclusive.
     *                     boolean: whether to count integer-part trailing zeros: true or false.
     * [rm] {number} Rounding mode. Integer, 0 to 8 inclusive.
     *
     * '[BigNumber Error] Argument {not a primitive number|not an integer|out of range}: {sd|rm}'
     */ P.precision = P.sd = function(sd, rm) {
            var c, n, v, x = this;
            if (sd != null && sd !== !!sd) {
                intCheck(sd, 1, MAX);
                if (rm == null) rm = ROUNDING_MODE;
                else intCheck(rm, 0, 8);
                return round(new BigNumber(x), sd, rm);
            }
            if (!(c = x.c)) return null;
            v = c.length - 1;
            n = v * LOG_BASE + 1;
            if (v = c[v]) {
                // Subtract the number of trailing zeros of the last element.
                for(; v % 10 == 0; v /= 10, n--);
                // Add the number of digits of the first element.
                for(v = c[0]; v >= 10; v /= 10, n++);
            }
            if (sd && x.e + 1 > n) n = x.e + 1;
            return n;
        };
        /*
     * Return a new BigNumber whose value is the value of this BigNumber shifted by k places
     * (powers of 10). Shift to the right if n > 0, and to the left if n < 0.
     *
     * k {number} Integer, -MAX_SAFE_INTEGER to MAX_SAFE_INTEGER inclusive.
     *
     * '[BigNumber Error] Argument {not a primitive number|not an integer|out of range}: {k}'
     */ P.shiftedBy = function(k) {
            intCheck(k, -MAX_SAFE_INTEGER, MAX_SAFE_INTEGER);
            return this.times('1e' + k);
        };
        /*
     *  sqrt(-n) =  N
     *  sqrt(N) =  N
     *  sqrt(-I) =  N
     *  sqrt(I) =  I
     *  sqrt(0) =  0
     *  sqrt(-0) = -0
     *
     * Return a new BigNumber whose value is the square root of the value of this BigNumber,
     * rounded according to DECIMAL_PLACES and ROUNDING_MODE.
     */ P.squareRoot = P.sqrt = function() {
            var m, n, r, rep, t, x = this, c = x.c, s = x.s, e = x.e, dp = DECIMAL_PLACES + 4, half = new BigNumber('0.5');
            // Negative/NaN/Infinity/zero?
            if (s !== 1 || !c || !c[0]) {
                return new BigNumber(!s || s < 0 && (!c || c[0]) ? NaN : c ? x : 1 / 0);
            }
            // Initial estimate.
            s = Math.sqrt(+valueOf(x));
            // Math.sqrt underflow/overflow?
            // Pass x to Math.sqrt as integer, then adjust the exponent of the result.
            if (s == 0 || s == 1 / 0) {
                n = coeffToString(c);
                if ((n.length + e) % 2 == 0) n += '0';
                s = Math.sqrt(+n);
                e = bitFloor((e + 1) / 2) - (e < 0 || e % 2);
                if (s == 1 / 0) {
                    n = '5e' + e;
                } else {
                    n = s.toExponential();
                    n = n.slice(0, n.indexOf('e') + 1) + e;
                }
                r = new BigNumber(n);
            } else {
                r = new BigNumber(s + '');
            }
            // Check for zero.
            // r could be zero if MIN_EXP is changed after the this value was created.
            // This would cause a division by zero (x/t) and hence Infinity below, which would cause
            // coeffToString to throw.
            if (r.c[0]) {
                e = r.e;
                s = e + dp;
                if (s < 3) s = 0;
                // Newton-Raphson iteration.
                for(;;){
                    t = r;
                    r = half.times(t.plus(div(x, t, dp, 1)));
                    if (coeffToString(t.c).slice(0, s) === (n = coeffToString(r.c)).slice(0, s)) {
                        // The exponent of r may here be one less than the final result exponent,
                        // e.g 0.0009999 (e-4) --> 0.001 (e-3), so adjust s so the rounding digits
                        // are indexed correctly.
                        if (r.e < e) --s;
                        n = n.slice(s - 3, s + 1);
                        // The 4th rounding digit may be in error by -1 so if the 4 rounding digits
                        // are 9999 or 4999 (i.e. approaching a rounding boundary) continue the
                        // iteration.
                        if (n == '9999' || !rep && n == '4999') {
                            // On the first iteration only, check to see if rounding up gives the
                            // exact result as the nines may infinitely repeat.
                            if (!rep) {
                                round(t, t.e + DECIMAL_PLACES + 2, 0);
                                if (t.times(t).eq(x)) {
                                    r = t;
                                    break;
                                }
                            }
                            dp += 4;
                            s += 4;
                            rep = 1;
                        } else {
                            // If rounding digits are null, 0{0,4} or 50{0,3}, check for exact
                            // result. If not, then there are further digits and m will be truthy.
                            if (!+n || !+n.slice(1) && n.charAt(0) == '5') {
                                // Truncate to the first rounding digit.
                                round(r, r.e + DECIMAL_PLACES + 2, 1);
                                m = !r.times(r).eq(x);
                            }
                            break;
                        }
                    }
                }
            }
            return round(r, r.e + DECIMAL_PLACES + 1, ROUNDING_MODE, m);
        };
        /*
     * Return a string representing the value of this BigNumber in exponential notation and
     * rounded using ROUNDING_MODE to dp fixed decimal places.
     *
     * [dp] {number} Decimal places. Integer, 0 to MAX inclusive.
     * [rm] {number} Rounding mode. Integer, 0 to 8 inclusive.
     *
     * '[BigNumber Error] Argument {not a primitive number|not an integer|out of range}: {dp|rm}'
     */ P.toExponential = function(dp, rm) {
            if (dp != null) {
                intCheck(dp, 0, MAX);
                dp++;
            }
            return format(this, dp, rm, 1);
        };
        /*
     * Return a string representing the value of this BigNumber in fixed-point notation rounding
     * to dp fixed decimal places using rounding mode rm, or ROUNDING_MODE if rm is omitted.
     *
     * Note: as with JavaScript's number type, (-0).toFixed(0) is '0',
     * but e.g. (-0.00001).toFixed(0) is '-0'.
     *
     * [dp] {number} Decimal places. Integer, 0 to MAX inclusive.
     * [rm] {number} Rounding mode. Integer, 0 to 8 inclusive.
     *
     * '[BigNumber Error] Argument {not a primitive number|not an integer|out of range}: {dp|rm}'
     */ P.toFixed = function(dp, rm) {
            if (dp != null) {
                intCheck(dp, 0, MAX);
                dp = dp + this.e + 1;
            }
            return format(this, dp, rm);
        };
        /*
     * Return a string representing the value of this BigNumber in fixed-point notation rounded
     * using rm or ROUNDING_MODE to dp decimal places, and formatted according to the properties
     * of the format or FORMAT object (see BigNumber.set).
     *
     * The formatting object may contain some or all of the properties shown below.
     *
     * FORMAT = {
     *   prefix: '',
     *   groupSize: 3,
     *   secondaryGroupSize: 0,
     *   groupSeparator: ',',
     *   decimalSeparator: '.',
     *   fractionGroupSize: 0,
     *   fractionGroupSeparator: '\xA0',      // non-breaking space
     *   suffix: ''
     * };
     *
     * [dp] {number} Decimal places. Integer, 0 to MAX inclusive.
     * [rm] {number} Rounding mode. Integer, 0 to 8 inclusive.
     * [format] {object} Formatting options. See FORMAT pbject above.
     *
     * '[BigNumber Error] Argument {not a primitive number|not an integer|out of range}: {dp|rm}'
     * '[BigNumber Error] Argument not an object: {format}'
     */ P.toFormat = function(dp, rm, format) {
            var str, x = this;
            if (format == null) {
                if (dp != null && rm && typeof rm == 'object') {
                    format = rm;
                    rm = null;
                } else if (dp && typeof dp == 'object') {
                    format = dp;
                    dp = rm = null;
                } else {
                    format = FORMAT;
                }
            } else if (typeof format != 'object') {
                throw Error(bignumberError + 'Argument not an object: ' + format);
            }
            str = x.toFixed(dp, rm);
            if (x.c) {
                var i, arr = str.split('.'), g1 = +format.groupSize, g2 = +format.secondaryGroupSize, groupSeparator = format.groupSeparator || '', intPart = arr[0], fractionPart = arr[1], isNeg = x.s < 0, intDigits = isNeg ? intPart.slice(1) : intPart, len = intDigits.length;
                if (g2) {
                    i = g1;
                    g1 = g2;
                    g2 = i;
                    len -= i;
                }
                if (g1 > 0 && len > 0) {
                    i = len % g1 || g1;
                    intPart = intDigits.substr(0, i);
                    for(; i < len; i += g1)intPart += groupSeparator + intDigits.substr(i, g1);
                    if (g2 > 0) intPart += groupSeparator + intDigits.slice(i);
                    if (isNeg) intPart = '-' + intPart;
                }
                str = fractionPart ? intPart + (format.decimalSeparator || '') + ((g2 = +format.fractionGroupSize) ? fractionPart.replace(new RegExp('\\d{' + g2 + '}\\B', 'g'), '$&' + (format.fractionGroupSeparator || '')) : fractionPart) : intPart;
            }
            return (format.prefix || '') + str + (format.suffix || '');
        };
        /*
     * Return an array of two BigNumbers representing the value of this BigNumber as a simple
     * fraction with an integer numerator and an integer denominator.
     * The denominator will be a positive non-zero value less than or equal to the specified
     * maximum denominator. If a maximum denominator is not specified, the denominator will be
     * the lowest value necessary to represent the number exactly.
     *
     * [md] {number|string|BigNumber} Integer >= 1, or Infinity. The maximum denominator.
     *
     * '[BigNumber Error] Argument {not an integer|out of range} : {md}'
     */ P.toFraction = function(md) {
            var d, d0, d1, d2, e, exp, n, n0, n1, q, r, s, x = this, xc = x.c;
            if (md != null) {
                n = new BigNumber(md);
                // Throw if md is less than one or is not an integer, unless it is Infinity.
                if (!n.isInteger() && (n.c || n.s !== 1) || n.lt(ONE)) {
                    throw Error(bignumberError + 'Argument ' + (n.isInteger() ? 'out of range: ' : 'not an integer: ') + valueOf(n));
                }
            }
            if (!xc) return new BigNumber(x);
            d = new BigNumber(ONE);
            n1 = d0 = new BigNumber(ONE);
            d1 = n0 = new BigNumber(ONE);
            s = coeffToString(xc);
            // Determine initial denominator.
            // d is a power of 10 and the minimum max denominator that specifies the value exactly.
            e = d.e = s.length - x.e - 1;
            d.c[0] = POWS_TEN[(exp = e % LOG_BASE) < 0 ? LOG_BASE + exp : exp];
            md = !md || n.comparedTo(d) > 0 ? e > 0 ? d : n1 : n;
            exp = MAX_EXP;
            MAX_EXP = 1 / 0;
            n = new BigNumber(s);
            // n0 = d1 = 0
            n0.c[0] = 0;
            for(;;){
                q = div(n, d, 0, 1);
                d2 = d0.plus(q.times(d1));
                if (d2.comparedTo(md) == 1) break;
                d0 = d1;
                d1 = d2;
                n1 = n0.plus(q.times(d2 = n1));
                n0 = d2;
                d = n.minus(q.times(d2 = d));
                n = d2;
            }
            d2 = div(md.minus(d0), d1, 0, 1);
            n0 = n0.plus(d2.times(n1));
            d0 = d0.plus(d2.times(d1));
            n0.s = n1.s = x.s;
            e = e * 2;
            // Determine which fraction is closer to x, n0/d0 or n1/d1
            r = div(n1, d1, e, ROUNDING_MODE).minus(x).abs().comparedTo(div(n0, d0, e, ROUNDING_MODE).minus(x).abs()) < 1 ? [
                n1,
                d1
            ] : [
                n0,
                d0
            ];
            MAX_EXP = exp;
            return r;
        };
        /*
     * Return the value of this BigNumber converted to a number primitive.
     */ P.toNumber = function() {
            return +valueOf(this);
        };
        /*
     * Return a string representing the value of this BigNumber rounded to sd significant digits
     * using rounding mode rm or ROUNDING_MODE. If sd is less than the number of digits
     * necessary to represent the integer part of the value in fixed-point notation, then use
     * exponential notation.
     *
     * [sd] {number} Significant digits. Integer, 1 to MAX inclusive.
     * [rm] {number} Rounding mode. Integer, 0 to 8 inclusive.
     *
     * '[BigNumber Error] Argument {not a primitive number|not an integer|out of range}: {sd|rm}'
     */ P.toPrecision = function(sd, rm) {
            if (sd != null) intCheck(sd, 1, MAX);
            return format(this, sd, rm, 2);
        };
        /*
     * Return a string representing the value of this BigNumber in base b, or base 10 if b is
     * omitted. If a base is specified, including base 10, round according to DECIMAL_PLACES and
     * ROUNDING_MODE. If a base is not specified, and this BigNumber has a positive exponent
     * that is equal to or greater than TO_EXP_POS, or a negative exponent equal to or less than
     * TO_EXP_NEG, return exponential notation.
     *
     * [b] {number} Integer, 2 to ALPHABET.length inclusive.
     *
     * '[BigNumber Error] Base {not a primitive number|not an integer|out of range}: {b}'
     */ P.toString = function(b) {
            var str, n = this, s = n.s, e = n.e;
            // Infinity or NaN?
            if (e === null) {
                if (s) {
                    str = 'Infinity';
                    if (s < 0) str = '-' + str;
                } else {
                    str = 'NaN';
                }
            } else {
                if (b == null) {
                    str = e <= TO_EXP_NEG || e >= TO_EXP_POS ? toExponential(coeffToString(n.c), e) : toFixedPoint(coeffToString(n.c), e, '0');
                } else if (b === 10 && alphabetHasNormalDecimalDigits) {
                    n = round(new BigNumber(n), DECIMAL_PLACES + e + 1, ROUNDING_MODE);
                    str = toFixedPoint(coeffToString(n.c), n.e, '0');
                } else {
                    intCheck(b, 2, ALPHABET.length, 'Base');
                    str = convertBase(toFixedPoint(coeffToString(n.c), e, '0'), 10, b, s, true);
                }
                if (s < 0 && n.c[0]) str = '-' + str;
            }
            return str;
        };
        /*
     * Return as toString, but do not accept a base argument, and include the minus sign for
     * negative zero.
     */ P.valueOf = P.toJSON = function() {
            return valueOf(this);
        };
        P._isBigNumber = true;
        if (configObject != null) BigNumber.set(configObject);
        return BigNumber;
    }
    // PRIVATE HELPER FUNCTIONS
    // These functions don't need access to variables,
    // e.g. DECIMAL_PLACES, in the scope of the `clone` function above.
    function bitFloor(n) {
        var i = n | 0;
        return n > 0 || n === i ? i : i - 1;
    }
    // Return a coefficient array as a string of base 10 digits.
    function coeffToString(a) {
        var s, z, i = 1, j = a.length, r = a[0] + '';
        for(; i < j;){
            s = a[i++] + '';
            z = LOG_BASE - s.length;
            for(; z--; s = '0' + s);
            r += s;
        }
        // Determine trailing zeros.
        for(j = r.length; r.charCodeAt(--j) === 48;);
        return r.slice(0, j + 1 || 1);
    }
    // Compare the value of BigNumbers x and y.
    function compare(x, y) {
        var a, b, xc = x.c, yc = y.c, i = x.s, j = y.s, k = x.e, l = y.e;
        // Either NaN?
        if (!i || !j) return null;
        a = xc && !xc[0];
        b = yc && !yc[0];
        // Either zero?
        if (a || b) return a ? b ? 0 : -j : i;
        // Signs differ?
        if (i != j) return i;
        a = i < 0;
        b = k == l;
        // Either Infinity?
        if (!xc || !yc) return b ? 0 : !xc ^ a ? 1 : -1;
        // Compare exponents.
        if (!b) return k > l ^ a ? 1 : -1;
        j = (k = xc.length) < (l = yc.length) ? k : l;
        // Compare digit by digit.
        for(i = 0; i < j; i++)if (xc[i] != yc[i]) return xc[i] > yc[i] ^ a ? 1 : -1;
        // Compare lengths.
        return k == l ? 0 : k > l ^ a ? 1 : -1;
    }
    /*
   * Check that n is a primitive number, an integer, and in range, otherwise throw.
   */ function intCheck(n, min, max, name) {
        if (n < min || n > max || n !== mathfloor(n)) {
            throw Error(bignumberError + (name || 'Argument') + (typeof n == 'number' ? n < min || n > max ? ' out of range: ' : ' not an integer: ' : ' not a primitive number: ') + String(n));
        }
    }
    // Assumes finite n.
    function isOdd(n) {
        var k = n.c.length - 1;
        return bitFloor(n.e / LOG_BASE) == k && n.c[k] % 2 != 0;
    }
    function toExponential(str, e) {
        return (str.length > 1 ? str.charAt(0) + '.' + str.slice(1) : str) + (e < 0 ? 'e' : 'e+') + e;
    }
    function toFixedPoint(str, e, z) {
        var len, zs;
        // Negative exponent?
        if (e < 0) {
            // Prepend zeros.
            for(zs = z + '.'; ++e; zs += z);
            str = zs + str;
        // Positive exponent
        } else {
            len = str.length;
            // Append zeros.
            if (++e > len) {
                for(zs = z, e -= len; --e; zs += z);
                str += zs;
            } else if (e < len) {
                str = str.slice(0, e) + '.' + str.slice(e);
            }
        }
        return str;
    }
    // EXPORT
    BigNumber = clone();
    BigNumber['default'] = BigNumber.BigNumber = BigNumber;
    // AMD.
    if (typeof define == 'function' && define.amd) {
        ((r)=>r !== undefined && __turbopack_context__.v(r))(function() {
            return BigNumber;
        }(__turbopack_context__.r, exports, module));
    // Node.js and other environments that support module.exports.
    } else if (("TURBOPACK compile-time value", "object") != 'undefined' && module.exports) {
        module.exports = BigNumber;
    // Browser.
    } else {
        if (!globalObject) {
            globalObject = typeof self != 'undefined' && self ? self : window;
        }
        globalObject.BigNumber = BigNumber;
    }
})(/*TURBOPACK member replacement*/ __turbopack_context__.e);
}),
"[project]/node_modules/eventsource/lib/eventsource.js [app-ssr] (ecmascript)", ((__turbopack_context__, module, exports) => {

var parse = __turbopack_context__.r("[externals]/url [external] (url, cjs)").parse;
var events = __turbopack_context__.r("[externals]/events [external] (events, cjs)");
var https = __turbopack_context__.r("[externals]/https [external] (https, cjs)");
var http = __turbopack_context__.r("[externals]/http [external] (http, cjs)");
var util = __turbopack_context__.r("[externals]/util [external] (util, cjs)");
var httpsOptions = [
    'pfx',
    'key',
    'passphrase',
    'cert',
    'ca',
    'ciphers',
    'rejectUnauthorized',
    'secureProtocol',
    'servername',
    'checkServerIdentity'
];
var bom = [
    239,
    187,
    191
];
var colon = 58;
var space = 32;
var lineFeed = 10;
var carriageReturn = 13;
// Beyond 256KB we could not observe any gain in performance
var maxBufferAheadAllocation = 1024 * 256;
// Headers matching the pattern should be removed when redirecting to different origin
var reUnsafeHeader = /^(cookie|authorization)$/i;
function hasBom(buf) {
    return bom.every(function(charCode, index) {
        return buf[index] === charCode;
    });
}
/**
 * Creates a new EventSource object
 *
 * @param {String} url the URL to which to connect
 * @param {Object} [eventSourceInitDict] extra init params. See README for details.
 * @api public
 **/ function EventSource(url, eventSourceInitDict) {
    var readyState = EventSource.CONNECTING;
    var headers = eventSourceInitDict && eventSourceInitDict.headers;
    var hasNewOrigin = false;
    Object.defineProperty(this, 'readyState', {
        get: function() {
            return readyState;
        }
    });
    Object.defineProperty(this, 'url', {
        get: function() {
            return url;
        }
    });
    var self = this;
    self.reconnectInterval = 1000;
    self.connectionInProgress = false;
    function onConnectionClosed(message) {
        if (readyState === EventSource.CLOSED) return;
        readyState = EventSource.CONNECTING;
        _emit('error', new Event('error', {
            message: message
        }));
        // The url may have been changed by a temporary redirect. If that's the case,
        // revert it now, and flag that we are no longer pointing to a new origin
        if (reconnectUrl) {
            url = reconnectUrl;
            reconnectUrl = null;
            hasNewOrigin = false;
        }
        setTimeout(function() {
            if (readyState !== EventSource.CONNECTING || self.connectionInProgress) {
                return;
            }
            self.connectionInProgress = true;
            connect();
        }, self.reconnectInterval);
    }
    var req;
    var lastEventId = '';
    if (headers && headers['Last-Event-ID']) {
        lastEventId = headers['Last-Event-ID'];
        delete headers['Last-Event-ID'];
    }
    var discardTrailingNewline = false;
    var data = '';
    var eventName = '';
    var reconnectUrl = null;
    function connect() {
        var options = parse(url);
        var isSecure = options.protocol === 'https:';
        options.headers = {
            'Cache-Control': 'no-cache',
            'Accept': 'text/event-stream'
        };
        if (lastEventId) options.headers['Last-Event-ID'] = lastEventId;
        if (headers) {
            var reqHeaders = hasNewOrigin ? removeUnsafeHeaders(headers) : headers;
            for(var i in reqHeaders){
                var header = reqHeaders[i];
                if (header) {
                    options.headers[i] = header;
                }
            }
        }
        // Legacy: this should be specified as `eventSourceInitDict.https.rejectUnauthorized`,
        // but for now exists as a backwards-compatibility layer
        options.rejectUnauthorized = !(eventSourceInitDict && !eventSourceInitDict.rejectUnauthorized);
        if (eventSourceInitDict && eventSourceInitDict.createConnection !== undefined) {
            options.createConnection = eventSourceInitDict.createConnection;
        }
        // If specify http proxy, make the request to sent to the proxy server,
        // and include the original url in path and Host headers
        var useProxy = eventSourceInitDict && eventSourceInitDict.proxy;
        if (useProxy) {
            var proxy = parse(eventSourceInitDict.proxy);
            isSecure = proxy.protocol === 'https:';
            options.protocol = isSecure ? 'https:' : 'http:';
            options.path = url;
            options.headers.Host = options.host;
            options.hostname = proxy.hostname;
            options.host = proxy.host;
            options.port = proxy.port;
        }
        // If https options are specified, merge them into the request options
        if (eventSourceInitDict && eventSourceInitDict.https) {
            for(var optName in eventSourceInitDict.https){
                if (httpsOptions.indexOf(optName) === -1) {
                    continue;
                }
                var option = eventSourceInitDict.https[optName];
                if (option !== undefined) {
                    options[optName] = option;
                }
            }
        }
        // Pass this on to the XHR
        if (eventSourceInitDict && eventSourceInitDict.withCredentials !== undefined) {
            options.withCredentials = eventSourceInitDict.withCredentials;
        }
        req = (isSecure ? https : http).request(options, function(res) {
            self.connectionInProgress = false;
            // Handle HTTP errors
            if (res.statusCode === 500 || res.statusCode === 502 || res.statusCode === 503 || res.statusCode === 504) {
                _emit('error', new Event('error', {
                    status: res.statusCode,
                    message: res.statusMessage
                }));
                onConnectionClosed();
                return;
            }
            // Handle HTTP redirects
            if (res.statusCode === 301 || res.statusCode === 302 || res.statusCode === 307) {
                var location = res.headers.location;
                if (!location) {
                    // Server sent redirect response without Location header.
                    _emit('error', new Event('error', {
                        status: res.statusCode,
                        message: res.statusMessage
                    }));
                    return;
                }
                var prevOrigin = new URL(url).origin;
                var nextOrigin = new URL(location).origin;
                hasNewOrigin = prevOrigin !== nextOrigin;
                if (res.statusCode === 307) reconnectUrl = url;
                url = location;
                process.nextTick(connect);
                return;
            }
            if (res.statusCode !== 200) {
                _emit('error', new Event('error', {
                    status: res.statusCode,
                    message: res.statusMessage
                }));
                return self.close();
            }
            readyState = EventSource.OPEN;
            res.on('close', function() {
                res.removeAllListeners('close');
                res.removeAllListeners('end');
                onConnectionClosed();
            });
            res.on('end', function() {
                res.removeAllListeners('close');
                res.removeAllListeners('end');
                onConnectionClosed();
            });
            _emit('open', new Event('open'));
            // text/event-stream parser adapted from webkit's
            // Source/WebCore/page/EventSource.cpp
            var buf;
            var newBuffer;
            var startingPos = 0;
            var startingFieldLength = -1;
            var newBufferSize = 0;
            var bytesUsed = 0;
            res.on('data', function(chunk) {
                if (!buf) {
                    buf = chunk;
                    if (hasBom(buf)) {
                        buf = buf.slice(bom.length);
                    }
                    bytesUsed = buf.length;
                } else {
                    if (chunk.length > buf.length - bytesUsed) {
                        newBufferSize = buf.length * 2 + chunk.length;
                        if (newBufferSize > maxBufferAheadAllocation) {
                            newBufferSize = buf.length + chunk.length + maxBufferAheadAllocation;
                        }
                        newBuffer = Buffer.alloc(newBufferSize);
                        buf.copy(newBuffer, 0, 0, bytesUsed);
                        buf = newBuffer;
                    }
                    chunk.copy(buf, bytesUsed);
                    bytesUsed += chunk.length;
                }
                var pos = 0;
                var length = bytesUsed;
                while(pos < length){
                    if (discardTrailingNewline) {
                        if (buf[pos] === lineFeed) {
                            ++pos;
                        }
                        discardTrailingNewline = false;
                    }
                    var lineLength = -1;
                    var fieldLength = startingFieldLength;
                    var c;
                    for(var i = startingPos; lineLength < 0 && i < length; ++i){
                        c = buf[i];
                        if (c === colon) {
                            if (fieldLength < 0) {
                                fieldLength = i - pos;
                            }
                        } else if (c === carriageReturn) {
                            discardTrailingNewline = true;
                            lineLength = i - pos;
                        } else if (c === lineFeed) {
                            lineLength = i - pos;
                        }
                    }
                    if (lineLength < 0) {
                        startingPos = length - pos;
                        startingFieldLength = fieldLength;
                        break;
                    } else {
                        startingPos = 0;
                        startingFieldLength = -1;
                    }
                    parseEventStreamLine(buf, pos, fieldLength, lineLength);
                    pos += lineLength + 1;
                }
                if (pos === length) {
                    buf = void 0;
                    bytesUsed = 0;
                } else if (pos > 0) {
                    buf = buf.slice(pos, bytesUsed);
                    bytesUsed = buf.length;
                }
            });
        });
        req.on('error', function(err) {
            self.connectionInProgress = false;
            onConnectionClosed(err.message);
        });
        if (req.setNoDelay) req.setNoDelay(true);
        req.end();
    }
    connect();
    function _emit() {
        if (self.listeners(arguments[0]).length > 0) {
            self.emit.apply(self, arguments);
        }
    }
    this._close = function() {
        if (readyState === EventSource.CLOSED) return;
        readyState = EventSource.CLOSED;
        if (req.abort) req.abort();
        if (req.xhr && req.xhr.abort) req.xhr.abort();
    };
    function parseEventStreamLine(buf, pos, fieldLength, lineLength) {
        if (lineLength === 0) {
            if (data.length > 0) {
                var type = eventName || 'message';
                _emit(type, new MessageEvent(type, {
                    data: data.slice(0, -1),
                    lastEventId: lastEventId,
                    origin: new URL(url).origin
                }));
                data = '';
            }
            eventName = void 0;
        } else if (fieldLength > 0) {
            var noValue = fieldLength < 0;
            var step = 0;
            var field = buf.slice(pos, pos + (noValue ? lineLength : fieldLength)).toString();
            if (noValue) {
                step = lineLength;
            } else if (buf[pos + fieldLength + 1] !== space) {
                step = fieldLength + 1;
            } else {
                step = fieldLength + 2;
            }
            pos += step;
            var valueLength = lineLength - step;
            var value = buf.slice(pos, pos + valueLength).toString();
            if (field === 'data') {
                data += value + '\n';
            } else if (field === 'event') {
                eventName = value;
            } else if (field === 'id') {
                lastEventId = value;
            } else if (field === 'retry') {
                var retry = parseInt(value, 10);
                if (!Number.isNaN(retry)) {
                    self.reconnectInterval = retry;
                }
            }
        }
    }
}
module.exports = EventSource;
util.inherits(EventSource, events.EventEmitter);
EventSource.prototype.constructor = EventSource; // make stacktraces readable
[
    'open',
    'error',
    'message'
].forEach(function(method) {
    Object.defineProperty(EventSource.prototype, 'on' + method, {
        /**
     * Returns the current listener
     *
     * @return {Mixed} the set function or undefined
     * @api private
     */ get: function get() {
            var listener = this.listeners(method)[0];
            return listener ? listener._listener ? listener._listener : listener : undefined;
        },
        /**
     * Start listening for events
     *
     * @param {Function} listener the listener
     * @return {Mixed} the set function or undefined
     * @api private
     */ set: function set(listener) {
            this.removeAllListeners(method);
            this.addEventListener(method, listener);
        }
    });
});
/**
 * Ready states
 */ Object.defineProperty(EventSource, 'CONNECTING', {
    enumerable: true,
    value: 0
});
Object.defineProperty(EventSource, 'OPEN', {
    enumerable: true,
    value: 1
});
Object.defineProperty(EventSource, 'CLOSED', {
    enumerable: true,
    value: 2
});
EventSource.prototype.CONNECTING = 0;
EventSource.prototype.OPEN = 1;
EventSource.prototype.CLOSED = 2;
/**
 * Closes the connection, if one is made, and sets the readyState attribute to 2 (closed)
 *
 * @see https://developer.mozilla.org/en-US/docs/Web/API/EventSource/close
 * @api public
 */ EventSource.prototype.close = function() {
    this._close();
};
/**
 * Emulates the W3C Browser based WebSocket interface using addEventListener.
 *
 * @param {String} type A string representing the event type to listen out for
 * @param {Function} listener callback
 * @see https://developer.mozilla.org/en/DOM/element.addEventListener
 * @see http://dev.w3.org/html5/websockets/#the-websocket-interface
 * @api public
 */ EventSource.prototype.addEventListener = function addEventListener(type, listener) {
    if (typeof listener === 'function') {
        // store a reference so we can return the original function again
        listener._listener = listener;
        this.on(type, listener);
    }
};
/**
 * Emulates the W3C Browser based WebSocket interface using dispatchEvent.
 *
 * @param {Event} event An event to be dispatched
 * @see https://developer.mozilla.org/en-US/docs/Web/API/EventTarget/dispatchEvent
 * @api public
 */ EventSource.prototype.dispatchEvent = function dispatchEvent(event) {
    if (!event.type) {
        throw new Error('UNSPECIFIED_EVENT_TYPE_ERR');
    }
    // if event is instance of an CustomEvent (or has 'details' property),
    // send the detail object as the payload for the event
    this.emit(event.type, event.detail);
};
/**
 * Emulates the W3C Browser based WebSocket interface using removeEventListener.
 *
 * @param {String} type A string representing the event type to remove
 * @param {Function} listener callback
 * @see https://developer.mozilla.org/en/DOM/element.removeEventListener
 * @see http://dev.w3.org/html5/websockets/#the-websocket-interface
 * @api public
 */ EventSource.prototype.removeEventListener = function removeEventListener(type, listener) {
    if (typeof listener === 'function') {
        listener._listener = undefined;
        this.removeListener(type, listener);
    }
};
/**
 * W3C Event
 *
 * @see http://www.w3.org/TR/DOM-Level-3-Events/#interface-Event
 * @api private
 */ function Event(type, optionalProperties) {
    Object.defineProperty(this, 'type', {
        writable: false,
        value: type,
        enumerable: true
    });
    if (optionalProperties) {
        for(var f in optionalProperties){
            if (optionalProperties.hasOwnProperty(f)) {
                Object.defineProperty(this, f, {
                    writable: false,
                    value: optionalProperties[f],
                    enumerable: true
                });
            }
        }
    }
}
/**
 * W3C MessageEvent
 *
 * @see http://www.w3.org/TR/webmessaging/#event-definitions
 * @api private
 */ function MessageEvent(type, eventInitDict) {
    Object.defineProperty(this, 'type', {
        writable: false,
        value: type,
        enumerable: true
    });
    for(var f in eventInitDict){
        if (eventInitDict.hasOwnProperty(f)) {
            Object.defineProperty(this, f, {
                writable: false,
                value: eventInitDict[f],
                enumerable: true
            });
        }
    }
}
/**
 * Returns a new object of headers that does not include any authorization and cookie headers
 *
 * @param {Object} headers An object of headers ({[headerName]: headerValue})
 * @return {Object} a new object of headers
 * @api private
 */ function removeUnsafeHeaders(headers) {
    var safe = {};
    for(var key in headers){
        if (reUnsafeHeader.test(key)) {
            continue;
        }
        safe[key] = headers[key];
    }
    return safe;
}
}),
"[project]/node_modules/lucide-react/dist/esm/shared/src/utils.js [app-ssr] (ecmascript)", ((__turbopack_context__) => {
"use strict";

/**
 * @license lucide-react v0.553.0 - ISC
 *
 * This source code is licensed under the ISC license.
 * See the LICENSE file in the root directory of this source tree.
 */ __turbopack_context__.s([
    "hasA11yProp",
    ()=>hasA11yProp,
    "mergeClasses",
    ()=>mergeClasses,
    "toCamelCase",
    ()=>toCamelCase,
    "toKebabCase",
    ()=>toKebabCase,
    "toPascalCase",
    ()=>toPascalCase
]);
const toKebabCase = (string)=>string.replace(/([a-z0-9])([A-Z])/g, "$1-$2").toLowerCase();
const toCamelCase = (string)=>string.replace(/^([A-Z])|[\s-_]+(\w)/g, (match, p1, p2)=>p2 ? p2.toUpperCase() : p1.toLowerCase());
const toPascalCase = (string)=>{
    const camelCase = toCamelCase(string);
    return camelCase.charAt(0).toUpperCase() + camelCase.slice(1);
};
const mergeClasses = (...classes)=>classes.filter((className, index, array)=>{
        return Boolean(className) && className.trim() !== "" && array.indexOf(className) === index;
    }).join(" ").trim();
const hasA11yProp = (props)=>{
    for(const prop in props){
        if (prop.startsWith("aria-") || prop === "role" || prop === "title") {
            return true;
        }
    }
};
;
 //# sourceMappingURL=utils.js.map
}),
"[project]/node_modules/lucide-react/dist/esm/defaultAttributes.js [app-ssr] (ecmascript)", ((__turbopack_context__) => {
"use strict";

/**
 * @license lucide-react v0.553.0 - ISC
 *
 * This source code is licensed under the ISC license.
 * See the LICENSE file in the root directory of this source tree.
 */ __turbopack_context__.s([
    "default",
    ()=>defaultAttributes
]);
var defaultAttributes = {
    xmlns: "http://www.w3.org/2000/svg",
    width: 24,
    height: 24,
    viewBox: "0 0 24 24",
    fill: "none",
    stroke: "currentColor",
    strokeWidth: 2,
    strokeLinecap: "round",
    strokeLinejoin: "round"
};
;
 //# sourceMappingURL=defaultAttributes.js.map
}),
"[project]/node_modules/lucide-react/dist/esm/Icon.js [app-ssr] (ecmascript)", ((__turbopack_context__) => {
"use strict";

/**
 * @license lucide-react v0.553.0 - ISC
 *
 * This source code is licensed under the ISC license.
 * See the LICENSE file in the root directory of this source tree.
 */ __turbopack_context__.s([
    "default",
    ()=>Icon
]);
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$dist$2f$server$2f$route$2d$modules$2f$app$2d$page$2f$vendored$2f$ssr$2f$react$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/next/dist/server/route-modules/app-page/vendored/ssr/react.js [app-ssr] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$lucide$2d$react$2f$dist$2f$esm$2f$defaultAttributes$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/lucide-react/dist/esm/defaultAttributes.js [app-ssr] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$lucide$2d$react$2f$dist$2f$esm$2f$shared$2f$src$2f$utils$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/lucide-react/dist/esm/shared/src/utils.js [app-ssr] (ecmascript)");
;
;
;
const Icon = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$dist$2f$server$2f$route$2d$modules$2f$app$2d$page$2f$vendored$2f$ssr$2f$react$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["forwardRef"])(({ color = "currentColor", size = 24, strokeWidth = 2, absoluteStrokeWidth, className = "", children, iconNode, ...rest }, ref)=>(0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$dist$2f$server$2f$route$2d$modules$2f$app$2d$page$2f$vendored$2f$ssr$2f$react$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["createElement"])("svg", {
        ref,
        ...__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$lucide$2d$react$2f$dist$2f$esm$2f$defaultAttributes$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["default"],
        width: size,
        height: size,
        stroke: color,
        strokeWidth: absoluteStrokeWidth ? Number(strokeWidth) * 24 / Number(size) : strokeWidth,
        className: (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$lucide$2d$react$2f$dist$2f$esm$2f$shared$2f$src$2f$utils$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["mergeClasses"])("lucide", className),
        ...!children && !(0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$lucide$2d$react$2f$dist$2f$esm$2f$shared$2f$src$2f$utils$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["hasA11yProp"])(rest) && {
            "aria-hidden": "true"
        },
        ...rest
    }, [
        ...iconNode.map(([tag, attrs])=>(0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$dist$2f$server$2f$route$2d$modules$2f$app$2d$page$2f$vendored$2f$ssr$2f$react$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["createElement"])(tag, attrs)),
        ...Array.isArray(children) ? children : [
            children
        ]
    ]));
;
 //# sourceMappingURL=Icon.js.map
}),
"[project]/node_modules/lucide-react/dist/esm/createLucideIcon.js [app-ssr] (ecmascript)", ((__turbopack_context__) => {
"use strict";

/**
 * @license lucide-react v0.553.0 - ISC
 *
 * This source code is licensed under the ISC license.
 * See the LICENSE file in the root directory of this source tree.
 */ __turbopack_context__.s([
    "default",
    ()=>createLucideIcon
]);
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$dist$2f$server$2f$route$2d$modules$2f$app$2d$page$2f$vendored$2f$ssr$2f$react$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/next/dist/server/route-modules/app-page/vendored/ssr/react.js [app-ssr] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$lucide$2d$react$2f$dist$2f$esm$2f$shared$2f$src$2f$utils$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/lucide-react/dist/esm/shared/src/utils.js [app-ssr] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$lucide$2d$react$2f$dist$2f$esm$2f$Icon$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/lucide-react/dist/esm/Icon.js [app-ssr] (ecmascript)");
;
;
;
const createLucideIcon = (iconName, iconNode)=>{
    const Component = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$dist$2f$server$2f$route$2d$modules$2f$app$2d$page$2f$vendored$2f$ssr$2f$react$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["forwardRef"])(({ className, ...props }, ref)=>(0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$dist$2f$server$2f$route$2d$modules$2f$app$2d$page$2f$vendored$2f$ssr$2f$react$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["createElement"])(__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$lucide$2d$react$2f$dist$2f$esm$2f$Icon$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["default"], {
            ref,
            iconNode,
            className: (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$lucide$2d$react$2f$dist$2f$esm$2f$shared$2f$src$2f$utils$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["mergeClasses"])(`lucide-${(0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$lucide$2d$react$2f$dist$2f$esm$2f$shared$2f$src$2f$utils$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["toKebabCase"])((0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$lucide$2d$react$2f$dist$2f$esm$2f$shared$2f$src$2f$utils$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["toPascalCase"])(iconName))}`, `lucide-${iconName}`, className),
            ...props
        }));
    Component.displayName = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$lucide$2d$react$2f$dist$2f$esm$2f$shared$2f$src$2f$utils$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["toPascalCase"])(iconName);
    return Component;
};
;
 //# sourceMappingURL=createLucideIcon.js.map
}),
"[project]/node_modules/lucide-react/dist/esm/icons/wallet.js [app-ssr] (ecmascript)", ((__turbopack_context__) => {
"use strict";

/**
 * @license lucide-react v0.553.0 - ISC
 *
 * This source code is licensed under the ISC license.
 * See the LICENSE file in the root directory of this source tree.
 */ __turbopack_context__.s([
    "__iconNode",
    ()=>__iconNode,
    "default",
    ()=>Wallet
]);
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$lucide$2d$react$2f$dist$2f$esm$2f$createLucideIcon$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/lucide-react/dist/esm/createLucideIcon.js [app-ssr] (ecmascript)");
;
const __iconNode = [
    [
        "path",
        {
            d: "M19 7V4a1 1 0 0 0-1-1H5a2 2 0 0 0 0 4h15a1 1 0 0 1 1 1v4h-3a2 2 0 0 0 0 4h3a1 1 0 0 0 1-1v-2a1 1 0 0 0-1-1",
            key: "18etb6"
        }
    ],
    [
        "path",
        {
            d: "M3 5v14a2 2 0 0 0 2 2h15a1 1 0 0 0 1-1v-4",
            key: "xoc0q4"
        }
    ]
];
const Wallet = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$lucide$2d$react$2f$dist$2f$esm$2f$createLucideIcon$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["default"])("wallet", __iconNode);
;
 //# sourceMappingURL=wallet.js.map
}),
"[project]/node_modules/lucide-react/dist/esm/icons/wallet.js [app-ssr] (ecmascript) <export default as Wallet>", ((__turbopack_context__) => {
"use strict";

__turbopack_context__.s([
    "Wallet",
    ()=>__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$lucide$2d$react$2f$dist$2f$esm$2f$icons$2f$wallet$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["default"]
]);
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$lucide$2d$react$2f$dist$2f$esm$2f$icons$2f$wallet$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/lucide-react/dist/esm/icons/wallet.js [app-ssr] (ecmascript)");
}),
"[project]/node_modules/lucide-react/dist/esm/icons/target.js [app-ssr] (ecmascript)", ((__turbopack_context__) => {
"use strict";

/**
 * @license lucide-react v0.553.0 - ISC
 *
 * This source code is licensed under the ISC license.
 * See the LICENSE file in the root directory of this source tree.
 */ __turbopack_context__.s([
    "__iconNode",
    ()=>__iconNode,
    "default",
    ()=>Target
]);
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$lucide$2d$react$2f$dist$2f$esm$2f$createLucideIcon$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/lucide-react/dist/esm/createLucideIcon.js [app-ssr] (ecmascript)");
;
const __iconNode = [
    [
        "circle",
        {
            cx: "12",
            cy: "12",
            r: "10",
            key: "1mglay"
        }
    ],
    [
        "circle",
        {
            cx: "12",
            cy: "12",
            r: "6",
            key: "1vlfrh"
        }
    ],
    [
        "circle",
        {
            cx: "12",
            cy: "12",
            r: "2",
            key: "1c9p78"
        }
    ]
];
const Target = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$lucide$2d$react$2f$dist$2f$esm$2f$createLucideIcon$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["default"])("target", __iconNode);
;
 //# sourceMappingURL=target.js.map
}),
"[project]/node_modules/lucide-react/dist/esm/icons/target.js [app-ssr] (ecmascript) <export default as Target>", ((__turbopack_context__) => {
"use strict";

__turbopack_context__.s([
    "Target",
    ()=>__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$lucide$2d$react$2f$dist$2f$esm$2f$icons$2f$target$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["default"]
]);
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$lucide$2d$react$2f$dist$2f$esm$2f$icons$2f$target$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/lucide-react/dist/esm/icons/target.js [app-ssr] (ecmascript)");
}),
"[project]/node_modules/lucide-react/dist/esm/icons/trending-up.js [app-ssr] (ecmascript)", ((__turbopack_context__) => {
"use strict";

/**
 * @license lucide-react v0.553.0 - ISC
 *
 * This source code is licensed under the ISC license.
 * See the LICENSE file in the root directory of this source tree.
 */ __turbopack_context__.s([
    "__iconNode",
    ()=>__iconNode,
    "default",
    ()=>TrendingUp
]);
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$lucide$2d$react$2f$dist$2f$esm$2f$createLucideIcon$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/lucide-react/dist/esm/createLucideIcon.js [app-ssr] (ecmascript)");
;
const __iconNode = [
    [
        "path",
        {
            d: "M16 7h6v6",
            key: "box55l"
        }
    ],
    [
        "path",
        {
            d: "m22 7-8.5 8.5-5-5L2 17",
            key: "1t1m79"
        }
    ]
];
const TrendingUp = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$lucide$2d$react$2f$dist$2f$esm$2f$createLucideIcon$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["default"])("trending-up", __iconNode);
;
 //# sourceMappingURL=trending-up.js.map
}),
"[project]/node_modules/lucide-react/dist/esm/icons/trending-up.js [app-ssr] (ecmascript) <export default as TrendingUp>", ((__turbopack_context__) => {
"use strict";

__turbopack_context__.s([
    "TrendingUp",
    ()=>__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$lucide$2d$react$2f$dist$2f$esm$2f$icons$2f$trending$2d$up$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["default"]
]);
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$lucide$2d$react$2f$dist$2f$esm$2f$icons$2f$trending$2d$up$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/lucide-react/dist/esm/icons/trending-up.js [app-ssr] (ecmascript)");
}),
"[project]/node_modules/lucide-react/dist/esm/icons/arrow-left.js [app-ssr] (ecmascript)", ((__turbopack_context__) => {
"use strict";

/**
 * @license lucide-react v0.553.0 - ISC
 *
 * This source code is licensed under the ISC license.
 * See the LICENSE file in the root directory of this source tree.
 */ __turbopack_context__.s([
    "__iconNode",
    ()=>__iconNode,
    "default",
    ()=>ArrowLeft
]);
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$lucide$2d$react$2f$dist$2f$esm$2f$createLucideIcon$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/lucide-react/dist/esm/createLucideIcon.js [app-ssr] (ecmascript)");
;
const __iconNode = [
    [
        "path",
        {
            d: "m12 19-7-7 7-7",
            key: "1l729n"
        }
    ],
    [
        "path",
        {
            d: "M19 12H5",
            key: "x3x0zl"
        }
    ]
];
const ArrowLeft = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$lucide$2d$react$2f$dist$2f$esm$2f$createLucideIcon$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["default"])("arrow-left", __iconNode);
;
 //# sourceMappingURL=arrow-left.js.map
}),
"[project]/node_modules/lucide-react/dist/esm/icons/arrow-left.js [app-ssr] (ecmascript) <export default as ArrowLeft>", ((__turbopack_context__) => {
"use strict";

__turbopack_context__.s([
    "ArrowLeft",
    ()=>__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$lucide$2d$react$2f$dist$2f$esm$2f$icons$2f$arrow$2d$left$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["default"]
]);
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$lucide$2d$react$2f$dist$2f$esm$2f$icons$2f$arrow$2d$left$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/lucide-react/dist/esm/icons/arrow-left.js [app-ssr] (ecmascript)");
}),
"[project]/node_modules/lucide-react/dist/esm/icons/copy.js [app-ssr] (ecmascript)", ((__turbopack_context__) => {
"use strict";

/**
 * @license lucide-react v0.553.0 - ISC
 *
 * This source code is licensed under the ISC license.
 * See the LICENSE file in the root directory of this source tree.
 */ __turbopack_context__.s([
    "__iconNode",
    ()=>__iconNode,
    "default",
    ()=>Copy
]);
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$lucide$2d$react$2f$dist$2f$esm$2f$createLucideIcon$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/lucide-react/dist/esm/createLucideIcon.js [app-ssr] (ecmascript)");
;
const __iconNode = [
    [
        "rect",
        {
            width: "14",
            height: "14",
            x: "8",
            y: "8",
            rx: "2",
            ry: "2",
            key: "17jyea"
        }
    ],
    [
        "path",
        {
            d: "M4 16c-1.1 0-2-.9-2-2V4c0-1.1.9-2 2-2h10c1.1 0 2 .9 2 2",
            key: "zix9uf"
        }
    ]
];
const Copy = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$lucide$2d$react$2f$dist$2f$esm$2f$createLucideIcon$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["default"])("copy", __iconNode);
;
 //# sourceMappingURL=copy.js.map
}),
"[project]/node_modules/lucide-react/dist/esm/icons/copy.js [app-ssr] (ecmascript) <export default as Copy>", ((__turbopack_context__) => {
"use strict";

__turbopack_context__.s([
    "Copy",
    ()=>__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$lucide$2d$react$2f$dist$2f$esm$2f$icons$2f$copy$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["default"]
]);
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$lucide$2d$react$2f$dist$2f$esm$2f$icons$2f$copy$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/lucide-react/dist/esm/icons/copy.js [app-ssr] (ecmascript)");
}),
"[project]/node_modules/lucide-react/dist/esm/icons/check.js [app-ssr] (ecmascript)", ((__turbopack_context__) => {
"use strict";

/**
 * @license lucide-react v0.553.0 - ISC
 *
 * This source code is licensed under the ISC license.
 * See the LICENSE file in the root directory of this source tree.
 */ __turbopack_context__.s([
    "__iconNode",
    ()=>__iconNode,
    "default",
    ()=>Check
]);
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$lucide$2d$react$2f$dist$2f$esm$2f$createLucideIcon$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/lucide-react/dist/esm/createLucideIcon.js [app-ssr] (ecmascript)");
;
const __iconNode = [
    [
        "path",
        {
            d: "M20 6 9 17l-5-5",
            key: "1gmf2c"
        }
    ]
];
const Check = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$lucide$2d$react$2f$dist$2f$esm$2f$createLucideIcon$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["default"])("check", __iconNode);
;
 //# sourceMappingURL=check.js.map
}),
"[project]/node_modules/lucide-react/dist/esm/icons/check.js [app-ssr] (ecmascript) <export default as Check>", ((__turbopack_context__) => {
"use strict";

__turbopack_context__.s([
    "Check",
    ()=>__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$lucide$2d$react$2f$dist$2f$esm$2f$icons$2f$check$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["default"]
]);
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$lucide$2d$react$2f$dist$2f$esm$2f$icons$2f$check$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/lucide-react/dist/esm/icons/check.js [app-ssr] (ecmascript)");
}),
"[project]/node_modules/lucide-react/dist/esm/icons/plus.js [app-ssr] (ecmascript)", ((__turbopack_context__) => {
"use strict";

/**
 * @license lucide-react v0.553.0 - ISC
 *
 * This source code is licensed under the ISC license.
 * See the LICENSE file in the root directory of this source tree.
 */ __turbopack_context__.s([
    "__iconNode",
    ()=>__iconNode,
    "default",
    ()=>Plus
]);
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$lucide$2d$react$2f$dist$2f$esm$2f$createLucideIcon$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/lucide-react/dist/esm/createLucideIcon.js [app-ssr] (ecmascript)");
;
const __iconNode = [
    [
        "path",
        {
            d: "M5 12h14",
            key: "1ays0h"
        }
    ],
    [
        "path",
        {
            d: "M12 5v14",
            key: "s699le"
        }
    ]
];
const Plus = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$lucide$2d$react$2f$dist$2f$esm$2f$createLucideIcon$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["default"])("plus", __iconNode);
;
 //# sourceMappingURL=plus.js.map
}),
"[project]/node_modules/lucide-react/dist/esm/icons/plus.js [app-ssr] (ecmascript) <export default as Plus>", ((__turbopack_context__) => {
"use strict";

__turbopack_context__.s([
    "Plus",
    ()=>__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$lucide$2d$react$2f$dist$2f$esm$2f$icons$2f$plus$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["default"]
]);
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$lucide$2d$react$2f$dist$2f$esm$2f$icons$2f$plus$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/lucide-react/dist/esm/icons/plus.js [app-ssr] (ecmascript)");
}),
];

//# sourceMappingURL=node_modules_8a8de2fc._.js.map